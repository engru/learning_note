# 数据结构与算法

# 1.各种排序算法的比较

![image-20190113183152661](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190113183152661-7375512.png)

![image-20190113183210737](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190113183210737-7375530.png)

注：

1、归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间，

2、快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。

# 2.数据结构

#### 数据的逻辑结构分为线性结构和非线性结构。 

常用的**线性结构**有：线性表，栈，队列，双队列，数组，串。 
常见的**非线性结构**有：二维数组，多维数组，广义表，树(二叉树等)，图，堆。

## 2.1 链表

1.若频繁删除某线性表的第1个元素，则不宜采用以下哪种存储方式	:顺序表

```
单链表
顺序表
单向循环链表
双链表
```

​	对顺序表来说，删除第一个元素就需要后续元素都向前移动一个位置。每删除一次都需要移动大量元素，因此不宜采用。**挪动剩余的n-1个，花销o(N)**

2.顺序表和链表
顺序表

- 优点：查找和修改（首先要查找到）效率高，空间占用比链表小，时间复杂度 O(1)
- 缺点：插入和删除元素时，后面的元素都需要进行移动，编译时确定大小，时间复杂度 O(n)

链表

- 优点：插入和删除元素比较方便，只需要修改指针，空间大小不必指定，时间复杂度 O(n)
- 缺点：查询和修改（首先要查找到）效率并不高，而且因为添加了指针等中间数据结构，所以空间占用比顺序表大，时间复杂度 O(1)

3.栈可以是顺序存储，也可以是链式存储，与存储结构无关。循环队列是队列的顺序存储结构，链表是线性表的链式存储结构，用散列法存储的线性表叫散列表，都与存储结构有关。

4.广义表有如下三个特性：
	1.层次性：广义表的元素可以是子表，而子表的元素还可以是子表，由此，广义表是一个多层次的结构；
	2.共享性：广义表可为其他表所共享。
	3.递归表：广义表可以是其自身的一个子表。

## 2.2 数组

1.在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度。因为数组是**一个引用类型变量** ，因此**使用它定义一个变量时，仅仅定义了一个变量** **，这个引用变量还未指向任何有效的内存** **，因此定义数组不能指定数组的长度**。只有在实例化时才可以指定长度，如：String[] arr=new String[50];

2.在定义 int a\[3]\[4][2]; 后，第 20 个元素是

​	首先，总共有三层(0~2)，然后每层都是一个二维数组\[4\][2]，所以总共有3*4\*2=24个元素，所以20个元素就是第三层开始，然后2--16=4，差4个元素，所以是a[2]\[1][1]，后面二维数组是[1]\[1]表示2\*2=4

## 2.3 树

1.最佳二叉树指的是哈夫曼树，但是哈夫曼树不一定就是平衡二叉树，哈夫曼树指的是最短加权路径最短。

2.设一棵二叉树的深度为k，则该二叉树中最多有（2^k-1）个结点。

3.前中后序遍历：

前序：先根节点，再左结点最后右结点

中序：先左结点，再根结点最后右结点

后序：先左结点，再右结点最后根结点

4.高度的定义为：从结点x向下到某个叶结点**最长简单路径**中**边的条数**

5.二分搜索树的中序遍历结果是升序排列的元素

6.空树也是平衡二叉树

## 2.4 栈

​	==利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素,这种形式的栈也称为顺序栈==。虽然链栈也可以实现地址连续，但无法做到依次存放数据元素，因为除了元素域还需要存放指针域。因此满足条件的只有顺序栈。

​	top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增，top所指向的对象永远是栈顶元素。

## 2.5 堆

1.每次删除元素或者插入元素的时候，都是从数组最后一个数开始上浮。

2.堆排序复杂度分析

```
堆排序的时间复杂度为O(nlogn)
整个构建堆的时间复杂度为O(n)
堆排序的空间复杂度为O(1)
堆排序是一种不稳定的排序算法
```

# 3.算法总结

哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题。

- Java 中的 **HashSet** 用于存储一个集合，可以查找元素是否在集合中。如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在。例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。
- Java 中的 **HashMap** 主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。例如在一个简化 url 的系统中 [Leetcdoe : 535. Encode and Decode TinyURL (Medium)](https://leetcode.com/problems/encode-and-decode-tinyurl/description/)，利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源。









