# JVM(1)

## 一、JVM内存结构

### 1.运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。 这些组成部分一些是线程私有的，其他的则是线程共享的。

![è¿è¡æ¶æ°æ®åºå](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f32372f313633303661333463643861343335343f773d35313326683d34303426663d706e6726733d313332303638-1544494988876.jpg)

**其中，线程私有的：程序计数器，虚拟机栈和本地方法栈。**

**线程共享的：堆，方法区和直接内存。**

#### 1.1 程序计数器：

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。==字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令==，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

**从上面的介绍中我们知道程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**注意：==程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。==**

#### 1.2 Java 虚拟机栈

​	**与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。**

​	**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java虚拟机栈是由一个个栈帧组成，而**每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。**）

​	**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

​	**==其中，64位的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型占用1个。局部变量表所需要的内存空间是在编译时期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行时期不会改变局部变量表的大小。==**

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

- **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，**那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候**，就抛出StackOverFlowError异常。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，**如果扩展时无法申请到足够的内存**，此时抛出OutOfMemoryError异常。

Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

#### 1.3 本地方法栈

​	和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

​	==本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。==方法执行完毕后相应的栈帧也会出栈并释放内存空间，**也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。**

#### 1.4 堆

​	==Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。==**此内存区域的唯一目的就是==存放对象实例==，几乎所有的对象实例以及数组都在这里分配内存。**

​	Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32352f313635373033343461323963333433333f773d35393926683d32353026663d706e6726733d38393436.jpg)

**在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。**

​	**Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，在实现时，可以通过-Xmx和-Xms参数进行大小的调整，如果在堆中没有内存完成实例分配，并且堆也无法扩展时，将会抛出 OutOfMemoryError 异常。**

#### 1.5 方法区

​	**方法区与 Java 堆一样，是各个==线程共享==的内存区域，它用于==存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。==虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。**

​	HotSpot 虚拟机中方法区也常被称为 **“永久代”**，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。

**相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。**

##### 	当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。

#### 1.6 运行时常量池

​	**运行时常量池是方法区的一部分。**Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

​	==既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。==

**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，==在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。==**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31342f32363033383433332e6a7067.jpg)

#### 1.7 直接内存

​	直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致**OutOfMemoryError异常出现**。

​	JDK1.4中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，==它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。==这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

**本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。**

## 2.HotSpot 虚拟机对象探秘

通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。

#### 2.1 对象的创建

下图便是 Java 对象的创建过程。 ![Javaå¯¹è±¡çåå"ºè¿ç¨](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363165353961343133353836393f773d39353026683d32373926663d706e6726733d3238353239.jpg)

**①类加载检查：** 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数==是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过==。如果没有，那必须先执行相应的类加载过程。

**②分配内存：** 在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。**对象所需的内存大小在类加载完成后便可确定，**==为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。==**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的==垃圾收集器是否带有压缩整理功能决定==**。

##### **内存分配的两种方式：**

​	**选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363165353961343061326333643f773d3134323626683d33333326663d706e6726733d3236333436.jpg)

##### **内存分配并发问题**

​	在创建对象的时候有一个很重要的问题，就是**线程安全**，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **==CAS+失败重试：==** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **==TLAB：==** 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配

**③初始化零值：** 内存分配完成后，**虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，**程序能访问到这些字段的数据类型所对应的零值。

**④设置对象头：** 初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

**⑤执行 init 方法：** 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，**<init> 方法还没有执行，所有的字段都还为零。**所以一般来说，==执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。==

#### 2.2 对象的内存布局

​	在 Hotspot 虚拟机中，==对象在内存中的布局可以分为3块区域：**对象头**、**实例数据**和**对齐填充**。==

**Hotspot虚拟机的对象头(Mark Word)包括两部分信息**，**第一部分用于存储对象自身的自身运行时数据**（哈希码、GC分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，**虚拟机通过这个指针来确定这个对象是哪个类的实例。**

​	==Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。==

​	**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。**这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。**HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。

​	**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位符作用。** 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

#### 2.3 对象的访问定位

​	建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有==**①使用句柄**和**②直接指针**==两种：

1. **句柄：** **如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；** ![ä½¿ç¨å¥æ](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f32372f313633303662393537333936383934363f773d37383626683d33363226663d706e6726733d313039323031.jpg)
2. **直接指针：** **如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。**![ä½¿ç¨ç´æ¥æé](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f32372f313633303662613361343162366236353f773d37363626683d33353326663d706e6726733d3939313732.jpg)

   **这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**

### 3.重点补充内容

#### String 类和常量池

##### **1 String 对象的两种创建方式：**

```Java
     String str1 = "abcd";   //常量池中获取
     String str2 = new String("abcd");	//创建一个对象实例
     System.out.println(str1==str2);//false
```

​	这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。==只要使用new方法，便需要创建新的对象。==

 ![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363165353961353963303837333f773d36393826683d33353526663d706e6726733d3130343439.jpg)

**2 String 类型的常量池比较特殊。它的主要使用方法有两种：**

- ==直接使用双引号声明出来的 String 对象会直接存储在常量池中。==
- 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。==String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。==

```Java
	      String s1 = new String("计算机");
	      String s2 = s1.intern();
	      String s3 = "计算机";
	      System.out.println(s2);//计算机
	      System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象，一个是常量池中的String对象，
	      System.out.println(s3 == s2);//true，因为两个都是常量池中的String对象
```

**3 String 字符串拼接**

```Java
		  String str1 = "str";
		  String str2 = "ing";
		  
		  String str3 = "str" + "ing";//常量池中的对象
		  String str4 = str1 + str2; //在堆上创建的新的对象	  
		  String str5 = "string";//常量池中的对象
		  System.out.println(str3 == str4);//false
		  System.out.println(str3 == str5);//true
		  System.out.println(str4 == str5);//false
```

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363165353961346431336639323f773d35393326683d36303326663d706e6726733d3232323635.jpg)

​	尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。

##### 4.详解：

String s=new String("acbc")；	创建了两个对象，先有字符串"abc"放入常量池，然后 new 了一份字符串"abc"放入Java堆(字符串常量"abc"在编译期就已经确定放入常量池，而 Java 堆上的"abc"是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的"abc"。

##### 5.常量池内存延伸：

- ##### **==Java 基本类型的包装类的大部分都实现了常量池技术==，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值==[-128，127]这个范围内==的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。**

- **==两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。==**

```Java
		Integer i1 = 33;
		Integer i2 = 33;
		System.out.println(i1 == i2);// 输出true
		Integer i11 = 333;
		Integer i22 = 333;
		System.out.println(i11 == i22);// 输出false
		Double i3 = 1.2;
		Double i4 = 1.2;
		System.out.println(i3 == i4);// 输出false
```

**Integer 缓存源代码：**

```Java
/**
*此方法将始终缓存-128到127（包括端点）范围内的值，并可以缓存此范围之外的其他值。
*/
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
```

**应用场景：**

1. Integer i1=40；Java 在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。
2. Integer i1 = new Integer(40);这种情况下会创建新的对象。

```Java
  Integer i1 = 40;
  Integer i2 = new Integer(40);
  System.out.println(i1==i2);//输出false
```

**Integer比较更丰富的一个例子:**

```Java
  Integer i1 = 40;
  Integer i2 = 40;
  Integer i3 = 0;
  Integer i4 = new Integer(40);
  Integer i5 = new Integer(40);
  Integer i6 = new Integer(0);
  
  System.out.println("i1=i2   " + (i1 == i2));
  System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
  System.out.println("i1=i4   " + (i1 == i4));
  System.out.println("i4=i5   " + (i4 == i5));
  System.out.println("i4=i5+i6   " + (i4 == i5 + i6));   
  System.out.println("40=i5+i6   " + (40 == i5 + i6));     
```

结果：

```
i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
```

解释：

语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。**然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40**，最终这条语句转为40 == 40进行数值比较。	

##### 	String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。

## 二、JVM垃圾回收

### 1.JVM内存分配与回收

​	**Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。**同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。

**JDK1.8之前的堆内存示意图：**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32352f313635373033343461323963333433333f773d35393926683d32353026663d706e6726733d38393436-1544514899922.jpg)

从上图可以看出==堆内存分为新生代、老年代和永久代。==**新生代又被进一步分为：Eden 区＋Survivor1 区＋Survivor2 区。**值得注意的是，**在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域**（永久代使用的是JVM的堆内存空间，而==元空间使用的是物理内存，直接受到本机的物理内存限制==）。![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f38393239343534372e6a7067.jpg)

#### 1.1 对象优先在eden区分配

​	目前主流的垃圾收集器都会采用分代回收算法，因此需要将**堆内存分为新生代和老年代**，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

大多数情况下，**对象在新生代中 eden 区分配**。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC.下面我们来进行实际测试以下。

在测试之前我们先来看看 **Minor GC和Full GC 有什么不同呢？**

- **新生代GC（Minor GC）**:指发生==新生代==的的垃圾收集动作，**Minor GC非常频繁，回收速度一般也比较快。**
- **老年代GC（Major GC/Full GC）**:指发生在**老年代**的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。

**测试：**

```Java
public class GCTest {
	public static void main(String[] args) {
		byte[] allocation1, allocation2;
		allocation1 = new byte[30900*1024];
		//allocation2 = new byte[900*1024];
	}
}
```

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f32353137383335302e6a7067.jpg)

添加的参数：`-XX:+PrintGCDetails` ![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f31303331373134362e6a7067.jpg)

运行结果：![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f32383935343238362e6a7067.jpg)

​	从上图我们可以看出**==eden区(新生代中)内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用2000多k内存）。==**假如我们再为allocation2分配内存会出现什么情况呢？

```Java
allocation2 = new byte[900*1024];
```

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f32383132383738352e6a7067.jpg)

​	**简单解释一下为什么会出现这种情况：** 因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了**当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC**。GC期间虚拟机又发现allocation1无法存入Survivor空间，所以只好通过 **分配担保机制** 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，**后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。**可以执行如下代码验证：

```Java
public class GCTest {
	public static void main(String[] args) {
		byte[] allocation1, allocation2,allocation3,allocation4,allocation5;
		allocation1 = new byte[32000*1024];
		allocation2 = new byte[1000*1024];
		allocation3 = new byte[1000*1024];
		allocation4 = new byte[1000*1024];
		allocation5 = new byte[1000*1024];
	}
}
```

#### 1.2 大对象直接进入老年代

​	==大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。这是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。==

#### 1.3 长期存活的对象将进入老年代

​	既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，==虚拟机给每个对象一个对象年龄（Age）计数器==。

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

#### 1.4 动态对象年龄判定

​	为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。

### 2.判断对象是否死亡

​	**堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f31313033343235392e6a7067.jpg)

#### 2.1 引用计数法

​	**给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。**

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它==很难解决对象之间相互循环引用的问题。==** 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。

```Java
public class ReferenceCountingGc {
    Object instance = null;
	public static void main(String[] args) {
		ReferenceCountingGc objA = new ReferenceCountingGc();
		ReferenceCountingGc objB = new ReferenceCountingGc();
		objA.instance = objB;
		objB.instance = objA;
		objA = null;
		objB = null;

	}
}
```

#### 2.2 可达性分析算法

​	基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，**从这些节点开始向下搜索，节点所走过的路径称为引用链**，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。![å¯è¾¾æ§åæç®æ³](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f37323736323034392e6a7067.jpg)

##### 在Java语言中，可作为GC Roots的对象包括下面几种：

​	**虚拟机栈（栈帧中的本地变量表）中引用的对象。**

​	**方法区中类静态属性引用的对象。方法区中常量引用的对象。**

​	**本地方法栈中JNI（即一般说的Native方法）引用的对象。**

#### 2.3 再谈引用

​	无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。

​	JDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。

​	JDK1.2以后，Java对引用的概念进行了扩充，**将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）**

##### **1．强引用**

​	以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。==当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。==

##### **2．软引用（SoftReference）**

​	如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。**==软引用可用来实现内存敏感的高速缓存。==**

​	软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。**在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。**

##### **3．弱引用（WeakReference）**

​	如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。==弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。==**在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。**不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

​	弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。**被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。**

##### **4．虚引用（PhantomReference）**

​	"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

**虚引用主要用来跟踪对象被垃圾回收的活动**。

​	**虚引用与软引用和弱引用的一个区别在于：** **虚引用必须和引用队列（ReferenceQueue）联合使用。**当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

#### 2.4 不可达的对象并非“非死不可”

​	即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；**可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。**

​	**==如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。==**这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。**finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。**

​	任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。**不建议使用finalize这个方法。**

#### 2.5 如何判断一个常量是废弃常量

​	**运行时常量池主要回收的是废弃的常量。**那么，我们如何判断一个常量是废弃常量呢？

​	假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

#### 2.6 如何判断一个类是无用的类

**方法区主要回收的是无用的类，**那么如何判断一个类是无用的类的呢？

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 **“无用的类”** ：

- **该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。**
- **加载该类的 ClassLoader 已经被回收。**
- **该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。**

虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

### 3 垃圾收集算法

![åå¾æ¶éç®æ³](687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f313134323732332e6a7067.jpg)

#### 3.1 标记-清除算法

​	算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：

1. **==效率问题==**
2. **==空间问题（标记清除后会产生大量不连续的碎片）==![æ è®°-æ¸é¤ç®æ³](687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f36333730373238312e6a7067.jpg)**

   **复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。所以在老年代一般不能直接选用这种算法。**

#### 3.2 复制算法

​	为了解决效率问题，“复制”收集算法出现了。它可以将**内存分为大小相同的两块，每次使用其中的一块**。当这一块的内存使用完后，**就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。**这样就使每次的内存回收都是对内存区间的一半进行回收。![å¤å¶ç®æ³](687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f39303938343632342e6a7067.jpg)

#### 3.3 标记-整理算法

​	根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是**让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。**![æ è®°-æ´çç®æ³](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f39343035373034392e6a7067.jpg)

#### 3.4 分代收集算法

​	当前虚拟机的垃圾收集都采用==分代收集算法==，这种算法没有什么新的思想，只是**根据对象存活周期的不同将内存分为几块。一般将==java堆分为新生代和老年代，==**这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

**比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

### 4 垃圾收集器                           ![img](https://camo.githubusercontent.com/0d92016056cd3fd259cc0565429132b26ed94207/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f34313436303935352e6a7067)

**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**

​	虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，**我们能做的就是根据具体应用场景选择适合自己的垃圾收集器**。

##### JVM的server模式和client模式：

​	JVM有两种运行模式Server与Client。**两种模式的区别在于，Client模式启动速度较快，Server模式启动较慢；但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。**这是因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化；而Client模式启动的JVM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。

​	通过java -version 可以查看是 server vm 还是 client vm，可以通过jvm.cfg配置文件进行修改。

#### 4.1 Serial收集器

​	Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候==必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束==。**新生代采用复制算法，老年代采用标记-整理算法**![ Serialæ¶éå¨](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f34363837333032362e6a7067.jpg)

​	**虚拟机在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。**

​	虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。

不过，它**简单而高效（与其他收集器的单线程相比）**。==Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。==

#### 4.2 ParNew收集器

​	**ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。**

它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

##### **并行和并发概念补充：**

- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而**垃圾收集器运行在另一个CPU上。**

#### 4.3 Parallel Scavenge收集器

​	**Parallel Scavenge 收集器类似于ParNew 收集器。** 自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

```Java
-XX:+UseParallelGC 		使用Parallel收集器+ 老年代串行
-XX:+UseParallelOldGC   使用Parallel收集器+ 老年代并行
```

​	**Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。==CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。==** **所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%**。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。 

​	Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 -XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的 -XX：GCTimeRatio参数。

#### 4.4.Serial Old收集器
​	==这是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。==这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它主要有两大用途：**一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。**

#### 4.5 Parallel Old收集器

​	**Parallel Scavenge收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。

#### 4.6 CMS收集器

​	**CMS（Concurrent Mark Sweep）收集器是一种以==获取最短回收停顿时间为目标的收集器。==它非常符合在注重用户体验的应用上使用。**

**CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS收集器是一种 **==“标记-清除”算法==**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下GC Roots能直接关联到的对象，速度很快 ；

- **并发标记：** ==同时开启GC和用户线程，用一个闭包结构去记录可达对象。==但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

- **重新标记：** 重新标记阶段就是为了修正并发标记期间，因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短

- **并发清除：** 开启用户线程，同时GC线程开始对为标记的区域做清扫。![image-20181226154908502](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181226154908502-5810548.png)

  从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

  - **对CPU资源敏感；**
  - **无法处理浮动垃圾；**
  - **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

  #### 4.7 G1收集器

  ​	**G1 (Garbage-First)是一款==面向服务器==的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.**

  被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：

  - **并行与并发**：**G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。**部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
  - **分代收集**：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。
  - **空间整合**：与CMS的“标记--清理”算法不同，**G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。**
  - **可预测的停顿**：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。

  G1收集器的运作大致分为以下几个步骤：

  - **初始标记**
  - **并发标记**
  - **最终标记**
  - **筛选回收**

  **G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)**。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

  ### 5 内存分配与回收策略

  #### 5.1对象优先在Eden区分配

  ##### 	大多数情况下，对象在新生代中Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

  **Minor Gc和Full GC 有什么不同呢？**

  **新生代GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。

  **老年代GC（Major GC/Full GC）**:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。

  #### 5.2 大对象直接进入老年代

  ##### 	大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

  ​	**虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）。**

  #### 5.3长期存活的对象将进入老年代

  ​	既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。为了做到这一点，**虚拟机给每个对象一个对象年龄（Age）计数器。**如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。

  #### 5.4 动态对象年龄判定

  ​	为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，**如果Survivor 空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到MaxTenuringThreshold中要求的年龄。**

  #### 5.5 空间分配担保

  ​	**在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。**如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。

  ### 6 理解GC日志

  ​	先来看一段日志：

  ```
  33.125：[GC[DefNew：3324K-＞152K（3712K），0.0025925 secs]3324K-＞152K（11904K），0.0031680 secs]
  100.667：[FullGC[Tenured：0K-＞210K（10240K），0.0149142secs]4603K-＞210K（19456K），[Perm：2999K-＞2999K（21248K）]，0.0150007 secs][Times：user=0.01 sys=0.00，real=0.02 secs]
  ```

  ​	最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，**这个数字的含义是从Java虚拟机启动以来经过的秒数。**==GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，==而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（**这一般是因为出现了分配担保失败之类的问题，所以才导致STW**）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“[Full GC（System）”

  ```
  [Full GC 283.736：[ParNew：261599K-＞261599K（261952K），0.0000288 secs]
  ```

  ​	**接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，**例如上面样例所使用的Serial收集器中的新生代名为“DefaultNew Generation”，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变为“[ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。

  ​	后面方括号内部的**“3324K-＞152K（3712K）”含义是“GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-＞152K（11904K）”表示“GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）”。**再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。

  ### 7 垃圾收集器参数总结

  ![image-20181226161833674](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181226161833674-5812313.png)

  ![image-20181226161843389](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181226161843389-5812323.png)


## 三、JDK监控和故障处理工具

- **jps**：JVM Process Status Tool ,显示指定系统内所有的HotSpot虚拟机进程
- **jstat**: JVM Statistics Monitoring Tool ,用于收集HotSpot虚拟机各方面的运行数据。
- **jinfo**: Configuration Info forJava,显示虚拟机配置信息
- **jmap**: Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）
- **jhat**: JVM Heap Dump Browser ,用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果
- **jstack**: Stack Trace forJava，显示虚拟机的线程快照

#### 2.1 jps:虚拟机进程状况工具

​	JDK的很多小工具的名字都参考了UNIX命令的命名方式，**jps（JVM Process Status）**是其中的典型。除了名字像UNIX的ps命令外，它的功能也和ps命令类似：**可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID**（Local Virtual Machine Identifier,LVMID）。虽然功能比较单一，但它是使用最高的JDK命令行工具，因为其他的JDK工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。**jps的常用功能选项：**![image-20181226160225527](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181226160225527-5811345.png)

#### 2.2 jstat:虚拟机统计信息监视工具

**jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。** 它可以显示本地或者远程（需要远程主机提供RMI支持）虚拟机进程中的类信息、内存、垃圾收集、JIT编译等运行数据，在没有GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。![image-20181226160252701](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181226160252701-5811372.png)

### 2.3 jinfo：Java配置信息工具

**jinfo（Configuration Info for Java） 的作用是实时地查看和调整虚拟机各项参数。**使用jps命令的-v可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，可以使用jinfo的-flag选项进行查询，**jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。**![image-20181226160307603](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181226160307603-5811387.png)

### 2.4 jmap：Java内存映像工具

**jmap（Memory Map for Java）命令用于生成堆转储快照。** 如果不使用jmap命令，要想获取Java堆转储，可以使用“-XX:+HeapDumpOnOutOfMemoryError”参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，Linux命令下可以通过kill -3发送进程退出信号也能拿到dump文件。

**jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等**。和jinfo一样，jmap有不少功能在Windows平台下也是受限制的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux和Solaris系统下使用。

### 2.5 jstack：Java堆栈跟踪工具

**jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.**

**生成线程快照的目的主要是定位线程长时间出现停顿的原因**，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。**

## 3 JDK可视化工具：

**JConsole和VisualVM是两个功能强大的可视化工具。**

从Java 5开始 引入了 JConsole，JConsole 是一个内置 Java 性能分析器。您可以轻松地使用 JConsole（或者，它更高端的 “近亲” jvisualvm ）来监控 Java 应用程序性能和跟踪 Java 中的代码。（推荐使用升级版 JConsole 即 jvisualvm 。）

控制台启动或者直接双击可执行程序。![image-20181226160330858](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181226160330858-5811411.png)

![image-20181226160347102](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181226160347102-5811427.png)

我们再来看看**jvisualvm**

![image-20181226160755489](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181226160755489-5881433.png)

## 四、Class类文件结构

### 1 概述

​	计算机虽然只能识别0和1，但是越来越多的程序语言选择了与操作系统和机器指令集无关无关的、平台中立的格式作为程序编译后的存储格式。==Java虚拟机不和包括Java在内的任何语言绑定，只与 **"Class文件"** 这种特定的二进制文件所关联，Class文件中包含了Java虚拟机指令集合符号表以及若干其它辅助信息。==Java虚拟机作为一个通用的、机器无关的执行平台，任何其他语言都可以将其作为语言的产品交付媒介。 ![image-20181230104838913](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181230104838913-6138119.png)

### 2 Class类文件结构

​	**==注意:任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。==**

​	Class文件是一组以8位字节为基础的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，**中间没有添加任何分隔符**，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。**当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。**

**Class文件格式采用一种类似于C语言结构体的伪结构来存储数，这种伪结构有两种数据类型：无符号数和表。**

​	==无符号数==属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

​	==表==是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，**整个Class文件本质上就是一张表，**它由表6-1所示的数据项构成。![image-20181230105832504](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181230105832504-6138712.png)

​	这里需要重复提一下，Class文件结构不像XML等描述语言，由于它没有任何分割符号，所以无论是数量甚至于数据存储的字节序这样的细节都被严格限定，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。

#### 2.1 魔数与Class文件版本

​	==每个Class文件的头四个字节称为魔数（Magic Number）==,它的唯一作用是**确定这个文件是否为一个能被虚拟机接收的Class文件**。紧接着魔数的四个字节存储的是Class文件的版本号：第五和第六是**次版本号**，第七和第八是**主版本号**。

#### 2.2 常量池

​	紧接着主次版本号之后的是常量池入口，**常量池可以理解为Class文件之中的资源仓库**，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，==同时它还是在Class文件中第一个出现的表类型数据项目==。**常量池主要存放两大常量：字面量和符号引用**。**字面量**比较接近于java语言层面的的常量概念，如文本字符串、声明为final的常量值等。而**符号引用**则属于编译原理方面的概念。包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

​        Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是**在虚拟机加载Class文件的时候进行动态连接。**也就是说，==在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。==

#### 2.3访问标志

​	**在常量池结束之后，紧接着的两个字节代表访问标志，**这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否为public或者abstract类型，如果是类的话是否声明为final等等。具体标志位及标志的含义如下图所示：![image-20181230201748979](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181230201748979-6172269.png)

#### 2.4 类索引、父类索引与接口索引集合

​	**类索引、父类索引与接口索引集合都按顺序排列在访问标志之后，类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件由这三项数据来确定这个类的继承关系**。**类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名**，==由于java语言的单继承，所以父类索引只有一个，除了java.lang.Object之外，所有的java类都有父类，因此**除了java.lang.Object外，所有java类的父类索引都不为0**。==**接口索引集合用来描述这个类实现了那些接口**，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends)后的接口顺序从左到右排列在接口索引集合中。

#### 2.5 字段表集合

​	**字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。**

**在java中描述一个字段可以包含**字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型、字段名称等信息。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。

##### 下面区分一些“简单名称”、“描述符”以及“全限定名”

- 全限定名：就是这个类的绝对路径，如：“org/fenixsoft/clazz/TestClass”是TestClass这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，**在使用时最后一般会加入一个“；”表示全限定名结束。**

- 简单名称：指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别是“inc”和“m”

- 描述符：==用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。==根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而**对象类型则用字符L加对象的全限定名来表示**，详见下表：![image-20181230203932261](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181230203932261-6173572.png)

  ​	对于数组类型，**每一维度将使用一个前置的“[”字符来描述，**如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava/lang/String==；==”，一个整型数组“int[]”将被记录为“[I”**。用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内**。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String；”，方法intindexOf(char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex)的描述符为“([CII[CIII)I”

#### 2.6方法表集合

​	Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。==方法标的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。== 在这里稍微提一下，**因为volatile修饰符和transient修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了synchronized、native、abstract等关键字修饰方法，所以也就多了这些关键字对应的标志**。

#### 2.7 属性表结合

​	在Class文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与Class文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，**并且只要不与已有的属性名重复**，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。

### 3 字节码指令简介

​	Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。

#### 3.1字节码与数据类型

​	**在java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息，**例如：==iload指令用于从局部变量表中加载int类型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能是同一段代码实现的，但在Class文件中它们必须拥有各自独立的操作码。==

​	**大部分的指令都没有支持整数类型byte、char、short甚至没有任何指令支持boolean类型。大多数对于byte、char、short、boolean类型的操作，实际上都是使用相应的int类型作为运算符类型。**

#### 3.2 加载和存储指令

​	==加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。==这类指令主要有：![image-20190125122538319](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190125122538319.png)

​	**存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。**	

#### 3.3 运算指令

​	**==运算或算术指令用于对操作数栈上的值进行某种特定运算，并把结果重新存入操作栈顶==**。 **大体上算术指令可以分为两种：对整型数据和对浮点数据进行运算指令。**（由于没有byte、char、short、boolean类型，所以对这类数据的运算应使用int类型指令代替）![image-20181230214428548](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20181230214428548-6177468.png)

#### 3.4 类型转换指令

​	**类型转换指令可以将两种不同的数值类型进行相互转换。**（比如int类型转换为float类型） 小范围到大范围类型安全转换，无需显式的转换指令，否则必须显式的使用转换指令来完成。即从等级低的到高的可以安全转换，而等级高的到低的，需要显示使用转换指令。

​	处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成，这些转换指令包括：i2b(int到byte)、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。

#### 3.5 对象创建与访问指令

​	虽然类实例和数组都是对象，但java虚拟机对类实例和数组的创建和操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下：

![image-20190101170113412](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190101170113412-6333273.png)

#### 3.6 操作数栈管理指令

​	如同操作数据结构中的栈一样，java虚拟机也提供了一些用于**直接操作操作数栈**的指令，如：

将操作数栈的栈顶一个或两个元素出栈：==pop、pop2。==

复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：==dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。==

将栈最顶端的两个数值互换：==swap。==

#### 3.7 控制转移指令

​	**可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。**控制转移指令如下：

​	条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。

​	复合条件分支：tableswitch、lookupswitch。

​	无条件分支：goto、goto_w_w、jsr、jsr_w_w、ret。

#### 3.8 方法调用和返回指令

- invokevirtual 指令用于调用对象的实例方法
- invokeinterface指令用于调用接口方法
- invokespecial指令用于调用一些需要特殊处理的实例方法
- invokestatic指令用于调用类方法（static方法）
- invokedynamic指令用于在运行时动态解析出调用点限定符所使用的方法。

方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的。

#### 3.9 异常处理指令

​	**在java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表的方式。**

#### 3.10 同步指令

​	java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构使用管程（Monitor）来支持的。

​	在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。

##### 	方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。

## 4 虚拟机实现的两种方式

- 将输入的java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集
- 将输入的java虚拟机代码在加载或执行时翻译成宿主主机CPU的本地指令集（即JIT代码生成技术）

## 5 class文件结构的发展

​	Class文件结构已经有十多年历史了，这10多年间，java技术体系有了翻天覆地的变化，但是Class文件结构一直处于比较稳定的状态，Class文件的主体结构、字节码指令的语义和数量几乎没有出现过变动，所有Class文件格式的改进，都集中在向访问标志、属性表这些在设计上就可扩展的数据结构中添加内容。

## 五、虚拟机类加载机制

### 1 概述

#### 1.1 虚拟机类加载机制的概念

​	==虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化。最终形成可以被虚拟机最直接使用的java类型的过程就是虚拟机的类加载机制。==

#### 1.2 Java语言的动态加载和动态连接

​	另外需要注意的很重要的一点是：**java语言中类型的加载连接以及初始化过程都是在==程序运行期间==**
**(程序运行期间即是运行.class文件期间，.class文件是源代码.java文件编译后的文件)完成的**，这种策略虽然会使类加载时稍微增加一些性能开销，但是会为java应用程序提供高度的**灵活性**。java里天生就可以动态扩展语言特性就是==依赖运行期间动态加载和动态连接==这个特点实现的。比如，如果编写一个面向接口的程序，可以等到运行时再指定其具体实现类。

### 2 类加载时机

类从被加载到虚拟机内存到卸出内存为止，它的整个生命周期包括：![image-20190106232253416](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190106232253416-6788173.png)

我们思考一下那么**什么时候需要开始类加载的第一个阶段：加载？**

**虚拟机规范严格规定了==有且只有五种情况必须立即对类进行“初始化”：==**

- 使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，已经调用一个类的静态方法的时候。(静态资源属于类资源，所以如果调用了静态资源，其实就是需要加载这个类)
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。
- ==当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。==
- 当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类；
- 使用Jdk1.7动态语言支持的时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

而对于接口，当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口时（如引用父接口中定义的常量）才会初始化。

**==所有引用类的方式都不会触发初始化称为被动引用==，下面是3个被动引用例子：**

**①通过子类引用父类静态字段，不会导致子类初始化；②通过数组定义引用类，不会触发此类的初始化**

```Java
public class SuperClass {
	static {
		System.out.println("SuperClass（父类）被初始化了。。。");
	}
	public static int value = 66;
}
public class Subclass extends SuperClass {
	static {
		System.out.println("Subclass（子类）被初始化了。。。");
	}
}
public class Test1 {
	public static void main(String[] args) {
		// 1:通过子类调用父类的静态字段不会导致子类初始化        
		// System.out.println(Subclass.value);//SuperClass（父类）被初始化了。。。66        
		// 2:通过数组定义引用类，不会触发此类的初始化        
		SuperClass[] superClasses = new SuperClass[3];        
		// 3:通过new 创建对象,可以实现类初始化，必须把1下面的代码注释掉才有效果不然经过1的时候类已经初始化了，下面这条语句也就没用了。        
        //SuperClass superClass = new SuperClass();    
    }
}
```

**③常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用定义常量的类，因此不会触发定义常量的类的初始化**

```Java
public class ConstClass {
	static {
		System.out.println("ConstClass被初始化了。。。");
	}
	public static final String HELLO = "hello world";
}
public class Test2 {
	public static void main(String[] args) {
		System.out.println(ConstClass.HELLO);//输出结果：hello world    
	}
}
```

​	上述代码运行之后，也没有输出“ConstClass被初始化了。。。”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLO，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了Test2类的常量池中，以后对常量ConstClass.HELLO的引用实际都被转化为Test2类对自身常量池的引用了。也就是说，==实际上Test2的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。==

## 3 类加载过程

下面我们详细的说一下java虚拟机中类加载的全过程：==**加载**、**验证**、**准备**、**解析**和**初始化**==这5个阶段锁执行的具体工作。

### 3.1 加载

**“加载”** 是 **“类加载”** 过程的一个阶段，切不可将二者混淆。

**加载阶段由三个基本动作组成：**

​	1) 通过类型的完全限定名，**产生一个代表该类型的二进制数据流**

​	2) **解析这个二进制数据流为方法区内的运行时数据结构**

​	3) 创建一个表示该类型的java.lang.Class类的实例，作为方法区这个类的各种数据的访问入口。

**通过类型的完全限定名，产生一个代表该类型的二进制数据流的几种常见形式：**

- 从zip包中读取，成为日后JAR、EAR、WAR格式的基础；
- 从网络中获取，这种场景最典型的应用就是Applet;
- 运行时计算生成，这种场景最常用的就是动态代理技术了；
- 由其他文件生成，比如我们的JSP，即由jsp文件生成对应的class类。
- 从数据库中读取(比较少用)

**注意：** **数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。**非数组类加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成。（即重写一个类加载器的loadClass（）方法）

​	加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，**对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面**），这个对象将作为程序访问方法区中的这些类型数据的外部接口。

### 3.2 验证

​	验证是连接阶段的第一步，这一阶段的目的是==**为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全**。==

​	虚拟机如果不检查输入的字节流，并对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。这个阶段是否严谨，直接决定了java虚拟机是否能承受恶意代码的攻击。

##### 	从整体上看，验证阶段大致上会完成4个阶段的校验工作：**==文件格式、元数据、字节码、符号引用==**。

#### 3.2.1 文件格式验证

​	验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。该验证阶段的主要目的是==保证输入的字节流能正确地解析并存储于方法区之内。==这个阶段验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以==后面的3个阶段的全部是基于方法区的存储结构进行的，不会再直接操作字节流。==

如：

​	是否以魔数0xCAFEBABE开头。

​	主、次版本号是否在当前虚拟机处理范围之内。

​	常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。

​	指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。

​	……

#### 3.2.2 元数据验证

​	**该阶段对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，目的是保证不存在不符合Java语言规范的元数据信息**。

如：

​	这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。

​	这个类的父类是否继承了不允许被继承的类（被final修饰的类）。

​	如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。

#### 3.2.3 字节码验证

​	**该阶段主要工作是进行数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的==数据类型==做完校验后，这个阶段将对==类的方法体==进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。** 

如：保证跳转指令不会跳转到方法体以外的字节码指令上、保证方法体中的类型转换是有效的等等。

​	由于数据流校验的高复杂性，耗时较大，所以JDK1.6之后，在Javac中引入一项优化方法（可以通过参数关闭）：在方法体的Code属性的属性表中增加一项“StackMapTable”属性，该属性描述了方法体中所有基本块开始时本地变量表和操作栈应有的状态，从而将字节码验证的类型推导转变为类型检查从而节省一些时间。

**注意：**==如果一个方法体通过了字节码验证，也不能说明其一定是安全的，因为校验程序逻辑无法做到绝对精确。==

#### 3.2.4 符号引用验证

​	**最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。==符号引用验证的目的是确保解析动作能正常执行。==**

**验证的内容主要有：**

- 符号引用中通过字符串描述的全限定名是否能找到对应的类；
- 在指定类中是否存在符号方法的字段描述及简单名称所描述的方法和字段；
- 符号引用中的类、字段和方法的访问性（private、protected、public、default）是否可被当前类访问。

### 3.3 准备

​	**==准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将==在方法区中==进行分配。==**

##### （注意：这时候==进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量==，实例变量将会在对象实例化时随着对象一起分配在Java堆中）。

##### **==初始值通常是数据类型的零值：==**

​	如：public static int value = 123;，
​	**==变量value在准备阶段过后的初始值为0而不是123==，这时候尚未开始执行任何java方法，把value赋值为123的动作将在初始化阶段才会被执行。**

**一些特殊情况：**

​	如：public static **final** int value = 123;

​	编译时Javac将会为value生成ConstantValue属性，在**准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。**

**基本数据类型的零值：**![image-20190107114832326](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190107114832326-6832912.png)

### 3.4 解析

**==解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。==**

#### 3.4.1 符号引用和直接引用

**符号引用(Symbolic References)：** 符号引用以一组符号来描述所引用的目标，符号可以是符合约定的任何形式的字面量，==符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。==

**直接引用（Direct References）:** 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。**直接引用与虚拟机实现的内存布局相关，引用的目标必定已经在内存中存在。**

​	==虚拟机规范没有规定解析阶段发生的具体时间，虚拟机实现可以根据需要来判断到底是在类被加载时解析还是等到一个符号引用将要被使用前才去解析。==

#### 3.4.2 对解析结果进行缓存

​	同一符号引用进行多次解析请求是很常见的，**除invokedynamic指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。**无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。

#### 3.4.3 解析动作的目标

​	解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。前面四种引用的解析过程，对于后面三种，与JDK1.7新增的动态语言支持息息相关，由于java语言是一门静态类型语言，因此没有介绍invokedynamic指令的语义之前，没有办法将他们和现在的java语言对应上。

##### 1.类或接口的解析

​	假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：

​	1）如果C不是一个数组类型，那**虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。**在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。==一旦这个加载过程出现了任何异常，解析过程就宣告失败。==

​	2）如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似**“[Ljava/lang/Integer”**的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是**“java.lang.Integer”**，接着由虚拟机生成一个代表此数组维度和元素的数组对象。

​	3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，**但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。**

##### 2.字段解析

​	要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。**如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。**如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。

​	1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

​	2）否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

​	3）否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

​	4）否则，查找失败，抛出java.lang.NoSuchFieldError异常。如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。

​	在实际应用中，虚拟机的编译器实现可能会比上述规范要求得更加严格一些，**如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。**

##### 3.类方法解析

​	类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。

​	1）**类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。**

​	2）如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

​	3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

​	4）否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。

​	5）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。

##### 4.接口方法解析

​	接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。

​	1）与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。

​	2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

​	3）否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

​	4）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。

### 3.5 初始化

​	类初始化阶段是类加载的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。**到了初始化阶段，才真正开始执行类中定义的java程序代码（或者说是字节码）。**即在这一个阶段，虚拟机才开始加载程序员给变量所赋的值。

## 4 类加载器

### 4.1、类与类加载器

​	==对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。**如果两个类来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。**==

### 4.2 类加载器介绍

​	从Java虚拟机的角度分为两种不同的类加载器：**启动类加载器（Bootstrap ClassLoader）**和**其他类加载器**。其中启动类加载器，使用C++语言实现，是虚拟机自身的一部分；其余的类加载器都由Java语言实现，独立于虚拟机之外，并且全都继承自**java.lang.ClassLoader类**。（这里只限于HotSpot虚拟机）。

从Java开发人员的角度来看，绝大部分Java程序都会使用到以下3种系统提供的类加载器。

**启动类加载器（Bootstrap ClassLoader）：**

​	这个类加载器负责将存**放在＜JAVA_HOME＞\lib目录中**的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。

**扩展类加载器（Extension ClassLoader）：**

​	这个加载器由sun.misc.Launcher$ExtClassLoader实现，它**负责加载＜JAVA_HOME＞\lib\ext目录中**的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

**应用程序类加载器（Application ClassLoader）：**

​	这个类加载器由sun.misc.Launcher$AppClassLoader实现。**由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。**它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，**如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。**

​	我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如下图：

![image-20190107115600661](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190107115600661-6833360.png)

### 4.3 双亲委派模型

​	**双亲委派模型（Pattern Delegation Model）**,要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。**这里父子关系通常是子类通过组合关系而不是继承关系来复用父加载器的代码。**

​	**双亲委派模型的工作过程：** **如果一个类加载器收到了类加载的请求，先把这个请求委派给父类加载器去完成（==所以所有的加载请求最终都应该传送到顶层的启动类加载器中==），只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。**就像像上图那样，传递到最上层的启动类加载器。

​	使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是**java类随着它的类加载器一起具备了一种带有优先级的层次关系**。

​	实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass（）方法之中，如下：

```Java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            //首先，检查请求的类是否已经被加载过了
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
					//如果父类加载器抛出ClassNotFoundException
					//说明父类加载器无法完成加载请求
                }

                if (c == null) {
					//在父类加载器无法加载的时候
					//再调用本身的findClass方法来进行类加载
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

​	**先检查是否已经被加载过，若没有加载则调用父加载器的loadClass（）方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass（）方法进行加载。**

​	注意：双亲委派模型是Java设计者们推荐给开发者们的一种类加载器实现方式，并不是一个强制性 的约束模型。在java的世界中大部分的类加载器都遵循这个模型，但也有例外。

### 4.4 破坏双亲委派模型

​	双亲委派模型主要出现过3次较大规模“被破坏”的情况。

**第一次破坏**是因为类加载器和抽象类java.lang.ClassLoader在JDK1.0就存在的，而双亲委派模型在JDK1.2之后才被引入，为了兼容已经存在的用户自定义类加载器，引入双亲委派模型时做了一定的妥协：在java.lang.ClassLoader中引入了一个findClass()方法，在此之前，用户去继承java.lang.Classloader的唯一目的就是重写loadClass()方法。JDK1.2之后不提倡用户去覆盖loadClass()方法，而是把自己的类加载逻辑写到findClass()方法中，**如果loadClass()方法中，父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型规则的。**

**第二次破坏**是因为模型自身的缺陷，现实中存在这样的场景：基础的类加载器需要求调用用户的代码，而基础的类加载器可能不认识用户的代码。为此，Java设计团队引入的设计时“线程上下文类加载器（Thread Context ClassLoader）”。这样可以通过父类加载器请求子类加载器去完成类加载动作。已经违背了双亲委派模型的一般性原则。

**第三次破坏** 是由于用户对程序动态性的追求导致的。这里所说的动态性是指：“代码热替换”、“模块热部署”等等比较热门的词。说白了就是希望应用程序能够像我们的计算机外设一样，接上鼠标、U盘不用重启机器就能立即使用。OSGi是当前业界“事实上”的Java模块化标准，OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现。每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。**在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索**：

​	1）将以java.*开头的类委派给父类加载器加载。

​	2）否则，将委派列表名单内的类委派给父类加载器加载。

​	3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。

​	4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。

​	5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。

​	6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。

​	7）否则，类查找失败。

























































































































































