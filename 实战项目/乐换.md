# 一、前端

## 1.前端页面构建分页栏显示

```js
//定义搜索对象的结构，传给后端，充当搜索条件，除了spec是json，其他都是字符串，当需要新增搜索条件时，只需要在后面添加对应的key即可
    //pageNo：页码；pageSize：总页数
    $scope.searchMap = {
        'keywords': '', 'category': '', 'brand': '', 'spec': {}, 'price': '',
        'pageNo': 1, 'pageSize': 40, 'sort': '', 'sortField': ''};//搜索条件封装对象

//中间省略一堆代码

//构建分页栏
    //构建分页标签(totalPages为总页数),如果搜索的商品太多，会导致页面太多不美观，于是设定为最多显示五页：1,2,3,4,5，
    // 然后显示下一页，以当前页为中心的5个页码，要判断当前页要大于等于3，或者小于最大页码-2
    // 则显示结果为：1 2 3 4 5或：1 2 ... 5 6 7
    buildPageLabel = function () {
        //构建分页栏，即分页码1，2，3，4，5...
        $scope.pageLabel = [];  //新增分页栏数组
        // 8 9 10 11 12,8为开始页码，12位截止页码
        var firstPage = 1;  //开始页码
        var lastPage = $scope.resultMap.totalPages;//截止页码
        $scope.firstDot = true;     //前面有省略号小点
        $scope.lastDot = true;      //后边有省略号小点
        // 总页数分为两大类：多于5页，少于等于5页，
        // 少于等于于5页的时候，前后都不设置点，直接遍历存入分页栏数组即可
        // 多于5页的时候，分为三种情况，一种是当前页面少于等于3页的时候，前面不设置点；
                                // 当前页多于总页数-2的时候，从总页数-4开始，后面不设置点；
                                // 当前页大于3小于总页数-2的时候，显示当前页的前两页和当前页的后五页
        if ($scope.resultMap.totalPages > 5) {       //如果总页数大于5页,显示部分页码
            if ($scope.searchMap.pageNo <= 3) {     //如果当前页页码小于等于3
                lastPage = 5; //前5页
                $scope.firstDot = false;    //前面没点
            } else if ($scope.searchMap.pageNo >= lastPage - 2) {   //如果当前页大于等于最大页码-2
                firstPage = $scope.resultMap.totalPages - 4;		 //后5页
                $scope.lastDot = false;//后边没点
            } else { //显示当前页为中心的5页
                firstPage = $scope.searchMap.pageNo - 2;
                lastPage = $scope.searchMap.pageNo + 2;
            }
        } else {
            $scope.firstDot = false;//前面无点
            $scope.lastDot = false;//后边无点

        }
        //循环产生页码标签,从开始页码到截止页码，如果总页数小于5则全显示
        for (var i = firstPage; i <= lastPage; i++) {
            $scope.pageLabel.push(i);
        }
    }
```

​	写好后在js的查询方法中调用，再到HTML页面对应的页面遍历分页栏数组。

此外，分页还要注意就是第一页和最后一页的上一页和下一页是不能点的，可以通过两个方法来判断是否为第一页或者最后一页，然后在点击上一页和下一页的标签样式中调用，如果是第一页或者最后一页，则对应的标签样式是无效的。

```js
// controller.js
//判断当前页是否为第一页
$scope.isTopPage = function () {
    if ($scope.searchMap.pageNo == 1) {
        return true;
    } else {
        return false;
    }
}

//判断当前页是否为最后一页
$scope.isEndPage = function () {
    if ($scope.searchMap.pageNo == $scope.resultMap.totalPages) {
        return true;
    } else {
        return false;
    }
}
```

```html
<!--'disabled'表示是白色,即可以点击的，isTopPage判断是否为第一页，如果是的话点击的样式不可用-->
<li class="prev {{isTopPage()?'disabled':''}}">
    <a href="#" ng-click="queryByPage(searchMap.pageNo-1)">«</a>
</li>
<li class="next {{isEndPage()?'disabled':''}}">
    <a href="#" ng-click="queryByPage(searchMap.pageNo+1)">»</a>
</li>
```

## 2.FreeMarker生成文件，生产数据

使用步骤：

第一步：创建一个 Configuration 对象，直接 new 一个对象。构造方法的参数就是 freemarker的版本号。

第二步：设置模板文件所在的路径。

第三步：设置模板文件使用的字符集。一般就是 utf-8.

第四步：加载一个模板，创建一个模板对象。

第五步：创建一个模板使用的数据集，可以是 pojo 也可以是 map。一般是 Map。

第六步：创建一个 Writer 对象，一般创建一 FileWriter 对象，指定生成的文件名。

第七步：调用模板对象的 process 方法输出文件。

第八步：关闭流

### 模板文件中四种元素

  1、文本，直接输出的部分(body)
   2、注释，即<#--...-->格式不会输出
   3、插值（Interpolation）：==即${..}部分,将使用数据模型中的部分替代输出==，相当于调用数据
   4、FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。

模板文件：

```html
<html>
<head>
	<meta charset="utf-8">
	<title>Freemarker入门小DEMO </title>
</head>
<body>
<#--我只是一个注释，我不会有任何输出  -->
${name},你好。${message}
</body>
</html>
```

创建Test类 main方法如下：

```Java
	     //1.创建配置类(对象)
		Configuration configuration=new Configuration(Configuration.getVersion());
		//2.设置上面创建的模板所在的目录 
		configuration.setDirectoryForTemplateLoading(new File("D:/pinyougou_work/freemarkerDemo/src/main/resources/"));
		//3.设置字符集
		configuration.setDefaultEncoding("utf-8");
		//4.加载模板
		Template template = configuration.getTemplate("test.ftl");
		//5.创建数据模型(可以是pojo对象，也可以是map，map的key对应ftl文件中的属性名)
		Map map=new HashMap();
		map.put("name", "张三 ");
		map.put("message", "欢迎来到神奇的品优购世界！");
		//6.创建Writer输出流对象，可以指定
		Writer out =new FileWriter(new File("d:\\test.html"));
		//7.通过模板对象输出
		template.process(map, out);
		//8.关闭Writer对象
		out.close();

```

# 二、后端

## 1、消息中间件

### 1.1 概述

​	消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行[分布式系统](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者）。**中间件其实说到底就是一种服务型的软件，介于应用和底层数据之间的关系。消息中间件解决系统之间异步调用的关系。**

### 1.2 作用

#### 1)系统解耦

​	当一个主系统有多个子系统的时候，可以通过消息中间件来实现解耦合。![img](/Users/jack/Desktop/md/images/1208468-20190126142747039-343663977.png)

#### **2）异步调用**

​	假设你有一个系统调用链路，是系统A调用系统B，一般耗时20ms；系统B调用系统C，一般耗时200ms；系统C调用系统D，一般耗时2s，如下图所示。

![img](/Users/jack/Desktop/md/images/1208468-20190126142757375-1232720078.png)

​	因为系统D耗时比较久，所以可以将系统D抽离出来，实现异步调用，即先不用急着启动系统D，等到上面的完成之后再启动也可以，系统D回去消费前面几个系统发过来的数据。

![img](/Users/jack/Desktop/md/images/1208468-20190126142809076-677253897.png)

#### 3) 流量削峰

​	假如有个系统平时每秒请求只有几百个，然后在高峰期突然瞬时高峰达到每秒上千个甚至几千个，这时候原来的服务器配置可能就不大顶得住了。但是每天又只有半个小时的瞬间高峰期，如果增加服务器又有点浪费时间，这个时候也可以通过消息中间件解决。

​	用有限的机器资源承载高并发请求，如果业务场景允许异步削峰，高峰期积压一些请求在MQ里，然后高峰期过了，后台系统在一定时间内消费完毕不再积压的话，那就很适合用这种技术方案。

![img](/Users/jack/Desktop/md/images/1208468-20190126143304043-1472821196.png)

### 1.3 消息中间件分类与选择

1. ActiveMQ/ApolloMQ

优点：老牌的消息队列，**使用Java语言编写。对JMS支持最好，采用多线程并发，资源消耗比较大。**

缺点：由于历史悠久，历史包袱较多，版本更新很缓慢。集群模式需要依赖Zookeeper实现。最新架构的产品被命名为Apollo，号称下一代ActiveMQ，目前案例较少。

2. RocketMQ/Kafka

优点：**专为海量消息传递打造，主张使用拉模式，天然的集群、HA、负载均衡支持。**

缺点：所谓鱼和熊掌不可兼得，放弃了一些消息中间件的灵活性，使用的场景较窄，需关注你的业务模式是否契合，否则山寨变相使用很别扭。除此之外，RocketMQ没有.NET下的客户端可用。RocketMQ身出名门，但使用者不多，生态较小，毕竟消息量能达到这种体量的公司不多，你也可以直接去购买阿里云的消息服务。Kafka生态完善，其代码是用Scala语言写成，可靠性比RocketMQ低一些。

3. RabbitMQ

优点：生态丰富，使用者众，有很多人在前面踩坑。AMQP协议的领导实现，支持多种场景。淘宝的MySQL集群内部有使用它进行通讯，OpenStack开源云平台的通信组件，最先在金融行业得到运用。

缺点：虽然Erlang是天然集群化的，但RabbitMQ在高可用方面做起来还不是特别得心应手。

##  2、JMS

### 2.1 JMS简介

​	JMS（Java Messaging Service）是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。
​	 **JMS本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。**它类似于 JDBC(java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JML 客户机发送消息。==消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体==。**报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。**

​	JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。

- TextMessage--一个字符串对象
- MapMessage--一套名称-值对
- ObjectMessage--一个序列化的 Java 对象，实现了序列化接口
- BytesMessage--一个字节的数据流，声音、图片等等
- StreamMessage -- Java 原始值的数据流

### 2.1 JMS消息传递类型

对于消息的传递有两种类型：

#### 1.点对点的

即一个生产者和一个消费者一一对应，一个队列代表一个消息；![image-20190328095525250](/Users/jack/Desktop/md/images/image-20190328095525250.png)

​	==点对点的模式主要建立在一个队列上面，当连接一个列队的时候，发送端不需要知道接收端是否正在接收，可以直接向ActiveMQ发送消息==，**发送的消息，将会先进入队列中，如果有接收端在监听，则会发向接收端，如果没有接收端接收，则会保存在activemq服务器，直到接收端接收消息，点对点的消息模式可以有多个发送端，多个接收端，但是一条消息，只会被一个接收端给接收到，哪个接收端先连上ActiveMQ，则会先接收到，而后来的接收端则接收不到那条消息。**

##### 1.1 使用方法之消息生产者

1) 先引入依赖

```xml
 <dependency>
    <groupId>org.apache.activemq</groupId>
    <artifactId>activemq-client</artifactId>
    <version>5.13.4</version>
 </dependency>
```
2) 创建类QueueProducer ，main方法如下：

```Java
	//1.创建连接工厂, 61616是连接端口
	ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616");
	//2.获取连接,需要抛异常
	Connection connection = connectionFactory.createConnection();
	//3.启动连接
	connection.start();
	//4.获取session  (参数1：是否启动事务,参数2：消息确认模式)
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);		
	//5.创建队列对象(名称自己定义)
	Queue queue = session.createQueue("test-queue");
	//6.创建消息生产者
	MessageProducer producer = session.createProducer(queue);
	//7.创建消息
	TextMessage textMessage = session.createTextMessage("欢迎来到进入乐换");
	//8.发送消息
	producer.send(textMessage);
	//9.关闭资源
	producer.close();
	session.close();
	connection.close();
```

上述代码中第4步创建session  的两个参数：

第1个参数 是否使用事务

第2个参数 消息的确认模式

- AUTO_ACKNOWLEDGE = 1    自动确认
- CLIENT_ACKNOWLEDGE = 2    客户端手动确认   
- DUPS_OK_ACKNOWLEDGE = 3    自动批量确认
- SESSION_TRANSACTED = 0    事务提交并确认

通过ActiveMQ管理界面查询：![image-20190328100634208](/Users/jack/Desktop/md/images/image-20190328100634208.png)

列表各列信息含义如下：

[**Number Of Pending Messages**](http://192.168.25.135:8161/admin/queues.jsp)  **：**等待消费的消息 这个是当前未出队列的数量。

[**Number Of Consumers**](http://192.168.25.135:8161/admin/queues.jsp)  **：**消费者 这个是消费者端的消费者数量

[**Messages Enqueued**](http://192.168.25.135:8161/admin/queues.jsp)  **：**进入队列的消息  进入队列的总数量,包括出队列的。

[**Messages Dequeued**](http://192.168.25.135:8161/admin/queues.jsp)  **：**出了队列的消息  可以理解为是消费这消费掉的数量。

##### 1.2 使用方法之消息消费者

创建类QueueConsumer ，队列名称要跟生产者一样，main方法代码如下：

```Java
	//1.创建连接工厂
	ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616");
	//2.获取连接
	Connection connection = connectionFactory.createConnection();
	//3.启动连接
	connection.start();
	//4.获取session  (参数1：是否启动事务,参数2：消息确认模式)
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	//5.创建队列对象，注意队列名字要跟消息生产者一样
	Queue queue = session.createQueue("test-queue");
	//6.创建消息消费
	MessageConsumer consumer = session.createConsumer(queue);
	
	//7.监听消息,用匿名类的方式创建
	consumer.setMessageListener(new MessageListener() {
		public void onMessage(Message message) {
			TextMessage textMessage=(TextMessage)message;
			try {
				System.out.println("接收到消息："+textMessage.getText());
			} catch (JMSException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	});	
	//8.等待键盘输入
	System.in.read();	
	//9.关闭资源
	consumer.close();
	session.close();
	connection.close();	
```

运行结果：

​		控制台会输出：欢迎来到进入乐换。

​	同时开启2个以上的消费者(运行两次)，再次运行生产者，观察每个消费者控制台的输出，会发现只有一个消费者会接收到消息。

#### 2.发布/ 订阅模式

即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。

发消息的时候没有消费的话就不会被消费，就像广播一样，过了那个时间就收听不了了。

![image-20190328095533792](/Users/jack/Desktop/md/images/image-20190328095533792.png)

##### 2.1 使用方法之消息生产者

创建类TopicProducer ，main方法代码如下：

```Java
//1.创建连接工厂
	ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616");
	//2.获取连接
	Connection connection = connectionFactory.createConnection();
	//3.启动连接
	connection.start();
	//4.获取session  (参数1：是否启动事务,参数2：消息确认模式)
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	//5.创建主题对象
	Topic topic = session.createTopic("test-topic");
	//6.创建消息生产者
	MessageProducer producer = session.createProducer(topic);
	//7.创建消息
	TextMessage textMessage = session.createTextMessage("欢迎进入乐换");
	//8.发送消息
	producer.send(textMessage);
	//9.关闭资源
	producer.close();
	session.close();
	connection.close();
```

运行效果如下：

![image-20190328101805491](/Users/jack/Desktop/md/images/image-20190328101805491.png)

##### 2.2 使用方法之消息消费者

创建类TopicConsumer ,main方法代码如下：

```Java
	//1.创建连接工厂
	ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616");
	//2.获取连接
	Connection connection = connectionFactory.createConnection();
	//3.启动连接
	connection.start();
	//4.获取session  (参数1：是否启动事务,参数2：消息确认模式)
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	//5.创建主题对象
	//Queue queue = session.createQueue("test-queue");
	Topic topic = session.createTopic("test-topic");
	//6.创建消息消费
	MessageConsumer consumer = session.createConsumer(topic);
	
	//7.监听消息
	consumer.setMessageListener(new MessageListener() {
		public void onMessage(Message message) {
			TextMessage textMessage=(TextMessage)message;
			try {
				System.out.println("接收到消息："+textMessage.getText());
			} catch (JMSException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	});
	//8.等待键盘输入
	System.in.read();
	//9.关闭资源
	consumer.close();
	session.close();
	connection.close();	
```

##### 2.3 运行测试

​	先进行消费者，再启动生产者。同时开启2个以上的消费者，再次运行生产者，观察每个消费者控制台的输出，会发现每个消费者会接收到消息。

## 3、短信平台发送短息

1.选好短信平台，按照其开发文档进行配置

2.发短信的方法

```Java
public void createSmsCode(final String phone) {
        //1.生成一个6位随机数（验证码）,后面加空字符串转换成字符串
        final String smsCode = (long) (Math.random() * 1000000) + "";
        System.out.println("验证码：" + smsCode);

        //2.将验证码放入redis，key是手机号码，value是验证码
        redisTemplate.boundHashOps("smsCode").put(phone, smsCode);
        //3.将短信内容发送给activeMQ
        jmsTemplate.send(smsDestination, new MessageCreator() {
            @Override
            public Message createMessage(Session session) throws JMSException {
                MapMessage message = session.createMapMessage();
                message.setString("mobile", phone);//手机号
                message.setString("templateId", templateId);//模板id
                message.setString("uid", uid);//非必填
                //Map map = new HashMap();
                message.setString("param", smsCode + ",1");
                //message.setString("param", JSON.toJSONString(map));
                return message;
            }
        });
    }
```

根据短信平台的不同，可能实现发送方法会有所不同。













