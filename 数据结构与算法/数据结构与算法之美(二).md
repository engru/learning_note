# 十四、二叉树

## 树

- 根节点：没有父节点的节点
- 叶节点：没有子节点的节点
- 节点的高度：节点到叶子节点的最长路径，从 0 开始
- 节点的深度：根节点到这个节点所经历的边的个数，从 0 开始
- 节点的层数：节点的深度 + 1
- 树的高度：根节点的高度

![image-20190511230746164](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20190511230746164.png)

## 二叉树

存储一棵二叉树，有两种办法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。

- 满二叉树：除了叶子节点之外，其他节点都有左右两个孩子节点。
- 完全二叉树：叶子节点都在最下面两层，最后一层的叶子节点都靠左排列，除了最后一层的节点，其他层的节点都要排满。

完全二叉树天然适合用数组存储，若是有哨兵位置，如果每个节点 X 存储在数据下标为 i 的位置上，则每个节点若是有左儿子，则左儿子在 2 * i 位置上，若是有右儿子，右儿子必在 2 * i + 1 的位置上。

![image-20190511231438405](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20190511231438405.png)

从整个数组来看，空间被充分利用起来（除了哨兵位置，但是哨兵位置带来的优化也是很不错的），利用了数组的优点，访问父子节点的速度快很多，还天然支持按层遍历。

### 二叉树的遍历

- 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
- 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
- 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

![image-20190511231755939](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20190511231755939.png)

**二叉树遍历的时间复杂度是O(n)。**

## 课后思考

什么样的二叉树适合用数组存储

最完美的情况当然是完全二叉树。但是我思考了下，如果我们的业务场景中，构造的树缺少了极个别的节点，不能构成完全二叉树，但是非常接近完全二叉树，我认为还是可以用数组存储的。毕竟我们做工程，不是要追求学术上的某一指标绝对最优，整体最优才是我们更应该考虑的。

给定一组数据，比如 1，3，4，5，9，10。可以构建出多少种不同的二叉树？

根据卡特兰数C[n,2n] / (n+1)计算，C(6) = c[12,6]/7 = 132 种

## 二叉查找树

**二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。** 

​	二叉查找树又叫二叉搜索树。特点是，在树中任意一个节点，其左子树的每个节点的值，都要小于这个节点的值，而右节点的值都大于这个节点的值。

### 查找

​	从根节点递归，注意判断 null，对当前节点进行比较，等于则返回，小于则往左递归，否则往右递归。

```java
public class BinarySearchTree { 
    private Node tree;
    public Node find(int data) { 
        Node p = tree;
        while (p != null) {
            if (data < p.data) p = p.left;
            else if (data > p.data) p = p.right; 
        	else return p;
        }
        return null;
    }
 // 内部类
    public static class Node { 
        private int data;
        private Node left; 
        private Node right;
        public Node(int data) { 
        	this.data = data;
        }
    }
}
```

### 插入

​	思路类似查找操作，遇到 null 则应该直接插入。如果有相同的节点，考虑使用链表法解决，或者选定一个方向插入，比如插入左子树最右边，或则插入右子树最左边。这时树左右子树同当前节点的关系就变成了不大于、不小于的关系了，而原来的关系是小于、大于关系。这种情况下，查找操作和删除操作也应该做相应改变。

```Java
public void insert(int data) {
    if (tree == null) {
      tree = new Node(data);
      return;
    }

    Node p = tree;
    while (p != null) {
      if (data > p.data) {
        if (p.right == null) {	// 右子树为空，重新创建一个节点后直接插入
          p.right = new Node(data);
          return;
        }
        p = p.right;
      } else { // data < p.data，左子树
        if (p.left == null) {
          p.left = new Node(data);// 同理，直接新建
          return;
        }
        p = p.left;
      }
    }
  }
```

### 删除

![image-20190512191138213](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20190512191138213.png)

最简单的删除操作应该是这样：

- 没有孩子节点，直接结束。
- 只有一个孩子节点(只有左子节点或者右子节点)，孩子节点替换到当前位置。(无论左结点还是右结点，都小于父节点，所以直接替换)
- 有两个孩子节点的时候，如果左子树是叶子节点，则不用动，将右子树的左孩子节点移到被删除节点的位子；如果左子树非叶子结点，将删除节点的左节点移到被删除节点的位置，将左孩子的右子树插入右孩子的最左边，然后把右子树替换在左子树的右儿子位置。

```Java
public void delete(int data) {
  Node p = tree; // p指向要删除的节点，初始化指向根节点
  Node pp = null; // pp记录的是p的父节点
  while (p != null && p.data != data) {
    pp = p;
    if (data > p.data) p = p.right;
    else p = p.left;
  }
  if (p == null) return; // 没有找到

  // 要删除的节点有两个子节点
  if (p.left != null && p.right != null) { // 查找右子树中最小节点
    Node minP = p.right;
    Node minPP = p; // minPP表示minP的父节点
    while (minP.left != null) {
      minPP = minP;
      minP = minP.left;
    }
    p.data = minP.data; // 将minP的数据替换到p中
    p = minP; // 下面就变成了删除minP了
    pp = minPP;
  }

  // 删除节点是叶子节点或者仅有一个子节点
  Node child; // p的子节点
  if (p.left != null) child = p.left;
  else if (p.right != null) child = p.right;
  else child = null;

  if (pp == null) tree = child; // 删除的是根节点
  else if (pp.left == p) pp.left = child;
  else pp.right = child;
}
```

### 重复数据的二叉查找树

有两种方法可以存储数据重复的二叉查找树

- 第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。

- 第二种方法比较不好理解，不过更加优雅。
  每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，**把这个新插入的数据当作大于这个节点的值来处理。**

  当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。

  对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。

最好情况下，树的高度小于等于 log2n，其中 n 是节点个数。此时查找、插入、删除操作的时间复杂度是 O(log2n)。最坏情况下，时间复杂度是 O(n)，此时树退化成链表。

### 有了高效的散列表，为什么还需要二叉查找树呢

总的来说，有以下一些原因：

- 散列表中的数据是无序存储的，若要输出有序数据，需要进行排序。而二叉搜索树可以用中序遍历在 O(n) 时间内完成。
- 散列表扩容耗时很多，遇到散列冲突，性能不稳定。虽然二叉搜索树性能不稳定，但是它的优化版，平衡树的性能一直很稳定。
- 尽管散列表查找的性能是 O(1) 级的，但是因为散列冲突的存在，和哈希函数的耗时，性能不一定比 O(logn) 级快，毕竟 logn 是一个很小的数字。
- 散列表的构造要考虑的点很多，比如散列函数的设计、冲突解决的方法、初始容量和负载因子、扩容、缩容等。而平衡树就不需要考虑那么多了，唯一的问题平衡性已经有成熟的方案了。

### 求给定一颗二叉树的确切高度

1.深度优先思想的递归法

​	这种方法最简单好理解。 树高 = 根节点高度 = max(leftHeight, rightHeight) + 1，当前节点的高度就是左右子树中较大的那个+1。

2.队列法

​	类似层次遍历，维持一个队列，同时设变量记录下当前层数，当前层剩余未遍历个数，下一层个数。遍历完这个队列即可得到树的高度，也避免了过大的内存开销和过深的递归可能出现的问题。

​	每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。

# 十五、红黑树

## 平衡二叉查找树

​	平衡二叉树的严格定义：二叉树中任意一个节点的左右子树高度相差不能大于 1。而平衡二叉查找树，就是在平衡二叉树的基础上，满足二叉查找树的特定的树。

​	但是很多平衡二叉查找树并没有严格符合上面平衡的定义。比如红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径长一倍。

所以，**平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。**

## 红黑树的定义

红黑树是一种不严格的平衡二叉查找树。它要满足一下五个要求：

- 红黑树中的节点，一类被标记为黑色，一类被标记为红色。
- ==根节点是黑色的。==
- **每个叶子节点都是黑色的空节点，也就是说，叶子节点不存储数据。**
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。
- **每个节点，从该节点到其可达的叶子节点的所有路径，都包含相同数目的黑色节点。**

## 红黑树是“近似平衡”的

​	追根溯源，我们使用平衡二叉查找树的原因，就是为了解决二叉查找树动态更新导致的性能退化问题。所以，**“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。**

​	一颗极其平衡的的二叉树的高度大约是 log2n。故，只要证明红黑树的高度是近似 log2n，即可说明红黑树是“近似平衡”的。

土方法推导过程如下：

首先，将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度比 log2n 还低：

去除红色节点后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点作为父节点，所以，之前的二叉树就变成四叉树。

![image-20190512230312378](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20190512230312378.png)

​	从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。

​	从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。

==完全二叉树的高度近似 log2n，所以，红黑树的高度不会超过 2log2n，同样是 log2n 的数量级。==

> 使用平衡查找树是为了获得性能较好的插入、查找、删除操作。不使用 AVL 树是因为它太高度平衡，每次调整的代价太大，相比之下红黑树就是一种比较折中的选择。















































参照：https://www.jianshu.com/p/f1eaf1e8e073

《数据结构与算法之美》、<https://www.jianshu.com/nb/29712522>