# 计算机与网络

# 一、网络体系结构

![åçä½ç³"ç"æ VS OS VS TCP/IP](/Users/jack/Desktop/md/images/d6f64b4331cc61156c5a098c18ce05a9.png)

推荐的连接：

- [《计算机网络体系结构综述（上）》](https://blog.csdn.net/justloveyou_/article/details/69611328)
- [《计算机网络体系结构综述（下）》](https://blog.csdn.net/justloveyou_/article/details/69612153)

各层使用的数据交换设备：

- 网关：应用层、传输层。

  > 网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。
  >
  > 网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。

- 【重点】路由器：网络层

  > 路由选择、存储转发

- 【重点】交换机：数据链路层、网络层

  > 识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中。

- 网桥：数据链路层

  > 将两个 LAN 连起来，根据 MAC 地址来转发帧。

- 集线器（Hub）：物理层

  > 纯硬件设备，主要用来连接计算机等网络终端。

- 中继器：物理层

  > 在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离。

# 二、IP

## IP 地址的分类

IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

IP 地址编址方案将IP地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。

**每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID 。**同一个物理网络上的所有主机都使用同一个网络 ID ，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：

![五类互联网地址](/Users/jack/Desktop/md/images/0e2ff871cdb6c2b58a6a2fc3bec51933.jpeg)

- A 类地址：以 0 开头，第一个字节范围：0~127 。
- B 类地址：以 10 开头，第一个字节范围：128~191 。
- C 类地址：以 110 开头，第一个字节范围：192~223。
- D 类地址：以 1110 开头，第一个字节范围：224~239 。
- E 类地址：以 1111 开头，保留地址。

详细的，可以看看 [《IP 地址分类（A类 B类 C类 D类 E类）》](https://blog.csdn.net/kzadmxz/article/details/73658168) 文章。

## **IP 地址与物理地址的区别**

- 物理地址(MAC 地址)，是数据链路层和物理层使用的地址。
- IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。
- 其中 ARP 协议用于 IP 地址与物理地址的对应。

详细的，可以看看 [《即生瑜，何生亮 —— MAC 地址与 IP 地址》](http://blog.sciencenet.cn/blog-411071-1037673.html) 文章。

## 网络层的 ARP 协议工作原理

网络层的 ARP 协议完成了 IP 地址与物理地址的映射。

- 首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。
- 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：
  - 如果有，就直接将数据包发送到这个 MAC 地址。
  - 如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 I P地址一致。
    - 如果不相同，就忽略此数据包。
    - 如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中(如果 ARP 表中已经存在该 IP 的信息，则将其覆盖)，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。
      - 源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。
      - 如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。

> 注意，在 OSI 模型中 ARP 协议属于链路层；而在 TCP/IP 模型中，ARP 协议属于网络层。

# 三、TCP

TCP(Transmission Control Protocol)，传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。主要特点如下：

- TCP 是面向连接的。

  > 就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接

- 每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）。

- TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。

- TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据。

- 面向字节流。

  > TCP 中的“流”（Stream），指的是流入进程或从进程流出的字节序列。
  >
  > “面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

## TCP 对应的应用层协议？

- FTP ：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。
- Telnet ：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。
- 邮箱
  - SMTP ：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。
  - POP3 ：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Foxmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是 163 邮箱就没有必要先进入网易网站，再进入自己的邮箱来收信）。
- HTTP ：从 Web 服务器传输超文本到本地浏览器的传送协议。

## TCP 头部

- [《通俗大白话来理解 TCP 协议的三次握手和四次分手》](https://github.com/jawil/blog/issues/14) 的 [「TCP头部」](http://svip.iocoder.cn/Net/Interview/#) 小节。
- [《TCP 协议的学习 （二）TCP 头部信息》](https://blog.csdn.net/qq_34501940/article/details/51073691)

## 【重要】TCP 三次握手？

三次握手，简单来说，就是：

[TCP 三次握手的漫画](https://camo.githubusercontent.com/91cee189ca7c400e3be6aa35cdda000ecbb58930/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f3630363537332d32303137303331373139313333363933322d313635343735313132332e706e67)

- 发送方：我要和你建立链接？
- 接收方：你真的要和我建立链接么？
- 发送方：我真的要和你建立链接，成功。

详细来说，步骤如下：

![TCP 三次握手的干货](/Users/jack/Desktop/md/images/04edb57536fc9bbd3ea096cafa5d3630.png)

- 第一次握手：Client 将标志位 `SYN=1` ，随机产生一个值 `seq=J` ，并将该数据包发送给 Server 。此时，Client 进入SYN_SENT 状态，等待 Server 确认。
- 第二次握手：Server 收到数据包后由标志位 `SYN=1` 知道Client请求建立连接，Server 将标志位 `SYN` 和 `ACK` 都置为 1 ，`ack=J+1`，随机产生一个值 `seq=K` ，并将该数据包发送给 Client 以确认连接请求，Server 进入 `SYN_RCVD` 状态。此时，Server 进入 SYC_RCVD 状态。
- 第三次握手：Client 收到确认后，检查ack是否为J+1，ACK是否为 1 。
  - 如果正确，则将标志位 `ACK` 置为 1 ，`ack=K+1` ，并将该数据包发送给 Server 。此时，Client 进入 ESTABLISHED 状态。
  - Server 检查 `ack` 是否为 `K+1` ，`ACK` 是否为 1 ，如果正确则连接建立成功。此时 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。
- 仔细看来，Client 会发起两次数据包，分别是 `SYNC` 和 `ACK` ；Server 会发起一次数据包，包含 `SYNC` 和 `ACK` 。也就是说，三次握手的过程中，Client 和 Server 互相做了一次 `SYNC` 和 `ACK` 。

## 三次握手的原因

​	第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

​	客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

###  **为什么 TCP 连接需要三次握手**

为了防止**已失效的连接请求**报文突然又传送到了服务端，因而产生错误。

> 客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达 Server 。
>
> - 若不采用“三次握手”，那么只要 Server 发出确认数据包，新的连接就建立了。由于 Client 此时并未发出建立连接的请求，所以其不会理睬 Server 的确认，也不与 Server 通信；而这时 Server 一直在等待 Client 的请求，这样 Server 就白白浪费了一定的资源。
> - 若采用“三次握手”，在这种情况下，由于 Server 端没有收到来自客户端的确认，则就会知道 Client 并没有要求建立请求，就不会建立连接。

在 [《通俗大白话来理解 TCP 协议的三次握手和四次挥手》](https://github.com/jawil/blog/issues/14) 中，搜 [“为什么要三次握手”](http://svip.iocoder.cn/Net/Interview/#) 关键字，也有非常好的解答。

- **这就很明白了，防止了服务器端的一直等待而浪费资源**。

## 【重要】什么是 TCP 四次挥手

四次挥手，简单来说，就是：

- 发送方：我要和你断开连接！
- 接收方：好的，断吧。
- 接收方：我也要和你断开连接！
- 发送方：好的，断吧。

详细来说，步骤如下：

![TCP 四次挥手的干货](/Users/jack/Desktop/md/images/2cf7b8d1689ae6e920ef1b2c3eafb8b2.png)

> 如下使用 Client 和 Server 的方式，仅仅是为了方便，也是可以从 Server 向 Client 发起。

- 第一次挥手：Client 发送一个 `FIN=M` ，用来关闭 Client 到 Server 的数据传送。此时，Client 进入 FIN_WAIT_1 状态。
- 第二次挥手，Server 收到 `FIN` 后，发送一个 `ACK` 给 Client ，确认序号为 `M+1`（与 `SYN` 相同，一个 `FIN` 占用一个序号）。此时，Server 进入 CLOSE_WAIT 状态。==注意，TCP 链接处于**半关闭**状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。==
- 第三次挥手，Server 发送一个 `FIN=N` ，用来关闭 Server 到 Client 的数据传送。此时 Server 进入 LAST_ACK 状态。
- 第四次挥手，Client 收到 `FIN` 后，此时 Client 进入 TIME_WAIT 状态。接着，Client 发送一个 `ACK` 给 Server ，确认序号为 `N+1` 。Server 接收到后，此时 Server 进入 CLOSED 状态，完成四次挥手。

### **为什么要四次挥手？**

TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。**TCP 是全双工模式**，这就意味着：

- 当主机 1 发出 `FIN` 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2 ，它的数据已经全部发送完毕了；**但是，这个时候主机 1 还是可以接受来自主机 2 的数据；**==当主机 2 返回 `ACK` 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的。==

  > 艿艿：因为主机 2 此时可能还有数据想要发送给主机 1 ，所以挥手不能像握手只有三次，而是多了那么“一次”！

- 当主机 2 也发送了 `FIN` 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1 ，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。

  > 艿艿：我们把四次挥手，理解成一次和平的挥手~

如果要正确的理解四次的原理，就需要了解四次挥手过程中的状态变化。

> 主动方=发送方；被动方=接收方。
>
> 状态前面的（主动方）（被动方），表示该状态属于谁。

- （主动方）FIN_WAIT_1 ：**其实 FIN_WAIT_1 和 FIN_WAIT_2 状态的真正含义都是表示等待对方的FIN报文。**而这两种状态的区别是：

  - FIN_WAIT_1 状态实际上是当 Socket 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 `FIN` 报文，此时该 Socket 即进入到 FIN_WAIT_1 状态。
  - 而**当对方回应 `ACK` 报文后，则进入到 FIN_WAIT_2 状态**，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应`ACK` 报文。所以， FIN_WAIT_1 状态一般是比较难见到的，而 FIN_WAIT_2 状态还有时常常可以用 netstat 看到。

- （主动方）FIN_WAIT_2 ：上面已经详细解释了这种状态，实际上 FIN_WAIT_2 状态下的 Socket，表示半连接，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你(`ACK` 信息)，稍后再关闭连接。

- （被动方）CLOSE_WAIT ：这种状态的含义其实是表示在等待关闭。即当对方 close 一个 Socket 后发送 `FIN` 报文给自己，你系统毫无疑问地会回应一个 `ACK` 报文给对方，此时则进入到 CLOSE_WAIT 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 Socket ，发送 `FIN` 报文给对方，也即关闭连接。所以你在 CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。

- （被动方）LAST_ACK ：这个状态还是比较容易好理解的，它是被动关闭一方在发送 `FIN` 报文后，最后等待对方的 `ACK` 报文。当收到 `ACK` 报文后，也即可以进入到 CLOSED 可用状态了。

- （主动方）TIME_WAIT ：表示收到了对方的 `FIN` 报文，并发送出了 `ACK` 报文，就等 [2MSL](https://blog.csdn.net/xiaofei0859/article/details/6044694) 后即可回到 CLOSED 可用状态了。如果 FIN_WAIT_1 状态下，收到了对方同时带 `FIN` 标志和 `ACK` 标志的报文时，可以直接进入到 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。

  > **为何一定要等 2MSL ？**
  >
  > 如果不等，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的 TCP 报文可能与新 TCP 连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的 TCP 连接的活跃报文全部死翘翘，2MSL 时间可以满足这个需求（尽管非常保守）！
  >
  > 更多，可以看看知乎 [《为什么 TCP 4 次挥手时等待为 2MSL？》](https://www.zhihu.com/question/67013338) 的讨论。

- CLOSED ：表示连接中断。

另外，关于 TIME_WAIT 和 CLOSE_WAIT 状态的区别[《TIME_WAIT 和 CLOSE_WAIT 状态区别》](https://blog.csdn.net/kobejayandy/article/details/17655739) 。

## 【重要】TCP 数据如何传输？

建立连接后，两台主机就可以相互传输数据了。如下图所示：![TCP 套接字的数据交换过程](/Users/jack/Desktop/md/images/6ed78395a32a0fbf56afed309dc1eb71.jpeg)

- 上图给出了主机 A 分 2 次（分 2 个数据包）向主机 B 传递 200 字节的过程。
- 首先，主机 A 通过 1 个数据包发送 100 个字节的数据，数据包的Seq号设置为 1200 。主机 B 为了确认这一点，向主机 A 发送ACK包，并将Ack号设置为 1301 。
  - 为了保证数据准确到达，目标机器在收到数据包（包括 `SYN` 包、`FIN` 包、普通数据包等）包后必须立即回传 `ACK` 包，这样发送方才能确认数据传输成功。
  - 此时Ack号为 1301 而不是 1201，原因在于Ack号的增量为传输的数据字节数。假设每次Ack号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确 100 字节全部正确传递还是丢失了一部分，比如只传递了 80 字节。因此按如下的公式确认Ack号：Ack =Seq号 + 传递的字节数 + 1 。
    - 与三次握手协议相同，最后加 1 是为了告诉对方要传递的 `Seq` 号。

OK，让我们重新来看下 TCP 的整个过程。如下图所示：[TCP 过程](https://camo.githubusercontent.com/36cf7d4e1598683fe72a5e1c3e837b16840f4085/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f6a656c6c797468696e6b544350342e6a7067)

### **TCP 数据传输丢失怎么办？**

> 艿艿：这个问题，也可以改成提问，什么是 TCP 重传。

因为各种原因，TCP 数据包可能存在丢失的情况，TCP 会进行数据重传。如下图所示：

![TCP套接字数据传输过程中发生错误](/Users/jack/Desktop/md/images/a36ed3dad53b9b4439bc8156bc63a2c0.jpeg)

- 上图表示通过 `Seq` 1301 数据包向主机 B 传递 100 字节的数据，但中间发生了错误，主机 B 未收到。经过一段时间后，主机 A 仍未收到对于 `Seq` 1301 的 `ACK` 确认，因此尝试重传数据。==为了完成数据包的重传，TCP 套接字每次发送数据包时都会**启动定时器**，如果在一定时间内没有收到目标机器传回的 `ACK` 包，那么定时器超时，数据包会重传。==上图演示的是数据包丢失的情况，也会有 `ACK` 包丢失的情况，一样会重传。

- 重传超时时间(RTO，Retransmission Time Out)

  > 这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。
  >
  > 往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 `ACK` 确认包（接收端收到数据后便立即确认），总共经历的时延。

- 重传次数

  > TCP 数据包重传次数，根据系统设置的不同而有所区别。**有些系统，一个数据包只会被重传 3 次，如果重传 3 次后还未收到该数据包的 `ACK` 确认，就不再尝试重传。**但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。
  >
  > 最后需要说明的是，==发送端只有在收到对方的 `ACK` 确认包后，才会清空输出缓冲区中的数据==。

**ps：TCP 数据传输的过程，和 MQ Broker 投递消息给 Consumer 是一样的，只有在 Consumer Ack 确认消息已经消费，该消息才不会再被投递给 Consumer 。**

另外，也推荐阅读 [《网络基本功（九）：细说TCP重传》](https://wizardforcel.gitbooks.io/network-basic/content/8.html) 。

## 【重要】什么是 TCP 滑动窗口？

在看 TCP 滑动窗口的概念之前，我们先来看看它出现的**背景**？

> 将 TCP 与 UDP 这样的简单传输协议区分开来的是，它传输数据的质量。TCP 对于发送数据进行跟踪，这种数据管理需要协议有以下两大关键功能：
>
> - 可靠性：保证数据确实到达目的地。如果未到达，能够发现并重传。
> - 数据流控：管理数据的发送速率，以使接收设备不致于过载。
>
> 要完成这些任务，整个协议操作是围绕**滑动窗口** + **确认机制**来进行的。因此，理解了滑动窗口，也就是理解了 TCP 。

那么，到底什么是 TCP 滑动窗口呢？

> 滑动窗口协议，是传输层进行流控的一种措施**，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。**
>
> TCP 的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。

参照下面：

- [《TCP 滑动窗口控制流量的原理》](https://www.cnblogs.com/luoquan/p/4886345.html)
- [《网络基本功（八）：细说 TCP 滑动窗口》](https://wizardforcel.gitbooks.io/network-basic/content/7.html)
- [《TCP 协议的滑动窗口具体是怎样控制流量的？》](https://www.zhihu.com/question/32255109)

## 什么是 TCP 拥堵？

计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做**拥塞**。

🦅 **怎么解决 TCP 拥堵？**

通过拥塞控制来解决。拥堵控制，就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个**全局性**的过程，而后者指**点对点**通信量的控制。

拥塞控制的方法主要有以下四种：

- 1、慢开始。
- 2、拥塞避免。
- 3、快重传。
- 4、快恢复。

**1）慢开始**

不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

**2）拥塞避免**

拥塞避免算法，让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1 ，而不是加倍，这样拥塞窗口按线性规律缓慢增长。

![慢开始和拥塞避免算法的实现举例](/Users/jack/Desktop/md/images/3ed1936c7ee8639606bc8b3dccc2d5bc.png)

**3）快重传**

快重传，要求接收方在收到一个**失序的报文段**后就立即发出**重复确认**（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。

快重传算法规定，发送方只要一连收到三个重复确认，就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

![快重传的示意图](/Users/jack/Desktop/md/images/96da7b757bb0dc2f2eaf86ac8ad20858.jpeg)

**4）快恢复**

快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。

- 但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。
- 所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。

![从连续收到三个重复的确认转入拥堵避免](/Users/jack/Desktop/md/images/d5ac995144720c33399d8e518cb973a6.jpeg)