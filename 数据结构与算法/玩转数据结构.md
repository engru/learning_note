# 玩转数据结构

# 一、数组

​	数组优点：快速查询；数组最好用于“索引有语义”的情况；但并非所有有语义的索引都适用于数组；例： 身份证号就不适合，占用空间太大；数组也可以处理 “索引没有语义 ”的情况。

## 1 整型数组

​	**Java 自身的数组是静态数组，不具有对内存空间增、删、改、查功能；故二次分装自己的内存，为动态数组。**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123203028943.png)

自己的数组类： Array

data:数组名称

size:数组中实际装入元素的长度

capacity:数组定义的长度（容量）

代码如下：

```java
public class OurOwnArray {
    private int[] data;     //定义int 型数组 data
    private int size;       //data数组中有效元素的数量

    /**
     * @param capacity 数组的容量
     */
    // 构造函数，传入数组的容量capacity构造Array，数组容量与size无关
    //数组容量没有必要单独定义一个变量，只要声明函数的时候传入即可
    public OurOwnArray(int capacity) {
        data = new int[capacity];
        size = 0;
    }

    // 无参数的构造函数，默认数组的容量capacity=10
    public OurOwnArray() {
        this(10);
    }

    // 获取数组的容量
    public int getCapacity() {
        return data.length;
    }

    // 获取数组中的元素个数
    public int getSize() {
        return size;
    }

    // 返回数组是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    // 向所有元素后添加一个新元素
    public void addLast(int e) {
        //data[size++]=e    相当于下面两句
//        data[size] = e;
//        size++;
        add(size, e);
    }

    // 在所有元素前添加一个新元素
    public void addFirst(int e) {
        add(0, e);
    }

    // 在index索引的位置插入一个新元素e
    public void add(int index, int e) {
        if (size == data.length) {
            throw new IllegalArgumentException("out of capacity");
        }
        //索引不合格,这里index可以等于size，刚开始都是0
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("index illegal");
        }
        for (int i = size - 1; i >= index; i--) {
            data[i + 1] = data[i];  //从插入的位置开始，数组后移，后面的值覆盖前面的值
        }
        data[index] = e;       //覆盖原来的值
        size++;
    }

    // 获取index索引位置的元素
    public int get(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        return data[index];
    }

    // 修改index索引位置的元素为e
    public void set(int index, int e) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        data[index] = e;
    }

    // 查找数组中是否有元素e
    public boolean contains(int e) {
        for (int i = 0; i < size; i++) {
            if (data[i] == e) {
                return true;
            }
        }
        return false;
    }

    // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1,只能查找到一个元素e
    public int find(int e) {
        for (int i = 0; i < size; i++) {
            if (data[i] == e) {
                return i;
            }
        }
        return -1;
    }

    // 从数组中删除index位置的元素, 返回删除的元素,与插入相反
    public int delete(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        int temp = data[index];     //返回删除的元素
        for (int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];      //从删除的索引开始，插入的索引后面，数组左移
        }
        size--;
        return temp;
    }

    public int delFirst() {
        return delete(0);
    }

    public int delLast() {
        return delete(size - 1);
    }

    // 从数组中删除元素e,只删除一个元素e
    public void delElement(int e) {
        int index = find(e);
        if (index != -1) {  //数组中有这个元素
            delete(index);
        }
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format("Array：size=%d,capacity=%d\n", size, data.length));
        res.append('[');
        for (int i = 0; i < size; i++) {
            res.append(data[i]);
            if (i != size - 1) {
                res.append(", ");
            }
        }
        res.append(']');
        return res.toString();
    }
}
```

## 2 泛型数组

​	泛型：使数据结构可以放置所有的“数据类型”；**但只能放置类对象，不能是基本数据类型**（boolean、byte、char、short、int、long、float、double），为了解决这个问题，Java 中每个基本数据类型都有对应的包装类（将本来不是类对象的变成了类对象）；

​	**基本数据类型对应的包装类[Boolean、Byte、Char、Short、Int、Long、Float、Double ]  二者之间可以互相转换。**

```java
//泛型数组，E为类对象，所有判断元素相等的时候要用equal方法
public class TOurOwnArray<E>{
    private E[] data;
    ...
    // 构造函数，传入数组的容量capacity构造Array，数组容量与size无关
    //数组容量没有必要单独定义一个变量，只要声明函数的时候传入即可
    public TOurOwnArray(int capacity) {
        //java 中不支持直接new出泛型数组
        // 需要通过object创建一个数组，然后再转换为E[]
        data = (E[]) new Object[capacity];
        size = 0;
    }
    ...
    //将上面的数组int改为E类型就可以了
    // 从数组中删除index位置的元素, 返回删除的元素,与插入相反
    public E delete(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        E temp = data[index];     //返回删除的元素
        for (int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];      //从删除的索引开始，插入的索引后面，数组左移
        }
        size--;
        data[size] = null; // loitering objects != memory leak 使数组最后引用中的值被垃圾回收
        return temp;
    }
    ...
}
```

## 3动态数组

​	动态数组是为了解决数组空间不够用的情况，**Java 中的静态数组，当插入的值数量 > 数组的size 时就会报错，使用动态数组可以解决这个问题，**

​	**设置动态数组的思路**：再建立一个新的数组newData，它要比之前的数组空间大一些；将data 中的数据放入到 newData 中，**循环遍历数组data中所有的元素，将他们依次赋值到 newData 中；**	

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230804821.png)

**==想让 newData 取代原来的 data ,对数组而言，容量（capacity）已经变为 8 ；size 在newData中还是 4 ，但数组可以装入更多的元素；==**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230853839.png)

​	将数组data的**引用改为指向 新的有8个空间的数组**，与newData的引用相同,指向同样的空间；整个过程封装在函数中，当函数执行完成后，newData 就会失效了；而 data 是整个类的成员变量，和整个类的成员变量是相同的，只要类在使用则data就是有效的；![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230904146.png)

**==之前的4个空间的数组，因为已经没有引用了，垃圾回收器会将其销毁；数组完成扩容==**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230911188.png)

```java
public class DynamicTOurOwnArray<E> {
    private E[] data;     //定义int 型数组 data
    private int size;       //data数组中有效元素的数量

    /**
     * @param capacity 数组的容量
     */
    // 构造函数，传入数组的容量capacity构造Array，数组容量与size无关
    //数组容量没有必要单独定义一个变量，只要声明函数的时候传入即可
    public DynamicTOurOwnArray(int capacity) {
        //java 中不支持直接new出泛型数组
        // 需要通过object创建一个数组，然后再转换为E[]
        data = (E[]) new Object[capacity];
        size = 0;
    }

    // 无参数的构造函数，默认数组的容量capacity=10
    public DynamicTOurOwnArray() {
        this(10);
    }

    // 获取数组的容量
    public int getCapacity() {
        return data.length;
    }

    // 获取数组中的元素个数
    public int getSize() {
        return size;
    }

    // 返回数组是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    // 向所有元素后添加一个新元素
    public void addLast(E e) {
        //data[size++]=e    相当于下面两句
//        data[size] = e;
//        size++;
        add(size, e);
    }

    // 在所有元素前添加一个新元素
    public void addFirst(E e) {
        add(0, e);
    }

    // 在index索引的位置插入一个新元素e
    public void add(int index, E e) {
        //索引不合格,这里index可以等于size，刚开始都是0
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("index illegal");
        }
        if (size == data.length) {
            resize(2 * data.length);    //进行数组扩容，变为原来的2倍
        }
        for (int i = size - 1; i >= index; i--) {
            data[i + 1] = data[i];  //从插入的位置开始，数组后移，后面的值覆盖前面的值
        }
        data[index] = e;       //覆盖原来的值
        size++;
    }

    // 将数组空间的容量变成newCapacity大小（2倍）
    private void resize(int newCapacity) {
        E[] newData = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {       //new 一个新的E型数组newData
            newData[i] = data[i];     //将原来的数组内容放入到新的newData中
        }
        data = newData;       //让 data 指向 newData 的空间
    }

    // 获取index索引位置的元素
    public E get(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        return data[index];
    }

    // 修改index索引位置的元素为e
    public void set(int index, E e) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        data[index] = e;
    }

    // 查找数组中是否有元素e
    public boolean contains(E e) {
        for (int i = 0; i < size; i++) {
            if (data[i].equals(e)) {
                return true;
            }
        }
        return false;
    }

    // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1,只能查找到一个元素e
    public int find(E e) {
        for (int i = 0; i < size; i++) {
            if (data[i].equals(e)) {
                return i;
            }
        }
        return -1;
    }

    // 从数组中删除index位置的元素, 返回删除的元素,与插入相反
    public E delete(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        E temp = data[index];     //返回删除的元素
        for (int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];      //从删除的索引开始，插入的索引后面，数组左移
        }
        size--;
        data[size] = null; // loitering objects != memory leak 使数组最后引用中的值被垃圾回收
        //缩小一半
        if (size == data.length / 2) {
            resize(data.length / 2);
        }
        return temp;
    }

    public E delFirst() {
        return delete(0);
    }

    public E delLast() {
        return delete(size - 1);
    }

    // 从数组中删除元素e,只删除一个元素e
    public void delElement(E e) {
        int index = find(e);
        if (index != -1) {  //数组中有这个元素
            delete(index);
        }
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format("Array：size=%d,capacity=%d\n", size, data.length));
        res.append('[');
        for (int i = 0; i < size; i++) {
            res.append(data[i]);
            if (i != size - 1) {
                res.append(", ");
            }
        }
        res.append(']');
        return res.toString();
    }
}
```

## 4.复杂度分析

时间复杂度分析：例：O(1)、O(n)、O(lgn)、O(nlogn)、O(n^2)

O:描述的是算法的运行时间和输入数据之间的关系

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124131518511.png)

​	上图中：c1指在for 循环中，将nums这个数组里面的元素取出来、将sum这个数取出来、将sum和nums 加在一起、最后将结果扔回给sum变量这些操作花费的总时间；实际中无法具体取得

​	c2指在整个程序中，开辟 Int 型空间 sum，并将0的初始化空间赋值给 sum,在运算结束后，还有返回sum，这些操作花费的总时间；实际中无法具体取得。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132103936.png)

​	前两个忽略常数，都是O(n),虽然第三个的常数值很小，但它还是O(n^2),但并不代表：对于任意输入来说，O(n)都要优于O(n^2)，**O 是渐进时间复杂度**，【描述 n 趋近于无穷的情况来比较算法的性能】；最后一个中，低阶的300n 相比 n^2(高阶)可忽略，故为O(n^2)；

### 1.动态数组的时间复杂度分析

##### 添加操作：通常情况下（按最坏的情况看）是 O(n) 

​	addLast(e) ---O(1)   :该操作所消耗时间与数据规模没有关系，**无论数组中有多少元素，addLast都能在常数时间内完成。**

​	addFirst(e) ---O(n)   :数组头添加元素需要**将数组每个元素向后移动一个单位，故为O(n)。**

​	add(index,e) ---O(n/2)=O(n)  :在数组 index 索引的位置插入元素e，时间复杂度与 index 相关，index = 0时和addFirst(e)相同；index = size时和addLast(e)相同，分析：假设多种情况下的概率相同，运用概率论的知识，求出时间的期望。**平均来看需要右移动 n/2 个元素，O需要忽略常数，故为 O(n)。**

##### 删除操作：通常情况下（==按最坏的情况看==）是 O(n) 

​	removeLast(e) ---O(1) 

​	removeFirst(e) ---O(n) 

​	remove(index,e) --- O(n/2)=O(n)

​	resize  ---O(n)

##### 修改操作：

已知索引：O(1)  **数组最大优势--支持随机访问，只要知道索引就可以马上访问到该数据**

未知索引：O(n)  需要从头遍历数组来找到该元素进行修改

​	**set(index,e) ---O(1)** 

##### 查找操作：需要从头遍历数组来找到该元素

​	get(index) ---O(1)  	知道所要查找元素的索引，立马可以拿到该值

​	contains(e) --- O(n)      不知道所要查找元素的索引，查看数组中是否包含某个元素

​	find(e) ---O(n)        	不知道所要查找元素的索引，查看数组中 e 元素对应的索引是多少

### 2.均摊复杂度和防止复杂度的震荡

**resize 的时间复杂度分析：**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132502059.png)

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132517730.png)

​	不会每次添加元素都会触发resize，	==因为最坏的情况（resize）要在很多次 addLast 操作后才会执行； 运用均摊复杂度比较合适；==

​	假设capacity=n，n+1次addLast，超过数组的容量，所以触发resize，相当于又加了一倍capacity的元素，所以总共进行2n+1次基本操作，平均每次addLast操作，进行2次基本操作。**这样均摊计算，addLast 和 removeLast 的均摊复杂度均为O(1);**

####  复杂度震荡

​	上面的那种所说的是大多数情况下，都不会执行resize,现在认为制造这样的情景，让 addLast 和 removeLast 依次执行多次，**这样就会每次都执行 resize ，addLast 和 removeLast 的时间复杂度均为O(n);从O(1)变为O(n)，产生复杂度震荡。**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132707690.png)

#### 解决复杂度震荡问题：

出现原因：removeLast 时 resize 过于着急,额度过于紧凑，应该减半一些

解决方案：Lazy策略，不急着缩容，设置 resize == capacity/4 时，才将 capacity 减半

图解过程：

1.添加元素超过 size ,容量扩大一倍：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132733516.png)

**2.删除元素后，先不着急缩小数组容量**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132740344.png)

**3.等到数组长度size缩小到数组容量capacity 的1/4 时**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132739989.png)

**4.缩小数组容量，但也只缩小到原来的一半，仍然预留了一半的数组容量供数组进行 addLast 操作**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132740299.png)

##### 代码：

```java
//数组长度size为数组容量1/4时才会缩小数组容量,size可能等于1，所以后面再加个判断
if (size == data.length / 4 && data.length/2 != 0) {
    resize(data.length / 2);
}
```

# 二、栈

​	栈是一种线性数据结构；相比数组，栈对应的操作是数组的子集，因为栈只能从一端添加元素，也只能从同一端取出元素，这一端称为栈顶。

​	向栈中添加元素【入栈】，从栈中取出栈顶元素【出栈】，**栈中的元素是后进先出(LIFO)，由此可知：数组也是一种后进先出的数据结构。**

## 1.栈的应用

### 1.1 无处不在的 Undo (撤销)操作 

例：文档中依次输入 沉迷  学习  不法  ---实际上是将这些元素压入栈中;执行 Undo 操作，--实际是从栈中拿出栈顶元素，通过栈顶元素来确认最近一次的操作是什么；然后将其删除，成功删除（出栈）后

### 1.2 程序调用的系统栈 

例：子过程（子逻辑）的调用在编译器内部的实现机理:![image-20190126114236948](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190126114236948.png)

A2: 程序执行到了A函数的第二行，发生中断去执行函数B

B2：程序执行到了B函数的第二行，发生中断去执行函数C

当都执行完成后，接下来如何执行需要看系统栈了，对当前的栈来说，栈顶元素是B2；故跳到B2处继续执行，然后B2出栈，

接着执行B3完成整个函数B；接下来如何执行需要再看系统栈了，栈顶元素是A2，故跳到A2处继续执行，然后A2出栈，接着执行A3完成整个函数A；接下来如何执行需要再看系统栈，栈中已经没有元素了，表示没有之前中断的程序了，故系统知道已经没有要执行的程序了。

## 2.栈的实现

栈Stack<E>的基本操作：

void push(E)   --- 【入栈】向栈中添加元素              时间复杂度：O(1)

E pop()   ---【出栈】从栈中拿出栈顶元素                 时间复杂度：O(1)

E peek()   ---查看栈顶元素                                        时间复杂度：O(1)

int getSize()  ---查看栈中总共有多少个元素              时间复杂度：O(1)

boolean isEmpty()   ---判断栈是否为空                     时间复杂度：O(1)

##### 实现基于动态数组的栈：

```java
public interface Stack<E> {
    int getSize();        //查看栈中总共有多少个元素

    boolean isEmpty();    //判断栈是否为空

    void push(E e);        //【入栈】向栈中添加元素

    E pop();            //【出栈】从栈中拿出栈顶元素

    E peek();            //查看栈顶元素
}
```

```java
public class ArrayStack<E> implements Stack<E> {
    DynamicTOurOwnArray<E> array;

    /**
     * 构造函数，传入数组的容量capacity构造Array
     * @param capacity
     */
    public ArrayStack(int capacity) {
        array=new DynamicTOurOwnArray<>(capacity);
    }

    public ArrayStack() {
        array=new DynamicTOurOwnArray<>();
    }

    // 获取数组中的元素个数
    @Override
    public int getSize() {
        return array.getSize();
    }

    @Override
    public boolean isEmpty() {
        return array.isEmpty();
    }

    @Override
    public void push(E e) {
        array.addLast(e);
    }

    @Override
    public E pop() {
        return array.delLast();
    }

    @Override
    public E peek() {
        return array.getLast();
    }

    /**
     * 查看静态数组的容量
     * @return  数组容量
     */
    public int getCapacity(){
        return array.getCapacity();
    }

    @Override
    public String toString(){
        StringBuilder res = new StringBuilder();
        res.append("Stack: ");
        res.append('[');
        for(int i = 0 ; i < array.getSize() ; i ++){
            res.append(array.get(i));
            if(i != array.getSize() - 1)
                res.append(", ");
        }
        res.append("] top");   //横向排列，栈顶在数组右侧
        return res.toString();
    }
}
```

## 3.栈的另一个应用--（括号匹配）

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126121608624.png)

思路分析：

​	声明一个栈，然后逐一遍历字符串中的每一个字符，如果这个字符是一个左括号，就将其压入栈中；完成之后，判断右括号是否和栈顶的左括号相匹配，如果匹配成功就可以出栈；直至所有的都匹配成功，这时所有的元素都出栈，栈为空时表明字符串是一个有效的字符串。如果不是有效的字符串，在右括号与左括号相匹配时不能匹配成功，直接停止返回这是一个错误的字符串。

栈顶元素反映了在嵌套的层次关系中，最近的需要匹配的元素。

```java
public class StackSample {
    public boolean isValid(String s) {
        //声明栈stack
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            //获取字符串的第i个元素
            char c = s.charAt(i);
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) {
                    return false;
                }
                //取栈顶元素，与准备入栈的元素进行匹配
                char topChar = stack.pop();
                if (c == ')' && topChar != '(') {
                    return false;
                }
                if (c == ']' && topChar != '[') {
                    return false;
                }
                if (c == '}' && topChar != '{') {
                    return false;
                }
            }
        }
        return stack.isEmpty();     //判断栈是否为空,如果是空的话则匹配成功
    }

    public static void main(String[] args) {

        System.out.println((new StackSample()).isValid("()[]{}"));    //传入测试用例
        System.out.println((new StackSample()).isValid("([)]"));
    }
}
```

# 三、队列

​	队列是一种线性数据结构；相比数组，队列对应的操作也是数组的子集；**只能从一端（队尾）添加元素，只能从另一端（队首）取出元素，队列是先进先出的数据结构（First In First Out [FIFO]）。**

## 1.队列的实现

队列Queue<E>的基本操作：

void enqueue(E)   --- 【入队】向队列中添加元素              时间复杂度：O(1)

E dequeue()   ---【出队】从队列中拿出队首元素               时间复杂度：O(n)【队首后面的所有的元素都要移动一下】

E getFornt()   ---查看队首元素                                      	 时间复杂度：O(1)

int getSize()  ---查看队列中总共有多少个元素             	 时间复杂度：O(1)

boolean isEmpty()   ---判断队列是否为空                     	 时间复杂度：O(1)

```java
public class ArrayQueue<E> implements Queue<E> {
    private DynamicTOurOwnArray<E> array;

    //构造函数，传入数组容量
    public ArrayQueue(int capacity) {
        array = new DynamicTOurOwnArray<>(capacity);
    }

    public ArrayQueue() {
        array = new DynamicTOurOwnArray<>();
    }

    @Override
    public int getSize() {
        return array.getSize();
    }

    @Override
    public boolean isEmpty() {
        return array.isEmpty();
    }

    //新增元素,从队尾进，队头出
    @Override
    public void enqueue(E e) {
        array.addLast(e);
    }

    //查看静态数组容量
    public int getCapacity() {
        return array.getCapacity();
    }

    //取出队列头部元素
    @Override
    public E dequeue() {
        return array.delFirst();
    }

    //查看队首元素
    @Override
    public E getFront() {
        return array.getFirst();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append("Queue: ");
        res.append("front [");    //数组左侧是队首
        for (int i = 0; i < array.getSize(); i++) {
            res.append(array.get(i));    //将队列的每个元素都放到 res 中
            if (i != array.getSize() - 1)    //如果 i 不是array 的最后一个元素
                res.append(", ");
        }
        res.append("] tail");    //数组右侧是队尾
        return res.toString();
    }

    public static void main(String[] args) {
        ArrayQueue<Integer> queue = new ArrayQueue<>();
        for(int i = 0 ; i < 10 ; i ++){
            queue.enqueue(i);     //添加元素
            System.out.println("添加元素后的队列："+queue);
            if(i % 3 == 2){
                queue.dequeue();
                System.out.println("取出元素后的队列："+queue); //取出元素
            }
        }
    }
}
```

## 2.数组队列的问题

​	**删除队首元素（左侧队首）**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164156065.png)

​	**a 移除队列，后面的移动一个单位，size -1;得图**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164202334.png)

​	**但==如果 a移除队列后，后面的不移动，记录目前的队首位置为 front，队尾为 tail,只要维护 front 的指向即可（front++）,不需要所有的元素移动一个单位，即可得到循环队列==这种实现方式。**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164202375.png)

## 3.循环队列

​	**front == tail 		 -----		 队列为空时【起始状态如下图所示】**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164214658.png)

​	**队列进入5个元素后【front不变，tail 右移即可（tail++)】**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164240890.png)

​	**将 a 移除队列，【tail不变，front 右移即可（front++)】其余元素不必移动**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164245218.png)

​	继续加入元素到队列中，==**装满后面的空间，前面还有空着的空间，tail 就会移动到前面 0 的位置【环形结构】**==

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164252747.png)

​	**（tail+1）%capacity == front	 ---	队列满时 ，效果如图【capacity 中有意识的浪费一个空间,capacity为数组的长度：data.length】**

​	队满的时候，front和tail只相差一个元素，所以tail+1其实就是等于front。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164258464.png)

队列Queue<E>的基本操作：

void enqueue(E)   --- 【入队】向队列中添加元素              时间复杂度：O(1)【均摊】

E dequeue()   ---【出队】从队列中拿出队首元素           时间复杂度：O(1)【均摊】

E getFornt()   ---查看队首元素                                        时间复杂度：O(1)

int getSize()  ---查看队列中总共有多少个元素              时间复杂度：O(1)

boolean isEmpty()   ---判断队列是否为空                     时间复杂度：O(1)

#### 循环队列的实现：

```java
public class LoopQueue<E> implements Queue<E> {
    private E[] data;
    private int front;
    private int tail;
    private int size;           //元素个数

    //定义数组容积capacity
    public LoopQueue(int capacity) {
        //循环数组中有意识的浪费一个空间,所以这里要+1，相应的getCapacity方法那里要-1
        data = (E[]) new Object[capacity + 1];
        front = 0;
        tail = 0;
        size = 0;
    }

    public LoopQueue() {
        this(10);
    }

    //循环队列中最多装载的元素数量，要注意有一个空间要浪费的，即队头和队尾最多缺少一个元素的距离
    public int getCapacity() {
        return data.length - 1;
    }

    @Override
    public boolean isEmpty() {
        return front == tail;
    }

    @Override
    public int getSize() {
        return size;
    }

    //循环队列入队,front不变，tail+1，因为是循环队列，所以要跟data.length取余
    @Override
    public void enqueue(E e) {

        if ((tail + 1) % data.length == front) {   //判断队列是否“满”，队满则扩容
            resize(getCapacity() * 2);        //队列扩容,循环队列最多存放的元素的2倍
        }
        data[tail] = e;
        tail = (tail + 1) % data.length;
        size++;
    }

    private void resize(int newCapacity) {
        //因为浪费一个空间，所以要加一
        E[] newData = (E[]) new Object[newCapacity + 1];
//        遍历方式一，toString中是另一种便利方式
        for (int i = 0; i < size; i++) {
            //将data中的size个元素放到了newData中的[0，size-1]的位置
            newData[i] = data[(i + front) % data.length];
        }
        data = newData;
        front = 0;
        tail = size;
    }

    //循环队列出队，tail不变，front+1，因为是循环队列，所以要跟data.length取余
    @Override
    public E dequeue() {
        if (isEmpty()) {
            throw new IllegalArgumentException("queue is empty");
        }
        E ret = data[front];
        data[front] = null;     //清空队首
        front = (front + 1) % data.length;
        size--;
        if (size == getCapacity() / 4 && getCapacity() / 2 != 0) {
            resize(getCapacity() / 2);
        }
        return ret;
    }

    //取得队首元素
    @Override
    public E getFront(){
        if(isEmpty())
            throw new IllegalArgumentException("Queue is empty.");
        return data[front];
    }

    @Override
    public String toString(){		//打印输出

        StringBuilder res = new StringBuilder();
        res.append(String.format("LoopQueue: size = %d , capacity = %d\n", size, getCapacity()));
        res.append("front [");		//队列左侧是队首
        //循环地+1，所以要(i + 1) % data.length；第二种遍历方式，resize里面是另一种遍历方式
        for(int i = front ; i != tail ; i = (i + 1) % data.length){
            res.append(data[i]);
            if((i + 1) % data.length != tail)	//判断当前索引不是最后一个元素，既不是队尾
                res.append(", ");
        }
        res.append("] tail");		//队列右侧是队尾
        return res.toString();
    }

    public static void main(String[] args){

        LoopQueue<Integer> queue = new LoopQueue<>();	//添加测试用例
        for(int i = 0 ; i < 10 ; i ++){
            queue.enqueue(i);		//将0-9这10个数字存放到 queue 中
            System.out.println(queue);

            if(i % 3 == 2){
                queue.dequeue();	//每隔三个数字执行出队操作
                System.out.println(queue);
            }
        }
    }
}
```

## 4.数组队列和循环队列的比较（执行效率）

代码：

```java
public class TestQueue {
    /**
     * 测试使用q运行opCount个enqueue和dequeue操作所需要的时间
     *
     * @param queue   测试的队列
     * @param opCount 队列个数
     * @return 花费的时间
     */
    private static double testQueue(Queue<Integer> queue, int opCount) {
        long startTime = System.nanoTime();
        Random random = new Random();
        for (int i = 0; i < opCount; i++) {
            queue.enqueue(random.nextInt(Integer.MAX_VALUE));
        }
        for (int i = 0; i < opCount; i++) {
            queue.dequeue();
        }
        long endTime = System.nanoTime();

        return (endTime - startTime) / 1000000000.0;
    }

    public static void main(String[] args) {
        //操作数量
        int opCount = 100000;
        ArrayQueue<Integer> arrayQueue = new ArrayQueue<>();
        double time1 = testQueue(arrayQueue, opCount);
        System.out.println("ArrayQueue, time: " + time1 + " s");
        LoopQueue<Integer> loopQueue = new LoopQueue<>();        //循环队列输出时间
        double time2 = testQueue(loopQueue, opCount);
        System.out.println("LoopQueue, time: " + time2 + " s");
    }
}
```

数组队列执行10万个队列入队出队所需的时间远远大于循环队列所需的时间

​	==主要的差距在出队的过程中==，**数组队列每一次出队后面所有的元素都要向前挪动一个位置，时间复杂度为O(n),则对于testQueue来说是O(n2);循环队列 则无需挪动位置，时间复杂度为O(n),对于testQueue来说是O(n).**

# 四、链表(Linked List)

## 1.基本概念

==链表：最简单的动态数据结构==

重要性：更深入的理解引用和递归，辅助组成其他数据结构

**优点：真正的动态，不需要处理固定的容量**

**缺点：丧失了随机访问的能力**

与数组对比：数组最好用于索引有语义的情况(例 score[2])，其最大的有点是支持快速查询；链表不适合用于索引有语义的情况，最大优点是动态

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185242865.png)

### 链表的结构：

图解：数据存储在 “节点”（Node）中，实际存储在E  e 中，数据与数据之间的链接(对下一个链表的引用)由 next 完成；==最后一个节点 next 存储的为 Null；如果为Null则证明是最后一个节点。==

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185258131.png)

### ![image-20190127162624478](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190127162624478.png)

### 数组和链表的比较：

![image-20190127162846543](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190127162846543.png)

```java
public class LinkedList<E> {
    //声明Node类，只有链表内才能访问
    private class Node {
        //声明成员变量E类型的e，存放元素
        public E e;
        public Node next;

        //声明构造函数，用户也同时传来 e 和 next
        public Node(E e, Node next) {
            this.e = e;     //将当前节点的e赋值成用户传来的e
            this.next = next;       //将当前节点的next赋值成用户传来的next
        }

        public Node(E e) {            //用户只传来e
            this(e, null);            //将当前节点的e赋值成用户传来的e，next设为null
        }

        public Node() {                //用户什么都不传
            this(null, null);        //将e和next都设为null
        }

        @Override
        public String toString() {        //打印输出
            return e.toString();
        }
    }
}
```

## 2.在链表中添加元素

​	对于一个链表来说，想要访问存储在其中的所有节点，**我们必须把链表的头 head 存储起来**， 

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185339056.png)

### ==在链表头添加元素==:

​	图解（要将 666【即node类对象实例】 加入链表中而不破坏现有的链表结构）

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185401900.png)

步骤：1.让 node 的 next 指向现在链表的头，即执行  node.next = head

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185432984.png)

​	2. 此时，**666 成为新的链表头，让 head  指向新的 666 节点，即执行  head = node**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185449693.png)

```java
private Node head;       //声明Node型变量head
    private int size;       //不能外部修改，记录链表中有多少个元素

    public LinkedList() {
        head = null;
        size = 0;
    }

    // 获取链表中的元素个数
    public int getSize() {
        return size;
    }

    //判断链表是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    // 在链表头添加新的元素e
    public void addFirst(E e) {
//        Node node = new Node(e);
//        node.next = head;
//        head = node;
        //等同于上面的三句代码,将当前节点的e赋值成用户传来的e，然后将当前节点的next赋值成用户传来的next
        head = new Node(e, head);
        size++;
    }
```

### ==在链表中间添加元素:==

图解：将 666 插入到链表中 1 的位置

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185505584.png)

步骤：1.要插入节点 666 ，必须要找到插入666之后，这个节点之前的节点是谁，将其叫做 prev，其初始化和 head 在同一个地方,执行 Node prev = head;    

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185517225.png)

步骤2：要找到 666 之前节点 ，因为插入 666 的索引为2【链表中并没有索引这个概念】故之前节点的索引为 1 ，从0开始遍历，遍历到索引为1的位置即可；

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185531535.png)

步骤3：将 node 的 next 指向 prev 的下一个元素，即执行 node.next = prev.next

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185539887.png)

步骤4：prev 的 next 指向 node, 即执行 node.next = prev.next,成功将 666 插入到链表中

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185550481.png)

==关键：找到要添加的节点的前一个节点（prev）==

代码：

```java
// 在链表的index(0-based)位置添加新的元素e
    public void add(int index, E e) {
        //判断 index 的合法性
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("index is invalid");
        }
        if (index == 0) {
            addFirst(e);
        } else {
            Node prev = head;
            //把当前 prev 存的下一个节点放到 prev 变量中，prev会在链表中一直移动，
            // 直到 index - 1 这个位置,即index前一个节点
            for (int i = 0; i < index - 1; i++) {
                prev = prev.next;
            }
//            Node node=new Node(e);    //创建node,元素为 e
//            node.next = prev.next;   //将 node 的 next 指向 prev 的下一个元素
//            prev.next = node;          //prev 的 next 指向 node
            prev.next = new Node(e, prev.next);     //相当于上面三行代码
            size++;
        }
    }
```

## 3.使用链表的虚拟头结点

​	上面所述的方法中在链表头添加元素时存在特殊：**为链表添加元素的过程要找到待添加位之前的节点，但对于链表头来说并没有之前的节点，所以在逻辑上特殊。**通过使用链表的虚拟头节点即可将链表头添加元素与其他位置添加元素统一起来。

图解：==创建个虚拟节点即可解决链表头添加元素时的问题==，对链表来说，**第一个元素是 dummyHead 的 next 对应的节点的元素，而不是 dummyHead 对应的节点的元素，dummyHead 这个位置的元素是根本不存在的，对用户来说也没有意义，只是为了逻辑编写方便设置的虚拟头结点。**这样所有的元素都有前一个位置的节点，并且初始的时候 dummyHead 指向的就是 0 这个元素的前一个节点。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185652189.png)

## 4.从链表中删除元素

有虚拟头结点的链表如图所示：![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190127113947860.png)

**想要删除索引为 2 的元素，步骤：**

1.先找到所要删除元素的前一个节点,即为图中的 1

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190127114025246.png)

2.prev 对应节点的 next 就是所要删除的节点，称为 delNode,

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190127113934170.png)

3.将 prev 对应节点的 next 赋值称为要删除的节点 delNode 的 next;即 执行 prev.next = delNode.next,从某种意义上来说，就将索引为 2 的元素从链表中删除了。 

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190127114153369.png)

4.让 索引为 2 的元素的 next 与链表整个脱离开来，即让 delNode 的 next 指向 NULL,即执行 delNode.next = null ;通过这个测试，就将索引为 2 的元素真正的从链表中删除。

## 5.链表时间复杂度分析

### 1.添加操作:O(n)

addLast(e)     ---O(n) [需要从链表头开始比遍历到链表尾]

addFirst(e)     ---O(1)[直接添加即可]

addIndex(e)   ---O(n/2) = O(n)【均摊】

### 2.删除操作

removeLast(e)    ---O(n)[需要从头找到最后一个元素的前一个位置的节点]

removeFirst(e)   ---O(1)[虚拟头节点就是第一个元素的前一个节点]

removeIndex(e)   ---O(n/2) = O(n)

### 3.修改操作（链表不支持随机访问）

set(index e)    ---O(n)[修改元素必须从头遍历找到要修改元素的位置]

### 4.查找操作

get(index)   ---O(n)[需要从头遍历整个链表]

contains(e)    ---O(n)[需要从头遍历整个链表]

总结：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190127114235855.png)

## 6.使用链表实现栈

==将链表头当做栈顶，用链表作为栈的底层实现来完成栈的结构==

![image-20190127181325044](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190127181325044.png)

```java
public class LinkedListStack<E> implements Stack<E> {       //实现 Stack 接口
    private LinkedList<E> list;     //私有链表对象lis

    public LinkedListStack() {
        list = new LinkedList<>();        //链表初始化
    }

    @Override
    public int getSize() {
        return list.getSize();
    }

    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }

    @Override
    public void push(E e) {
        list.addFirst(e);
    }

    @Override
    public E pop() {
        return list.removeFirst();
    }

    //查看栈顶元素
    @Override
    public E peek() {
        return list.getFirst();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append("Stack: top ");
        res.append(list);
        return res.toString();
    }

    public static void main(String[] args) {

        LinkedListStack<Integer> stack = new LinkedListStack<>();    //声明LinkedListStack的对象stack

        for (int i = 0; i < 5; i++) {    //向栈中压入5个元素
            stack.push(i);
            System.out.println(stack);
        }

        stack.pop();    //从栈中取出元素
        System.out.println(stack);
    }
}
```

### 比较栈与链表的性能差异：

​	**链表栈要比数组栈要快一些，数组栈中，经常需要重新分配整个静态数组，将原来的静态元素分配到新的数组中，比较耗时。**

​	但这个结果不一定对，因为这二者的时间复杂度都是同一级别的，不存在过多的差距。如果输入量增到1000000时，可能数组栈更快了，链表每次new一个空间需要耗时。

## 7.使用链表实现队列

​	在链表的头进行增加或删除操作比较容易，因为有 head 帮助我们标记头部，想要在尾部也进行该操作，加入 tail 帮助我们标记尾部即可使增加操作更加容易，但删除操作需要找到 tail 的前一项，也只能通过遍历的方式来找到。**故==从 head 端删除元素，从tail端插入元素==；如果链表为空时，由于没有 dummyHead，要注意链表为空的情况。**	

### 比较数组、队列、与链表的性能差异：

#### ​	==数组队列--O(n);循环队列--O(1);链表实现队列--O(1)==

# 五、链表和递归

LeetCode题目：

![image-20190128160158783](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190128160158783.png)

### 1.不使用虚拟头结点

代码：https://github.com/JDawnF/structure/tree/master/src/recursion

### 2.使用虚拟头结点

代码：https://github.com/JDawnF/structure/tree/master/src/recursion

### 3.链表与递归

**递归定义：本质上，将原来的问题，转换为更小的同一问题(可以体现在处理的元素更少了)**

例：数组求和：

Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1])				[更小的同一问题]

Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1])				[更小的同一问题]

. . .

 Sum(arr[n-1...n-1]) = arr[n-1] + Sum([])					[最基本的问题]---（只要 Sum([]) 值解决，根据同一逻辑可解决整个问题）

代码实现：

```java
public class Sum {
    public static int sum(int[] arr){  // 这个sum是由用户来使用的
        return sum(arr, 0);       //调用下面的sum
    }

    // 计算arr[l...n)这个区间内所有数字的和
    private static int sum(int[] arr, int left){   //这个 sum 函数是真正的递归函数
        if(left == arr.length) //相当于整个数组为空的时候
            return 0;
        //递归调用【从计算 left--n 的和变为 left+1 -- n 的和】
        return arr[left] + sum(arr, left + 1);
    }

    public static void main(String[] args) {

        int[] nums = {1, 2, 3, 4, 5, 6, 7, 8};
        System.out.println(sum(nums));
    }
}
```

在上述代码中，1.求解最基本的问题

​	if(left == arr.length)  
​        	    return 0;
2.把原问题转换为更小的问题，要根据更小的问题的答案构建出原问题的答案  arr[left] + 

​	 return arr[left] + sum(arr, left + 1);

### 4. 链表的天然递归结构性质

​	链表可以看做是一个 **头结点 0+ 一个更短的链表**，在图中，1 就是更短链表的头结点；也可以看做是 头结点 0+ 一个更短的链表，2 就是更短链表的头结点；[以此类推](https://www.baidu.com/s?wd=%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)，直到最后，可理解为 NULL 本身也是一个链表，是哪个最普通的链表。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-8666635.png)

**解决链表中删除元素的问题：**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171052447.png)

**对于最原始的链表，可看做是 头结点e + 一个更短的链表**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171058211.png)

​	如何通过得到解来解决原问题的解？**对原问题，就是没有考虑 头结点 ：如果头结点e != val(无需删除)，最终原问题的结果，就是头结点e +求得的==子问题链表==；如果需要删除的话，就是后续求出的链表**；![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171133276.png)

代码：

https://github.com/JDawnF/structure/tree/master/src/recursion

### 5. 递归运行的机制：递归的微观解读

##### ==递归调用的代价：函数调用+系统栈空间==

**递归的实质：递归函数的调用就是函数调用，只不过调用的是它自身**

数组求和：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171157485.png)

​	一步步执行到，l==n\==2的时候，return结果，此时一步步递归回去计算结果。即x=0，然后res=0+10,再然后res=0+10+6

**链表中删除元素**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171212945.png)

**图解过程：**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171225214.png)

​	先调用第一步的代码，head不为空，调用第二步代码，这时候传入的是head.next，即传入7，同理，再调用一次函数，传入8，然后继续，传入8.next，即传入空，然后此时head为空了，所以返回null，回到上次的调用，即传入8.next的时候，第二步里面，head.next得到的值是空null，此时再执行第三步，判断head.val是否等于val，如果不等于就返回head，此时不等于，所以返回节点8指向空，此时拼接到节点7后面，然后执行第三步，此时val相等，所以返回7.next,即返回节点8指向空，然后再向上拼接继续重复第二三步。

#### 特殊链表：

##### **1.双链表**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171241404.png)

​	每个节点有两个指针(引用)

##### 2.循环链表

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171254025.png)

​	设置虚拟头节点，尾节点不执行null，执行虚拟头节点，在虚拟头节点添加元素就相当于插入到链表中。

##### 3.数组链表（明确知道要处理元素的个数）

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171253954.png)

# 六、二分搜索树

## 1、树结构

**​使用树结构的原因：**

1.树结构是一种天然的组织结构​      

2.数据使用树结构存储后，查找高效

### 二叉树

​	它是动态数据结构【不需要在创建数据结构的时候就决定好要存储多少数据，要添加元素就new一个新的空间加入到其中即可】

![image-20190130130159092](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190130130159092.png)

​	**节点 Node 中，除了要存放元素 e 之外，还要存储两个指向其他节点的引用 left【左孩子】 和 right 【右孩子】**

### 二叉树要点：

1.二叉树具有**唯一的根节点**；

2.二叉树中每个节点最多有两个孩子，每个节点最多有一个父亲节点；一个孩子也没有的叫做叶子节点

3.二叉树具有**天然的递归结构**【每个节点的左子树也是二叉树、每个节点的右子树也是二叉树】

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130130257634.png)

4.二叉树不一定都是“满”的【满二叉树：除叶子节点外，每个节点都有两个孩子】

5.**一个节点、甚至 NULL 也是二叉树**

### 二分搜索树：

1.二分搜索树是二叉树

2.二分搜索树的每个节点的值：**大于其左子树的所有节点的值且小于其右子树的所有节点的值**

3.**二分搜索树的每个子树也是二分搜索树**

4.存储的元素必须具有可比较性【存储自定义数据类型，必须自定义好数据的比较方式】

![image-20190130130323690](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190130130323690.png)

代码：



## 2、向二分搜索树中添加元素

图解步骤：

![image-20190130130400034](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190130130400034.png)

**特殊情况（有重复的话，该元素就相当于已经存在于树中，不做任何改变）**

![image-20190130130419592](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190130130419592.png)

​	**如果想要包含重复元素，只需定义：左子树 <= 节点；右子树 >= 节点【只需将 = 关系放到定义中即可】**

代码：

## 3、二分搜索树的查询操作



## 4、二分搜索树的遍历



### 4.1 二分搜索树的前序遍历

**遍历：就是把所有的节点都访问一遍**

​	二分搜索树的递归操作：从根节点开始，查看根节点是否是要查找的元素；是的话直接执行操作即可，不是的话就看要查找的元素是否 < 根节点 ，是的话在左子树中继续进行该操作；若是 > 根节点,在右子树中继续进行该操作【每次只选择一个子树进行下去】

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130130922343.png)

tranverse(node.left) -- 既要进行二叉树左子树的调用

tranverse(node.right) --也要进行二叉树右子树的调用

##### **==前序遍历：先访问该节点，再访问左右子树==**

### 4.2 二分搜索树的中序遍历和后序遍历

##### ​	==中序遍历：要访问节点放在中间，先访问左子树,再访问节点；最后访问右子树==

![image-20190130131025343](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190130131025343.png)

​	**二分搜索树的中序遍历结果是顺序的**】 

##### ==后序遍历：要访问节点放在最后，先访问左子树,再访问右子树；最后访问节点==

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131045810.png)

#### 分析结果：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131123341.png)

**前序遍历:节点在首位，故只有执行最左侧的点时才会执行递归调用**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131141654.png)

**中序遍历:节点在中间，故只有执行最中间的点时才会执行递归调用**

**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131150452.png)**

**后序遍历:节点在后面，故只有执行最后面的点时才会执行递归调用**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131151465.png)

### 4.3 二分搜索树前序遍历的非递归实现

**前序遍历**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131203194.png)

**使用栈来模拟递归调用**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131238908.png)





































参照：慕课网《玩转数据结构》

​	https://blog.csdn.net/jianghao233/article/list/2?t=1&







































































































































































































































































































































































































