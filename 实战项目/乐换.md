# 一、前端

## 1.前端页面构建分页栏显示

```js
//定义搜索对象的结构，传给后端，充当搜索条件，除了spec是json，其他都是字符串，当需要新增搜索条件时，只需要在后面添加对应的key即可
    //pageNo：页码；pageSize：总页数
    $scope.searchMap = {
        'keywords': '', 'category': '', 'brand': '', 'spec': {}, 'price': '',
        'pageNo': 1, 'pageSize': 40, 'sort': '', 'sortField': ''};//搜索条件封装对象

//中间省略一堆代码

//构建分页栏
    //构建分页标签(totalPages为总页数),如果搜索的商品太多，会导致页面太多不美观，于是设定为最多显示五页：1,2,3,4,5，
    // 然后显示下一页，以当前页为中心的5个页码，要判断当前页要大于等于3，或者小于最大页码-2
    // 则显示结果为：1 2 3 4 5或：1 2 ... 5 6 7
    buildPageLabel = function () {
        //构建分页栏，即分页码1，2，3，4，5...
        $scope.pageLabel = [];  //新增分页栏数组
        // 8 9 10 11 12,8为开始页码，12位截止页码
        var firstPage = 1;  //开始页码
        var lastPage = $scope.resultMap.totalPages;//截止页码
        $scope.firstDot = true;     //前面有省略号小点
        $scope.lastDot = true;      //后边有省略号小点
        // 总页数分为两大类：多于5页，少于等于5页，
        // 少于等于于5页的时候，前后都不设置点，直接遍历存入分页栏数组即可
        // 多于5页的时候，分为三种情况，一种是当前页面少于等于3页的时候，前面不设置点；
                                // 当前页多于总页数-2的时候，从总页数-4开始，后面不设置点；
                                // 当前页大于3小于总页数-2的时候，显示当前页的前两页和当前页的后五页
        if ($scope.resultMap.totalPages > 5) {       //如果总页数大于5页,显示部分页码
            if ($scope.searchMap.pageNo <= 3) {     //如果当前页页码小于等于3
                lastPage = 5; //前5页
                $scope.firstDot = false;    //前面没点
            } else if ($scope.searchMap.pageNo >= lastPage - 2) {   //如果当前页大于等于最大页码-2
                firstPage = $scope.resultMap.totalPages - 4;		 //后5页
                $scope.lastDot = false;//后边没点
            } else { //显示当前页为中心的5页
                firstPage = $scope.searchMap.pageNo - 2;
                lastPage = $scope.searchMap.pageNo + 2;
            }
        } else {
            $scope.firstDot = false;//前面无点
            $scope.lastDot = false;//后边无点

        }
        //循环产生页码标签,从开始页码到截止页码，如果总页数小于5则全显示
        for (var i = firstPage; i <= lastPage; i++) {
            $scope.pageLabel.push(i);
        }
    }
```

​	写好后在js的查询方法中调用，再到HTML页面对应的页面遍历分页栏数组。

此外，分页还要注意就是第一页和最后一页的上一页和下一页是不能点的，可以通过两个方法来判断是否为第一页或者最后一页，然后在点击上一页和下一页的标签样式中调用，如果是第一页或者最后一页，则对应的标签样式是无效的。

```js
// controller.js
//判断当前页是否为第一页
$scope.isTopPage = function () {
    if ($scope.searchMap.pageNo == 1) {
        return true;
    } else {
        return false;
    }
}

//判断当前页是否为最后一页
$scope.isEndPage = function () {
    if ($scope.searchMap.pageNo == $scope.resultMap.totalPages) {
        return true;
    } else {
        return false;
    }
}
```

```html
<!--'disabled'表示是白色,即可以点击的，isTopPage判断是否为第一页，如果是的话点击的样式不可用-->
<li class="prev {{isTopPage()?'disabled':''}}">
    <a href="#" ng-click="queryByPage(searchMap.pageNo-1)">«</a>
</li>
<li class="next {{isEndPage()?'disabled':''}}">
    <a href="#" ng-click="queryByPage(searchMap.pageNo+1)">»</a>
</li>
```

## 2.FreeMarker生成文件，生产数据

使用步骤：

第一步：创建一个 Configuration 对象，直接 new 一个对象。构造方法的参数就是 freemarker的版本号。

第二步：设置模板文件所在的路径。

第三步：设置模板文件使用的字符集。一般就是 utf-8.

第四步：加载一个模板，创建一个模板对象。

第五步：创建一个模板使用的数据集，可以是 pojo 也可以是 map。一般是 Map。

第六步：创建一个 Writer 对象，一般创建一 FileWriter 对象，指定生成的文件名。

第七步：调用模板对象的 process 方法输出文件。

第八步：关闭流

### 模板文件中四种元素

  1、文本，直接输出的部分(body)
   2、注释，即<#--...-->格式不会输出
   3、插值（Interpolation）：==即${..}部分,将使用数据模型中的部分替代输出==，相当于调用数据
   4、FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。

模板文件：

```html
<html>
<head>
	<meta charset="utf-8">
	<title>Freemarker入门小DEMO </title>
</head>
<body>
<#--我只是一个注释，我不会有任何输出  -->
${name},你好。${message}
</body>
</html>
```

创建Test类 main方法如下：

```Java
	     //1.创建配置类(对象)
		Configuration configuration=new Configuration(Configuration.getVersion());
		//2.设置上面创建的模板所在的目录 
		configuration.setDirectoryForTemplateLoading(new File("D:/pinyougou_work/freemarkerDemo/src/main/resources/"));
		//3.设置字符集
		configuration.setDefaultEncoding("utf-8");
		//4.加载模板
		Template template = configuration.getTemplate("test.ftl");
		//5.创建数据模型(可以是pojo对象，也可以是map，map的key对应ftl文件中的属性名)
		Map map=new HashMap();
		map.put("name", "张三 ");
		map.put("message", "欢迎来到神奇的品优购世界！");
		//6.创建Writer输出流对象，可以指定
		Writer out =new FileWriter(new File("d:\\test.html"));
		//7.通过模板对象输出
		template.process(map, out);
		//8.关闭Writer对象
		out.close();

```

## 3.购物车

### 3.1 service层

```js
//购物车服务层
app.service('cartService', function ($http) {
    //购物车列表
    this.findCartList = function () {
        return $http.get('cart/findCartList.do');
    }
    //添加商品到购物车
    this.addGoodsToCartList = function (itemId, num) {
        return $http.get('cart/addGoodsToCartList.do?itemId=' + itemId + '&num=' + num);
    }
    //求合计商品数量,遍历每个商家下面的商品订单list对应的具体商品订单
    this.sum = function (cartList) {
        var totalValue = {totalNum: 0, totalMoney: 0.00};   //合计实体，是一个Json格式的变量
        for (var i = 0; i < cartList.length; i++) {
            //购物车对象，购物车列表是一个大list，大list里面是每个商家对应的商品订单list
            var cart = cartList[i];
            // 遍历商品订单list
            for (var j = 0; j < cart.orderItemList.length; j++) {
                var orderItem = cart.orderItemList[j];  //购物车中的商品订单明细
                totalValue.totalNum += orderItem.num;
                totalValue.totalMoney += orderItem.totalFee;
            }
        }
        return totalValue;
    }

    //获取当前登录账号的收货地址列表
    this.findAddressList = function () {
        return $http.get('address/findListByLoginUser.do');
    }
    //保存订单
    this.submitOrder = function (order) {
        return $http.post('order/add.do', order);
    }
});
```

### 3.2 controller层

```js
//购物车控制层
app.controller('cartController', function ($scope, cartService) {
    //查询购物车列表
    $scope.findCartList = function () {
        cartService.findCartList().success(
            function (response) {
                $scope.cartList = response;     //返回购物车列表
                $scope.totalValue = cartService.sum($scope.cartList);//求合计数,参数是购物车列表
            }
        );
    }
    //添加商品到购物车,数量加减
    $scope.addGoodsToCartList = function (itemId, num) {
        cartService.addGoodsToCartList(itemId, num).success(
            function (response) {
                if (response.success) {
                    $scope.findCartList();//刷新列表
                } else {
                    alert(response.message);//弹出错误提示
                }
            }
        );
    }

    //获取当前登录账号的收货地址列表
    $scope.findAddressList = function () {
        cartService.findAddressList().success(
            function (response) {
                $scope.addressList = response;
                for (var i = 0; i < $scope.addressList.length; i++) {
                    if ($scope.addressList[i].isDefault == '1') {
                        $scope.address = $scope.addressList[i];
                        break;
                    }
                }
            }
        );
    }

    //选择地址
    $scope.selectAddress = function (address) {
        $scope.address = address;
    }
    //判断是否是当前选中的地址
    $scope.isSelectedAddress = function (address) {
        if (address == $scope.address) {
            return true;
        } else {
            return false;
        }
    }
    //默认付款方式为1，表示微信付款
    $scope.order = {paymentType: '1'}
    //选择支付方式
    $scope.selectPayType = function (type) {
        $scope.order.paymentType = type;
    }
    //保存订单
    $scope.submitOrder = function () {
        $scope.order.receiverAreaName = $scope.address.address;//地址
        $scope.order.receiverMobile = $scope.address.mobile;//手机
        $scope.order.receiver = $scope.address.contact;//联系人
        cartService.submitOrder($scope.order).success(
            function (response) {
                if (response.success) {
                    //页面跳转
                    if ($scope.order.paymentType == '1') {
                        //如果是微信支付，跳转到支付页面
                        location.href = "pay.html";
                    } else {//如果货到付款，跳转到提示页面
                        location.href = "paysuccess.html";
                    }
                } else {
                    alert(response.message);   //也可以跳转到提示页面
                }
            }
        );
    }
});
```

# 二、后端

## 1、消息中间件

### 1.1 概述

​	消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行[分布式系统](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者）。**中间件其实说到底就是一种服务型的软件，介于应用和底层数据之间的关系。消息中间件解决系统之间异步调用的关系。**

### 1.2 作用

#### 1)系统解耦

​	当一个主系统有多个子系统的时候，可以通过消息中间件来实现解耦合。![img](/Users/jack/Desktop/md/images/1208468-20190126142747039-343663977.png)

#### **2）异步调用**

​	假设你有一个系统调用链路，是系统A调用系统B，一般耗时20ms；系统B调用系统C，一般耗时200ms；系统C调用系统D，一般耗时2s，如下图所示。

![img](/Users/jack/Desktop/md/images/1208468-20190126142757375-1232720078.png)

​	因为系统D耗时比较久，所以可以将系统D抽离出来，实现异步调用，即先不用急着启动系统D，等到上面的完成之后再启动也可以，系统D回去消费前面几个系统发过来的数据。

![img](/Users/jack/Desktop/md/images/1208468-20190126142809076-677253897.png)

#### 3) 流量削峰

​	假如有个系统平时每秒请求只有几百个，然后在高峰期突然瞬时高峰达到每秒上千个甚至几千个，这时候原来的服务器配置可能就不大顶得住了。但是每天又只有半个小时的瞬间高峰期，如果增加服务器又有点浪费时间，这个时候也可以通过消息中间件解决。

​	用有限的机器资源承载高并发请求，如果业务场景允许异步削峰，高峰期积压一些请求在MQ里，然后高峰期过了，后台系统在一定时间内消费完毕不再积压的话，那就很适合用这种技术方案。

![img](/Users/jack/Desktop/md/images/1208468-20190126143304043-1472821196.png)

### 1.3 消息中间件分类与选择

1. ActiveMQ/ApolloMQ

优点：老牌的消息队列，**使用Java语言编写。对JMS支持最好，采用多线程并发，资源消耗比较大。**

缺点：由于历史悠久，历史包袱较多，版本更新很缓慢。集群模式需要依赖Zookeeper实现。最新架构的产品被命名为Apollo，号称下一代ActiveMQ，目前案例较少。

2. RocketMQ/Kafka

优点：**专为海量消息传递打造，主张使用拉模式，天然的集群、HA、负载均衡支持。**

缺点：所谓鱼和熊掌不可兼得，放弃了一些消息中间件的灵活性，使用的场景较窄，需关注你的业务模式是否契合，否则山寨变相使用很别扭。除此之外，RocketMQ没有.NET下的客户端可用。RocketMQ身出名门，但使用者不多，生态较小，毕竟消息量能达到这种体量的公司不多，你也可以直接去购买阿里云的消息服务。Kafka生态完善，其代码是用Scala语言写成，可靠性比RocketMQ低一些。

3. RabbitMQ

优点：生态丰富，使用者众，有很多人在前面踩坑。AMQP协议的领导实现，支持多种场景。淘宝的MySQL集群内部有使用它进行通讯，OpenStack开源云平台的通信组件，最先在金融行业得到运用。

缺点：虽然Erlang是天然集群化的，但RabbitMQ在高可用方面做起来还不是特别得心应手。

##  2、JMS

### 2.1 JMS简介

​	JMS（Java Messaging Service）是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。
​	 **JMS本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。**它类似于 JDBC(java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JML 客户机发送消息。==消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体==。**报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。**

​	JMS同样适用于基于事件的应用程序，如聊天服务，它需要一种发布事件机制向所有与服务器连接的客户端发送消息。==JMS与RMI不同，发送消息的时候，接收者不需要在线。服务器发送了消息，然后就不管了；等到客户端上线的时候，能保证接收到服务器发送的消息。==

​	JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。

- TextMessage--一个字符串对象
- MapMessage--一套名称-值对
- ObjectMessage--一个序列化的 Java 对象，实现了序列化接口
- BytesMessage--一个字节的数据流，声音、图片等等
- StreamMessage -- Java 原始值的数据流

### 2.1 JMS消息传递类型

对于消息的传递有两种类型：

#### 1.点对点的

即一个生产者和一个消费者一一对应，一个队列代表一个消息；![image-20190328095525250](/Users/jack/Desktop/md/images/image-20190328095525250.png)

​	==点对点的模式主要建立在一个队列上面，当连接一个列队的时候，发送端不需要知道接收端是否正在接收，可以直接向ActiveMQ发送消息==，**发送的消息，将会先进入队列中，如果有接收端在监听，则会发向接收端，如果没有接收端接收，则会保存在activemq服务器，直到接收端接收消息，点对点的消息模式可以有多个发送端，多个接收端，但是==一条消息，只会被一个接收端给接收到，哪个接收端先连上ActiveMQ，则会先接收到，而后来的接收端则接收不到那条消息。==**

​	在点对点消息传送模型中，应用程序由消息队列，发送者，接收者组成。每一个消息发送给一个特殊的消息队列，该队列保存了所有发送给它的消息(除了被接收者消费掉的和过期的消息)。点对点消息模型有一些特性，如下：

- **每个消息只有一个接收者；**
- **消息发送者和接收者并没有时间依赖性；**
- 当消息发送者发送消息的时候，无论接收者程序在不在运行，都能获取到消息；
- 当接收者收到消息的时候，会发送确认收到通知（acknowledgement）。

![img](/Users/jack/Desktop/md/images/879896-20160604194640227-215496499.gif)

##### 1.1 使用方法之消息生产者

1) 先引入依赖

```xml
 <dependency>
    <groupId>org.apache.activemq</groupId>
    <artifactId>activemq-client</artifactId>
    <version>5.13.4</version>
 </dependency>
```
2) 创建类QueueProducer ，main方法如下：

```Java
	//1.创建连接工厂, 61616是连接端口
	ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616");
	//2.获取连接,需要抛异常
	Connection connection = connectionFactory.createConnection();
	//3.启动连接
	connection.start();
	//4.获取session  (参数1：是否启动事务,参数2：消息确认模式)
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);		
	//5.创建队列对象(名称自己定义)
	Queue queue = session.createQueue("test-queue");
	//6.创建消息生产者
	MessageProducer producer = session.createProducer(queue);
	//7.创建消息
	TextMessage textMessage = session.createTextMessage("欢迎来到进入乐换");
	//8.发送消息
	producer.send(textMessage);
	//9.关闭资源
	producer.close();
	session.close();
	connection.close();
```

上述代码中第4步创建session  的两个参数：

第1个参数 是否使用事务

第2个参数 消息的确认模式

- AUTO_ACKNOWLEDGE = 1    自动确认
- CLIENT_ACKNOWLEDGE = 2    客户端手动确认   
- DUPS_OK_ACKNOWLEDGE = 3    自动批量确认
- SESSION_TRANSACTED = 0    事务提交并确认

通过ActiveMQ管理界面查询：![image-20190328100634208](/Users/jack/Desktop/md/images/image-20190328100634208.png)

列表各列信息含义如下：

[**Number Of Pending Messages**](http://192.168.25.135:8161/admin/queues.jsp)  **：**等待消费的消息 这个是当前未出队列的数量。

[**Number Of Consumers**](http://192.168.25.135:8161/admin/queues.jsp)  **：**消费者 这个是消费者端的消费者数量

[**Messages Enqueued**](http://192.168.25.135:8161/admin/queues.jsp)  **：**进入队列的消息  进入队列的总数量,包括出队列的。

[**Messages Dequeued**](http://192.168.25.135:8161/admin/queues.jsp)  **：**出了队列的消息  可以理解为是消费这消费掉的数量。

##### 1.2 使用方法之消息消费者

创建类QueueConsumer ，队列名称要跟生产者一样，main方法代码如下：

```Java
	//1.创建连接工厂
	ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616");
	//2.获取连接
	Connection connection = connectionFactory.createConnection();
	//3.启动连接
	connection.start();
	//4.获取session  (参数1：是否启动事务,参数2：消息确认模式)
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	//5.创建队列对象，注意队列名字要跟消息生产者一样
	Queue queue = session.createQueue("test-queue");
	//6.创建消息消费
	MessageConsumer consumer = session.createConsumer(queue);
	
	//7.监听消息,用匿名类的方式创建
	consumer.setMessageListener(new MessageListener() {
		public void onMessage(Message message) {
			TextMessage textMessage=(TextMessage)message;
			try {
				System.out.println("接收到消息："+textMessage.getText());
			} catch (JMSException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	});	
	//8.等待键盘输入
	System.in.read();	
	//9.关闭资源
	consumer.close();
	session.close();
	connection.close();	
```

运行结果：

​		控制台会输出：欢迎来到进入乐换。

​	同时开启2个以上的消费者(运行两次)，再次运行生产者，观察每个消费者控制台的输出，会发现只有一个消费者会接收到消息。

#### 2.发布/ 订阅模式

即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。

发消息的时候没有消费的话就不会被消费，就像广播一样，过了那个时间就收听不了了。

![image-20190328095533792](/Users/jack/Desktop/md/images/image-20190328095533792.png)

​	**在发布/订阅消息模型中，发布者发布一个消息，该消息通过topic传递给所有的客户端。在这种模型中，发布者和订阅者彼此不知道对方，是匿名的且可以动态发布和订阅topic。**topic主要用于保存和传递消息，且会一直保存消息直到消息被传递给客户端。

发布/订阅消息模型特性如下：

- **一个消息可以传递给多个订阅者**
- ==发布者和订阅者有时间依赖性，只有当客户端创建订阅后才能接受消息，且订阅者需一直保持活动状态以接收消息。==
- 为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。

![img](/Users/jack/Desktop/md/images/879896-20160604232610055-1944763982.gif)

##### 2.1 使用方法之消息生产者

创建类TopicProducer ，main方法代码如下：

```Java
//1.创建连接工厂
	ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616");
	//2.获取连接
	Connection connection = connectionFactory.createConnection();
	//3.启动连接
	connection.start();
	//4.获取session  (参数1：是否启动事务,参数2：消息确认模式)
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	//5.创建主题对象
	Topic topic = session.createTopic("test-topic");
	//6.创建消息生产者
	MessageProducer producer = session.createProducer(topic);
	//7.创建消息
	TextMessage textMessage = session.createTextMessage("欢迎进入乐换");
	//8.发送消息
	producer.send(textMessage);
	//9.关闭资源
	producer.close();
	session.close();
	connection.close();
```

运行效果如下：

![image-20190328101805491](/Users/jack/Desktop/md/images/image-20190328101805491.png)

##### 2.2 使用方法之消息消费者

创建类TopicConsumer ,main方法代码如下：

```Java
	//1.创建连接工厂
	ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616");
	//2.获取连接
	Connection connection = connectionFactory.createConnection();
	//3.启动连接
	connection.start();
	//4.获取session  (参数1：是否启动事务,参数2：消息确认模式)
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	//5.创建主题对象
	//Queue queue = session.createQueue("test-queue");
	Topic topic = session.createTopic("test-topic");
	//6.创建消息消费
	MessageConsumer consumer = session.createConsumer(topic);
	
	//7.监听消息
	consumer.setMessageListener(new MessageListener() {
		public void onMessage(Message message) {
			TextMessage textMessage=(TextMessage)message;
			try {
				System.out.println("接收到消息："+textMessage.getText());
			} catch (JMSException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	});
	//8.等待键盘输入
	System.in.read();
	//9.关闭资源
	consumer.close();
	session.close();
	connection.close();	
```

##### 2.3 运行测试

​	先进行消费者，再启动生产者。同时开启2个以上的消费者，再次运行生产者，观察每个消费者控制台的输出，会发现每个消费者会接收到消息。

参照：<https://www.cnblogs.com/chenpi/p/5559349.html>

## 3、短信平台发送短息

1.选好短信平台，按照其开发文档进行配置

2.发短信的方法

```Java
public void createSmsCode(final String phone) {
        //1.生成一个6位随机数（验证码）,后面加空字符串转换成字符串
        final String smsCode = (long) (Math.random() * 1000000) + "";
        System.out.println("验证码：" + smsCode);

        //2.将验证码放入redis，key是手机号码，value是验证码
        redisTemplate.boundHashOps("smsCode").put(phone, smsCode);
        //3.将短信内容发送给activeMQ
        jmsTemplate.send(smsDestination, new MessageCreator() {
            @Override
            public Message createMessage(Session session) throws JMSException {
                MapMessage message = session.createMapMessage();
                message.setString("mobile", phone);//手机号
                message.setString("templateId", templateId);//模板id
                message.setString("uid", uid);//非必填
                //Map map = new HashMap();
                message.setString("param", smsCode + ",1");
                //message.setString("param", JSON.toJSONString(map));
                return message;
            }
        });
    }
```

根据短信平台的不同，可能实现发送方法会有所不同。

## 4、CAS

​	单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。

​	我们目前的系统存在诸多子系统，而这些子系统是分别部署在不同的服务器中，那么**使用传统方式的session是无法解决的，我们需要使用相关的单点登录技术来解决。**

![image-20190330143401067](/Users/jack/Desktop/md/images/image-20190330143401067.png)

​	应用系统相当于web模块，访问应用系统1如果没登录会访问认证系统，认证系统连接到数据库，带着ticket票据做认证。

### 4.1 简介

#### CAS 具有以下特点：

【1】开源的企业级单点登录解决方案。

【2】CAS Server 为需要独立部署的 Web 应用。与solr类似，部署到Tomcat就可以用

【3】CAS Client 支持非常多的客户端(这里指单点登录系统中的各个 Web 应用)，包括 Java, .Net, PHP, Perl, Apache, uPortal, Ruby 等。

​	**从结构上看，CAS 包含两个部分： CAS Server 和 CAS Client。CAS Server 需要独立部署，主要负责对用户的认证工作；CAS Client 负责处理对客户端受保护资源的访问请求，需要登录时，重定向到 CAS Server。**下图是 CAS 最基本的协议过程：![image-20190330145544769](/Users/jack/Desktop/md/images/image-20190330145544769.png)

### 4.2 SSO单点登录访问流程

主要有以下步骤：

1. 访问服务：SSO客户端发送请求访问应用系统提供的服务资源。

2. 定向认证：SSO客户端会重定向用户请求到SSO服务器。

3. 用户认证：用户身份认证,返回到浏览器

4. **发放票据：SSO服务器会产生一个随机的Service Ticket。通过浏览器到客户端；**

5. **验证票据：SSO服务器验证票据Service Ticket的合法性，验证通过后，允许客户端访问服务。**

6. 传输用户信息：SSO服务器验证票据通过后，传输用户认证结果信息给客户端。



注意：

​	CAS默认使用的是HTTPS协议，如果使用HTTPS协议需要SSL安全证书（需向特定的机构申请和购买） 。如果对安全要求不高或是在开发测试阶段，可使用HTTP协议。我们这里讲解通过修改配置，让CAS使用HTTP协议。

## 5、购物车

### 1.实现思路：

​	购物车数据的存储结构如下：

![image-20190331100325081](/Users/jack/Desktop/md/images/image-20190331100325081.png)

​	两个循环list，第一个list表示不同的商家，第二个list表示同个商家下面不同的商品

**当用户在未登录的情况下，将此购物车存入cookies , 在用户登陆的情况下，将购物车数据存入redis  。**如果用户登陆时，cookies中存在购物车，需要将cookies的购物车合并到redis中存储，cookie中的商品清空。

### 2.Cookie存储购物车

#### Service层实现思路：

> ​    //1.根据商品SKU ID查询SKU商品信息
>
> ​	判断商品是否存在，商品状态是否有效
>
> ​    //2.获取商家ID      
> ​    //3.根据商家ID判断购物车列表中是否存在该商家的购物车,因为每个商家的商品都是购物车列表中的一个元素
> ​    //4.如果购物车列表中不存在该商家的购物车
> ​    //4.1 新建购物车对象
> ​    //4.2 将新建的购物车对象添加到购物车列表      
> ​    //5.如果购物车列表中存在该商家的购物车       
> ​    // 查询购物车明细列表中是否存在该商品
> ​    //5.1. 如果没有，新增商品订单明细到购物车     
> ​    //5.2. 如果有，在原购物车明细上添加数量，更改金额

##### 具体实现层代码：

```Java
@Service
public class CartServiceImpl implements CartService {
    @Autowired
    private TbItemMapper itemMapper;
    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * @param cartList 购物车列表
     * @param itemId   商品ID
     * @param num      商品数量
     * @return 购物车列表
     */
    @Override
    public List<Cart> addGoodsToCartList(List<Cart> cartList, Long itemId, Integer num) {
        //1.根据商品SKU ID查询SKU商品信息
        TbItem item = itemMapper.selectByPrimaryKey(itemId);
        if (item == null) {
            throw new RuntimeException("商品不存在");
        }
        if (!("1").equals(item.getStatus())) {
            throw new RuntimeException("商品无效");
        }
        //2.获取商家ID
        String sellerId = item.getSellerId();
        //3.根据商家ID判断购物车列表中，是否存在该商家的购物车
        // 因为每个商家的商品都是购物车列表中的一个列表
        Cart cart = this.searchCartBySellerId(cartList, sellerId);
        //4.如果购物车列表中不存在该商家的购物车
        if (cart == null) {
            //4.1 新建购物车对象
            cart = new Cart();
            // 购物车对象存入商家ID和用户名
            cart.setSellerId(sellerId);
            cart.setSellerName(item.getSeller());
            // 创建订单商品明细列表
            List<TbOrderItem> orderItemList = new ArrayList<>();
            //创建订单商品
            TbOrderItem orderItem = this.createOrderItem(item, num);
            orderItemList.add(orderItem);   // 加入订单列表
            cart.setOrderItemList(orderItemList);   // 添加到购物车，多种列表嵌合
            //4.2 将新建的购物车对象添加到购物车列表
            cartList.add(cart);
        } else {
            //5.如果购物车列表中存在该商家的购物车
            // 查询商品订单明细列表中是否存在该商品
            TbOrderItem orderItem = this.searchOrderItemByItemId(cart.getOrderItemList(), itemId);
            if (orderItem == null) {
                //5.1. 如果商品订单不存在，创建新商品订单
                orderItem = createOrderItem(item, num);
//                存入购物车中的商品订单列表
                cart.getOrderItemList().add(orderItem);
            } else {
                //5.2. 如果商品订单存在，在商品订单明细上添加数量，更改金额
                orderItem.setNum(orderItem.getNum() + num);
                orderItem.setTotalFee(new BigDecimal(orderItem.getPrice().doubleValue() * orderItem.getNum()));
                //如果数量操作后小于等于0，则移除,添加数量可能是负的，数量+-
                if (orderItem.getNum() <= 0) {
                    cart.getOrderItemList().remove(orderItem);
                }
                //如果移除后cart的明细数量为0，则将cart移除
                if (cart.getOrderItemList().size() == 0) {
                    cartList.remove(cart);
                }
            }
        }
        return cartList;
    }

    /**
     * @param username 用户名
     * @return 购物车列表
     */
    @Override
    public List<Cart> findCartListFromRedis(String username) {
        System.out.println("从redis中提取购物车数据....." + username);
        List<Cart> cartList = (List<Cart>) redisTemplate.boundHashOps("cartList").get(username);
        if (cartList == null) {
            cartList = new ArrayList();
        }
        return cartList;
    }

    /**
     * @param username 用户名
     * @param cartList 购物车列表
     */
    @Override
    public void saveCartListToRedis(String username, List<Cart> cartList) {
        System.out.println("向redis存入购物车数据....." + username);
        redisTemplate.boundHashOps("cartList").put(username, cartList);

    }

    /**
     * @param cartList1 购物车列表
     * @param cartList2 购物车列表
     * @return 合并后的购物车列表
     */
    @Override
    public List<Cart> mergeCartList(List<Cart> cartList1, List<Cart> cartList2) {
        System.out.println("合并购物车");
        for (Cart cart : cartList2) {
            for (TbOrderItem orderItem : cart.getOrderItemList()) {
                cartList1 = addGoodsToCartList(cartList1, orderItem.getItemId(), orderItem.getNum());
            }
        }
        return cartList1;
    }

    /**
     * 根据商家ID查询购物车对象,判断是否属于当前商家
     *
     * @param cartList 购物车列表
     * @param sellerId 商家ID
     * @return 返回购物车
     */
    private Cart searchCartBySellerId(List<Cart> cartList, String sellerId) {
        for (Cart cart : cartList) {
//            判断是否属于当前商家，是的话就返回购物车当前这条记录，否则返回null
            if (cart.getSellerId().equals(sellerId)) {
                return cart;
            }
        }
        return null;
    }

    /**
     * 创建订单明细商品
     *
     * @param item 添加的商品
     * @param num  数量
     * @return
     */
    private TbOrderItem createOrderItem(TbItem item, Integer num) {
        if (num <= 0) {
            throw new RuntimeException("数量非法");
        }
//        创建订单明细商品，存入相应的信息
        TbOrderItem orderItem = new TbOrderItem();
        orderItem.setGoodsId(item.getGoodsId());    // 物品ID，即SPUID
        orderItem.setItemId(item.getId());          // 商品ID
        orderItem.setNum(num);
        orderItem.setPicPath(item.getImage());      // 省略图路径
        orderItem.setPrice(item.getPrice());
        orderItem.setSellerId(item.getSellerId());  // 商家ID
        orderItem.setTitle(item.getTitle());
//        商品总价,参数是BigDecimal类型的，先转换为double类型的，再转为BigDecimal
        orderItem.setTotalFee(new BigDecimal(item.getPrice().doubleValue() * num));
        return orderItem;
    }

    /**
     * 根据商品明细ID在订单商品明细列表中查询购物车明细对象
     *
     * @param orderItemList 订单商品列表
     * @param itemId        商品ID
     * @return 订单
     */
    private TbOrderItem searchOrderItemByItemId(List<TbOrderItem> orderItemList, Long itemId) {
        for (TbOrderItem orderItem : orderItemList) {
            // Long类型不能用==，要转成long比较值
            if (orderItem.getItemId().longValue() == itemId.longValue()) {
                return orderItem;
            }
        }
        return null;
    }
}
```

#### controller层实现思路：

（1）从cookie中取出购物车

（2）向购物车添加商品

（3）将购物车存入cookie

##### 具体代码：

```java
@RestController
@RequestMapping("/cart")
public class CartController {
    @Reference(timeout = 6000)
    private CartService cartService;
    @Autowired
    private HttpServletRequest request;
    @Autowired
    private HttpServletResponse response;

    /**
     * 购物车列表，通过cookie获取
     * @return 购物车列表
     */
    @RequestMapping("/findCartList")
    public List<Cart> findCartList() {
        //得到登陆人账号,判断当前是否有人登陆
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        System.out.println("当前登录人" + username);
        //读取本地购物车,即从cookie中提取购物车列表,String类型的购物车列表
        String cartListString = CookieUtil.getCookieValue(request, "cartList", "UTF-8");
//        本地购物车列表为空
        if (cartListString == null || cartListString.equals("")) {
            cartListString = "[]";  // 用空的中括号，防止下面转换报错
        }
//      转换为Json数组/列表
        List<Cart> cartList_cookie = JSON.parseArray(cartListString, Cart.class);
        if ("anonymousUser".equals(username)) {  //如果未登录,anonymousUser表示匿名认证对象
            return cartList_cookie;
        } else {     //如果已登录
            List<Cart> cartList_redis = cartService.findCartListFromRedis(username);  //从redis中提取
            //如果本地存在购物车
            if (cartList_cookie.size() > 0) {
                //合并购物车
                cartList_redis = cartService.mergeCartList(cartList_redis, cartList_cookie);
                //清除本地cookie的数据
                CookieUtil.deleteCookie(request, response, "cartList");
                //将合并后的数据存入redis
                cartService.saveCartListToRedis(username, cartList_redis);
            }
            return cartList_redis;
        }
    }

    /**
     * 添加商品到购物车
     * @param itemId      商品ID
     * @param num         商品数量
     * @return            添加结果
     */
    @RequestMapping("/addGoodsToCartList")
    @CrossOrigin(origins = "http://localhost:9105", allowCredentials = "true")
    public Result addGoodsToCartList(Long itemId, Integer num) {
        //跨域请求，springMVC4.2后跨域用上面的注解
//        response.setHeader("Access-Control-Allow-Origin", "http://localhost:9105");
//        response.setHeader("Access-Control-Allow-Credentials", "true");
        //得到登陆人账号,判断当前是否有人登陆
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        System.out.println("当前登录人" + username);
        try {
            //获取购物车列表
            List<Cart> cartList = findCartList();
            // 添加到购物车列表
            cartList = cartService.addGoodsToCartList(cartList, itemId, num);
            if ("anonymousUser".equals(username)) { // 未登录，存入cookie
                //将新的购物车存入cookie
                String cartListString = JSON.toJSONString(cartList);
                CookieUtil.setCookie(request, response, "cartList", cartListString, 3600 * 24, "UTF-8");
                System.out.println("向cookie存入数据");
            } else {    // 已登录，存入redis
                cartService.saveCartListToRedis(username, cartList);
                System.out.println("向Redis中存入数据");
            }
            return new Result(true, "存入购物车成功");
        } catch (RuntimeException e) {
            return new Result(false, e.getMessage());
        } catch (Exception e) {
            e.printStackTrace();
            return new Result(false, "存入购物车失败");
        }

    }
}
```

### 3.Redis存储购物车

如果用户未登录，则先存入cookie，如果已登录，存入redis

### 4.合并购物车

​	==不能简单地两个集合相加，要遍历循环，然后调用添加到购物车的方法，那个方法会过滤重复的商品，即判断购物车中是否存在==。

具体参照上面的具体代码

## 6、JS跨域处理

​	这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。==只要协议、域名、端口有任何一个不同，都被当作是不同的域。==

$http服务无法实现跨域处理。

### 使用CROS解决跨域问题

​	CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

​	**它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。**==整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。==**因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。**

请求过程如下图:

![image-20190331143837575](/Users/jack/Desktop/md/images/image-20190331143837575.png)

预请求和预响应，先询问是否为跨域请求

Preflight Request：

![image-20190331143954341](/Users/jack/Desktop/md/images/image-20190331143954341.png)

然后服务器端给我们返回一个Preflight Response

![image-20190331144017225](/Users/jack/Desktop/md/images/image-20190331144017225.png)

```Java
response.setHeader("Access-Control-Allow-Origin", "http://localhost:9105"); //可以访问的域(此方法不允许操作cookie，如果需要操作cookie，需要加上下面的那句话)
response.setHeader("Access-Control-Allow-Credentials", "true");//允许操作cookie，如果操作cookie，上面那句话的ip地址不能用*
```

**Access-Control-Allow-Origin**

Access-Control-Allow-Origin是**HTML5**中定义的一种解决资源跨域的策略。

他是通过服务器端返回带有Access-Control-Allow-Origin标识的Response header，用来解决资源的跨域权限问题。

 使用方法，在response添加 Access-Control-Allow-Origin，例如

   Access-Control-Allow-Origin:www.google.com   

也可以设置为   \*   表示该资源谁都可以用

```js
//添加商品到购物车
$scope.addToCart=function(){
	$http.get('http://localhost:9107/cart/addGoodsToCartList.do?itemId='
	+ $scope.sku.id +'&num='+$scope.num,{'withCredentials':true}).success(
			function(response){
				.......				 
			}				
	);		
}
```

​	CORS请求默认不发送Cookie和HTTP认证信息。跨域cookie操作中，如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开**withCredentials**属性。否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。

**springMVC的版本在4.2或以上版本，可以使用注解实现跨域, 我们只需要在需要跨域的方法上添加注解@CrossOrigin即可**，在cartcontroller的addCart上面

   @CrossOrigin(origins="http://localhost:9105",allowCredentials="true")   

allowCredentials="true"  可以缺省

## 7、订单表的设计

​	因为订单表信息比较多，所以考虑拆分为两个表，**Tb_order为订单主表，一个商家一个订单记录，针对商家拆分;Tb_order_item为订单从表，这里每个商品就是一个id，主要是商品SPU相关信息 。**

购物车列表是就一个商家为一条购物车列表中的记录，然后这个商家里面有多个商品信息。

点击结算页的提交订单 ，将购物车保存到订单表和订单明细表中，并将购物车数据清除.

![image-20190331153421732](/Users/jack/Desktop/md/images/image-20190331153421732.png)

**order_id不用自增,自增可能会导致id重复，所以用分布式ID生成器**

![image-20190331153556274](/Users/jack/Desktop/md/images/image-20190331153556274.png)

## 8、分布式ID生成器

分布式ID生成解决方案：

1. UUID：会生成全球唯一的ID号，但太长；无法排序，本身就是乱序的

2. Redis：产生自增的序号，可以调用Redis获取顺序号，但是主键的生成需要访问Redis，对Redis依赖太大。

3. Oracle：数据库对象—序列(与表无关，产生连续号)，只有数据库是oracle才可以用

4. 实现ID生成算法，保证ID不重复

![image-20190331154941809](/Users/jack/Desktop/md/images/image-20190331154941809.png)

​	64位二进制存储结构，**第一位不用，2到41作为时间戳，精确到毫秒，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，在分布式环境下，要考虑到集群，所以需要区分服务器）12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。**

其中，数据中心ID：0-31；机器ID：0-31，最终组合：32*32=1024个值要保证数据中心ID和机器ID的值不同

























