# 一、消息中间件

​	消息 (Message) 是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、JSON 等，也可以很复杂，比如内嵌对象。

​	消息队列中间件 (Message Queue Middleware，简称为 MQ) 是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。

​	消息队列中间件，也可以称为消息队列或者消息中间件。它一般有两种传递模式:点对点(P2P, Point-to-Point) 模式和发布/订阅 (Pub/Sub) 模式。

- 点对点模式是基于队列的，消息生产者 发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的异步传输成为可能。
- 发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题 (topic)，**主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中 订阅消息。**主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消 息的传递，发布/订阅模式在消息的一对多广播时采用 。

​	消息中间件适用于需要可靠的数据传送的分布式环境 。 采用消息中间件的系统中，不同的对象之间通过传递消息来激活对方的事件，以完成相应的操作 。 发送者将消息发送给消息服务器， 消 息服务器将消息存放在若干队列中，在合适的时候再将消息转发给接收者 。 

## 作用

- 解耦：消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独 立地扩展或修改两边的处理过程，只要确保它 们遵守同样的接口约束即可 。
- 冗余〈存储) : 有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直 到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息己经被处理完成，从而确保你的数据被安全地保 存直到你使用完毕。
- 扩展性: 因为消息中间件解捐了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。
- 削峰:  使用消息中间件能够使关 键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩惯 。
- 可恢复性: 当系统一部分组件失效时，不会影响到整个系统 。 消息中间件降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理 。
- 顺序保证: 在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程 度上的顺序性。
- 缓冲: 在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过 一个缓 冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速 。 该缓冲层有助于控制 和优化数据流经过系统的速度。
- 异步通信: 在很多时候应用不想也不需要立即处理消息 。消息中间件提供了异步处理机制， 允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理 。

# 二、简介

​	RabbitMQ是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间传递数据，RabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基于AMQP协议的。

## 特点：

1. RabbitMQ底层使用Erlang语言编写，传递效率高，延迟低
2. 开源、性能优秀、稳定性较高
3. 与SpringAMQP完美的整合、API丰富
4. 集群模式丰富、表达式配置、HA模式、镜像队列模式
5. 保证数据不丢失的情况下，做到高可用
6. AMQP全称：Advanced Message Queuing Protocol(Spring为RabbitMQ设计的一套框架)
7. AMQP翻译:高级消息队列协议

## RabbitMQ整体架构

![img_0918](/Users/jack/Desktop/md/images/img_0918.png)

​	先从客户端生产者发送消息到exchange上，然后再路由到对应的queue中，消费者只要监听对应的queue即可接收到消息。

## AMQP核心概念

- Producer: 生产者，就是投递消息的 一方。

  > ​	生产者创建消息，然后发布到 RabbitMQ 中。消息一般可以包含 2 个部分:**消息体和标签(Label)。消息体也可以称之为 payload，在实际应用中，消 息体一般是一个带有业务逻辑结构 的数据，比如一个 JSON 字符串。当然可以进一步对这个消息体进行序列化操作。**消息的标签用来表述这条消息 ， 比如 一个交换器的名称和 一个路由键 。 生产者把消息交由 RabbitMQ，RabbitMQ 之后会根据标签把消息发送给感兴趣 的消费者(Consumer)。

- Consumer: 消费者 ， 就是接收消息的 一方。

  > 消费者连接到 RabbitMQ 服务器，并订阅到队列上 。 ==当消费者消费 一 条消息时 ， 只是消费 消息的消息体(payload)。 在消息路由的过程中 ， 消息的标签会丢弃 ， 存入到队列中的消息只有消息体，消费者也只会消费到消息体 ， 也就不知道消息的生产者是谁。==

- Broker：即server，接收客户端的连接，实现AMQP实体服务

  > 对于 RabbitMQ来说， 一个 RabbitMQBroker可以简单地看作一个 RabbitMQ服务节点，或者RabbitMQ服务实例。 **大多数情况下也可以将一个 RabbitMQ Broker看作一台 RabbitMQ服务器 。**

- Connection：连接，应用程序与Broker的网络连接

- Channel：网络信道，**几乎所有的操作都在Channel中进行，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。**Channel是进行消息读写的通道。客户端可以建立多个Channel，每个Channel代表一个会话任务。

- Message：消息，服务器和应用程序之间传送的数据，由Properties和Body组成。

  > Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。

- Virtual host：**虚拟地址，用于进行逻辑隔离，最上层的消息路由**。一个Virtual host可以有若干个Exchange和Queue，==同一个Virtual host里面不能有相同名称的Exchange和Queue。==

- Exchange：交换机，接收消息，根据路由键转发消息到绑定的队列。

> RabbitMQ中有三种常用的交换机类型:
>
> - direct: 如果路由键匹配，消息就投递到对应的队列
> - fanout：投递消息给所有绑定在当前交换机上面的队列
> - topic：允许实现有趣的消息通信场景，使得5不同源头的消息能够达到同一个队列。topic队列名称有两个特殊的关键字。

- Binding：Exchange和Queue之间的虚拟连接，binding中可以包含routing key。

- Routing key：一个路由规则，虚拟机可用它来确定如何路由一个特定消息

  > \* 可以替换一个单词
  > \# 可以替换多个单词

- Queue：也称为Message Queue，消息队列，保存消息并将它们转发给消费者，多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。

- Prefetch count：如果有多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者。这时如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发送一条消息。

## 消息流转图

![image](/Users/jack/Desktop/md/images/RabbitMQ1.jpg)

## 消息队列的运转过程

![image-20190924235159050](/Users/jack/Desktop/md/images/image-20190924235159050.png)

​	**==首先生产者将业务方数据进行可能的包装 ， 之后封装成消息 ， 发送 (AMQP 协议里这个动作对应的命令为 Basic . Publish) 到 Broker 中 。 消费者订阅并接收消息 CAMQP 协议里这个动作对应的命令为 Basic.Consume或者 Basic.Get)，经过可能的解包处理得到原始的数据， 之后再进行业务处理逻辑。这个业务处理逻辑并不一定需要和接收消息的逻辑使用同一个线程。消费者进程可以使用一个线程去接收消息，存入到内存中，比如使用 Java 中的 Blocki呵 Queue。业务处理逻辑使用另 一个线程从内存中读取数据，这样可以将应用进一步解稿，提高整个应用的处理效率。==**

# 三、RabbitMQ整合SpringBoot2.x,消息可靠性传递方案100%的实现

![image-20190924223158753](/Users/jack/Desktop/md/images/image-20190924223158753.png)

共分为七步：

1. 先将消息和业务数据分别存入数据库；
2. 将消息通过sender发送到MQ Broker；
3. Listener等待broker的confirm；
4. 等收到确认时，将状态值从0更改为1，表示消息发送成功，然后更新数据库；
5. 由于网络或者消息发送失败等原因，无法更新状态值；
6. 通过定时任务获取超时消息，即状态值为0的消息，重新发送消息(MQ Broker没发生故障的情况下)；
7. 设置重新尝试发送次数为3，当超过3次时，设置状态为2，表示需要人工处理。

























## RPC和MQ各自适合的应用场景

RPC比较适合- 客户端调用哪个服务器比较明确

> 调用需要立即得到返回结果
> 架构简单 在一个由多个微服务构成的大系统中，某些关键服务间的调用应当在较短的时间内返回，而且各个微服务的专业化程度较高，同一个请求的关注者只有一个。这个时候就应该用RPC。 比如在一个ERP系统中，有一个管理仓储的微服务，以及一个负责订单的微服务。新建订单时需要查知当前的存货是否充足，如果不充足就通知用户；提交订单时预订指定数量的货物，如果此时货物不错，也要终止订单的提交，并通知用户。显然在这种场景下是不允许较大的延迟，否则会影响用户体验。所以应该使用RPC，及时返回仓储情况。

MQ比较适合

> 消息的发送者和消费者需要解耦的情况
> 发送者并不明确谁是消费者
> 发送者并不关心谁来消费消息
> 各个消费者可以从不同的角度入手处理消息
> 消费者的处理结果也不返回给发送者
> 消息的发送和处理是异步的
> 消息的关注者不止一个
> 在一个由多个微服务构成的大系统中，会有一些非关键服务，用来执行一些不需要立刻得到结果的计算。而且它们的计算结果并不会返回给消息的发送者。这个时候就应该使用MQ。







参照：https://github.com/suxiongwei/springboot-rabbitmq

[RabbitMQ消息中间件极速入门与实战](https://www.imooc.com/learn/1042)

朱忠华的《RabbitMQ实战指南》