# 玩转数据结构

# 一、数组

​	数组优点：快速查询；数组最好用于“索引有语义”的情况；但并非所有有语义的索引都适用于数组；例： 身份证号就不适合，占用空间太大；数组也可以处理 “索引没有语义 ”的情况。

## 1 整型数组

​	**Java 自身的数组是静态数组，不具有对内存空间增、删、改、查功能；故二次分装自己的内存，为动态数组。**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123203028943.png)

自己的数组类： Array

data:数组名称

size:数组中实际装入元素的长度

capacity:数组定义的长度（容量）

代码如下：

```java
public class OurOwnArray {
    private int[] data;     //定义int 型数组 data
    private int size;       //data数组中有效元素的数量

    /**
     * @param capacity 数组的容量
     */
    // 构造函数，传入数组的容量capacity构造Array，数组容量与size无关
    //数组容量没有必要单独定义一个变量，只要声明函数的时候传入即可
    public OurOwnArray(int capacity) {
        data = new int[capacity];
        size = 0;
    }

    // 无参数的构造函数，默认数组的容量capacity=10
    public OurOwnArray() {
        this(10);
    }

    // 获取数组的容量
    public int getCapacity() {
        return data.length;
    }

    // 获取数组中的元素个数
    public int getSize() {
        return size;
    }

    // 返回数组是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    // 向所有元素后添加一个新元素
    public void addLast(int e) {
        //data[size++]=e    相当于下面两句
//        data[size] = e;
//        size++;
        add(size, e);
    }

    // 在所有元素前添加一个新元素
    public void addFirst(int e) {
        add(0, e);
    }

    // 在index索引的位置插入一个新元素e
    public void add(int index, int e) {
        if (size == data.length) {
            throw new IllegalArgumentException("out of capacity");
        }
        //索引不合格,这里index可以等于size，刚开始都是0
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("index illegal");
        }
        for (int i = size - 1; i >= index; i--) {
            data[i + 1] = data[i];  //从插入的位置开始，数组后移，后面的值覆盖前面的值
        }
        data[index] = e;       //覆盖原来的值
        size++;
    }

    // 获取index索引位置的元素
    public int get(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        return data[index];
    }

    // 修改index索引位置的元素为e
    public void set(int index, int e) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        data[index] = e;
    }

    // 查找数组中是否有元素e
    public boolean contains(int e) {
        for (int i = 0; i < size; i++) {
            if (data[i] == e) {
                return true;
            }
        }
        return false;
    }

    // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1,只能查找到一个元素e
    public int find(int e) {
        for (int i = 0; i < size; i++) {
            if (data[i] == e) {
                return i;
            }
        }
        return -1;
    }

    // 从数组中删除index位置的元素, 返回删除的元素,与插入相反
    public int delete(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        int temp = data[index];     //返回删除的元素
        for (int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];      //从删除的索引开始，插入的索引后面，数组左移
        }
        size--;
        return temp;
    }

    public int delFirst() {
        return delete(0);
    }

    public int delLast() {
        return delete(size - 1);
    }

    // 从数组中删除元素e,只删除一个元素e
    public void delElement(int e) {
        int index = find(e);
        if (index != -1) {  //数组中有这个元素
            delete(index);
        }
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format("Array：size=%d,capacity=%d\n", size, data.length));
        res.append('[');
        for (int i = 0; i < size; i++) {
            res.append(data[i]);
            if (i != size - 1) {
                res.append(", ");
            }
        }
        res.append(']');
        return res.toString();
    }
}
```

## 2 泛型数组

​	泛型：使数据结构可以放置所有的“数据类型”；**但只能放置类对象，不能是基本数据类型**（boolean、byte、char、short、int、long、float、double），为了解决这个问题，Java 中每个基本数据类型都有对应的包装类（将本来不是类对象的变成了类对象）；

​	**基本数据类型对应的包装类[Boolean、Byte、Char、Short、Int、Long、Float、Double ]  二者之间可以互相转换。**

```java
//泛型数组，E为类对象，所有判断元素相等的时候要用equal方法
public class TOurOwnArray<E>{
    private E[] data;
    ...
    // 构造函数，传入数组的容量capacity构造Array，数组容量与size无关
    //数组容量没有必要单独定义一个变量，只要声明函数的时候传入即可
    public TOurOwnArray(int capacity) {
        //java 中不支持直接new出泛型数组
        // 需要通过object创建一个数组，然后再转换为E[]
        data = (E[]) new Object[capacity];
        size = 0;
    }
    ...
    //将上面的数组int改为E类型就可以了
    // 从数组中删除index位置的元素, 返回删除的元素,与插入相反
    public E delete(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        E temp = data[index];     //返回删除的元素
        for (int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];      //从删除的索引开始，插入的索引后面，数组左移
        }
        size--;
        data[size] = null; // loitering objects != memory leak 使数组最后引用中的值被垃圾回收
        return temp;
    }
    ...
}
```

## 3动态数组

​	动态数组是为了解决数组空间不够用的情况，**Java 中的静态数组，当插入的值数量 > 数组的size 时就会报错，使用动态数组可以解决这个问题，**

​	**设置动态数组的思路**：再建立一个新的数组newData，它要比之前的数组空间大一些；将data 中的数据放入到 newData 中，**循环遍历数组data中所有的元素，将他们依次赋值到 newData 中；**	

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230804821.png)

**==想让 newData 取代原来的 data ,对数组而言，容量（capacity）已经变为 8 ；size 在newData中还是 4 ，但数组可以装入更多的元素；==**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230853839.png)

​	将数组data的**引用改为指向 新的有8个空间的数组**，与newData的引用相同,指向同样的空间；整个过程封装在函数中，当函数执行完成后，newData 就会失效了；而 data 是整个类的成员变量，和整个类的成员变量是相同的，只要类在使用则data就是有效的；![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230904146.png)

**==之前的4个空间的数组，因为已经没有引用了，垃圾回收器会将其销毁；数组完成扩容==**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230911188.png)

```java
public class DynamicTOurOwnArray<E> {
    private E[] data;     //定义int 型数组 data
    private int size;       //data数组中有效元素的数量

    /**
     * @param capacity 数组的容量
     */
    // 构造函数，传入数组的容量capacity构造Array，数组容量与size无关
    //数组容量没有必要单独定义一个变量，只要声明函数的时候传入即可
    public DynamicTOurOwnArray(int capacity) {
        //java 中不支持直接new出泛型数组
        // 需要通过object创建一个数组，然后再转换为E[]
        data = (E[]) new Object[capacity];
        size = 0;
    }

    // 无参数的构造函数，默认数组的容量capacity=10
    public DynamicTOurOwnArray() {
        this(10);
    }

    // 获取数组的容量
    public int getCapacity() {
        return data.length;
    }

    // 获取数组中的元素个数
    public int getSize() {
        return size;
    }

    // 返回数组是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    // 向所有元素后添加一个新元素
    public void addLast(E e) {
        //data[size++]=e    相当于下面两句
//        data[size] = e;
//        size++;
        add(size, e);
    }

    // 在所有元素前添加一个新元素
    public void addFirst(E e) {
        add(0, e);
    }

    // 在index索引的位置插入一个新元素e
    public void add(int index, E e) {
        //索引不合格,这里index可以等于size，刚开始都是0
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("index illegal");
        }
        if (size == data.length) {
            resize(2 * data.length);    //进行数组扩容，变为原来的2倍
        }
        for (int i = size - 1; i >= index; i--) {
            data[i + 1] = data[i];  //从插入的位置开始，数组后移，后面的值覆盖前面的值
        }
        data[index] = e;       //覆盖原来的值
        size++;
    }

    // 将数组空间的容量变成newCapacity大小（2倍）
    private void resize(int newCapacity) {
        E[] newData = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {       //new 一个新的E型数组newData
            newData[i] = data[i];     //将原来的数组内容放入到新的newData中
        }
        data = newData;       //让 data 指向 newData 的空间
    }

    // 获取index索引位置的元素
    public E get(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        return data[index];
    }

    // 修改index索引位置的元素为e
    public void set(int index, E e) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        data[index] = e;
    }

    // 查找数组中是否有元素e
    public boolean contains(E e) {
        for (int i = 0; i < size; i++) {
            if (data[i].equals(e)) {
                return true;
            }
        }
        return false;
    }

    // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1,只能查找到一个元素e
    public int find(E e) {
        for (int i = 0; i < size; i++) {
            if (data[i].equals(e)) {
                return i;
            }
        }
        return -1;
    }

    // 从数组中删除index位置的元素, 返回删除的元素,与插入相反
    public E delete(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        E temp = data[index];     //返回删除的元素
        for (int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];      //从删除的索引开始，插入的索引后面，数组左移
        }
        size--;
        data[size] = null; // loitering objects != memory leak 使数组最后引用中的值被垃圾回收
        //缩小一半
        if (size == data.length / 2) {
            resize(data.length / 2);
        }
        return temp;
    }

    public E delFirst() {
        return delete(0);
    }

    public E delLast() {
        return delete(size - 1);
    }

    // 从数组中删除元素e,只删除一个元素e
    public void delElement(E e) {
        int index = find(e);
        if (index != -1) {  //数组中有这个元素
            delete(index);
        }
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format("Array：size=%d,capacity=%d\n", size, data.length));
        res.append('[');
        for (int i = 0; i < size; i++) {
            res.append(data[i]);
            if (i != size - 1) {
                res.append(", ");
            }
        }
        res.append(']');
        return res.toString();
    }
}
```

## 4.复杂度分析

时间复杂度分析：例：O(1)、O(n)、O(lgn)、O(nlogn)、O(n^2)

O:描述的是算法的运行时间和输入数据之间的关系

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124131518511.png)

​	上图中：c1指在for 循环中，将nums这个数组里面的元素取出来、将sum这个数取出来、将sum和nums 加在一起、最后将结果扔回给sum变量这些操作花费的总时间；实际中无法具体取得

​	c2指在整个程序中，开辟 Int 型空间 sum，并将0的初始化空间赋值给 sum,在运算结束后，还有返回sum，这些操作花费的总时间；实际中无法具体取得。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132103936.png)

​	前两个忽略常数，都是O(n),虽然第三个的常数值很小，但它还是O(n^2),但并不代表：对于任意输入来说，O(n)都要优于O(n^2)，**O 是渐进时间复杂度**，【描述 n 趋近于无穷的情况来比较算法的性能】；最后一个中，低阶的300n 相比 n^2(高阶)可忽略，故为O(n^2)；

### 1.动态数组的时间复杂度分析

##### 添加操作：通常情况下（按最坏的情况看）是 O(n) 

​	addLast(e) ---O(1)   :该操作所消耗时间与数据规模没有关系，**无论数组中有多少元素，addLast都能在常数时间内完成。**

​	addFirst(e) ---O(n)   :数组头添加元素需要**将数组每个元素向后移动一个单位，故为O(n)。**

​	add(index,e) ---O(n/2)=O(n)  :在数组 index 索引的位置插入元素e，时间复杂度与 index 相关，index = 0时和addFirst(e)相同；index = size时和addLast(e)相同，分析：假设多种情况下的概率相同，运用概率论的知识，求出时间的期望。**平均来看需要右移动 n/2 个元素，O需要忽略常数，故为 O(n)。**

##### 删除操作：通常情况下（==按最坏的情况看==）是 O(n) 

​	removeLast(e) ---O(1) 

​	removeFirst(e) ---O(n) 

​	remove(index,e) --- O(n/2)=O(n)

​	resize  ---O(n)

##### 修改操作：

已知索引：O(1)  **数组最大优势--支持随机访问，只要知道索引就可以马上访问到该数据**

未知索引：O(n)  需要从头遍历数组来找到该元素进行修改

​	**set(index,e) ---O(1)** 

##### 查找操作：需要从头遍历数组来找到该元素

​	get(index) ---O(1)  	知道所要查找元素的索引，立马可以拿到该值

​	contains(e) --- O(n)      不知道所要查找元素的索引，查看数组中是否包含某个元素

​	find(e) ---O(n)        	不知道所要查找元素的索引，查看数组中 e 元素对应的索引是多少

### 2.均摊复杂度和防止复杂度的震荡

**resize 的时间复杂度分析：**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132502059.png)

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132517730.png)

​	不会每次添加元素都会触发resize，	==因为最坏的情况（resize）要在很多次 addLast 操作后才会执行； 运用均摊复杂度比较合适；==

​	假设capacity=n，n+1次addLast，超过数组的容量，所以触发resize，相当于又加了一倍capacity的元素，所以总共进行2n+1次基本操作，平均每次addLast操作，进行2次基本操作。**这样均摊计算，addLast 和 removeLast 的均摊复杂度均为O(1);**

####  复杂度震荡

​	上面的那种所说的是大多数情况下，都不会执行resize,现在认为制造这样的情景，让 addLast 和 removeLast 依次执行多次，**这样就会每次都执行 resize ，addLast 和 removeLast 的时间复杂度均为O(n);从O(1)变为O(n)，产生复杂度震荡。**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132707690.png)

#### 解决复杂度震荡问题：

出现原因：removeLast 时 resize 过于着急,额度过于紧凑，应该减半一些

解决方案：Lazy策略，不急着缩容，设置 resize == capacity/4 时，才将 capacity 减半

图解过程：

1.添加元素超过 size ,容量扩大一倍：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132733516.png)

**2.删除元素后，先不着急缩小数组容量**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132740344.png)

**3.等到数组长度size缩小到数组容量capacity 的1/4 时**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132739989.png)

**4.缩小数组容量，但也只缩小到原来的一半，仍然预留了一半的数组容量供数组进行 addLast 操作**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132740299.png)

##### 代码：

```java
//数组长度size为数组容量1/4时才会缩小数组容量,size可能等于1，所以后面再加个判断
if (size == data.length / 4 && data.length/2 != 0) {
    resize(data.length / 2);
}
```

# 二、栈

​	栈是一种线性数据结构；相比数组，栈对应的操作是数组的子集，因为栈只能从一端添加元素，也只能从同一端取出元素，这一端称为栈顶。

​	向栈中添加元素【入栈】，从栈中取出栈顶元素【出栈】，**栈中的元素是后进先出(LIFO)，由此可知：数组也是一种后进先出的数据结构。**

## 1.栈的应用

### 1.1 无处不在的 Undo (撤销)操作 

例：文档中依次输入 沉迷  学习  不法  ---实际上是将这些元素压入栈中;执行 Undo 操作，--实际是从栈中拿出栈顶元素，通过栈顶元素来确认最近一次的操作是什么；然后将其删除，成功删除（出栈）后

### 1.2 程序调用的系统栈 

例：子过程（子逻辑）的调用在编译器内部的实现机理:![image-20190126114236948](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190126114236948.png)

A2: 程序执行到了A函数的第二行，发生中断去执行函数B

B2：程序执行到了B函数的第二行，发生中断去执行函数C

当都执行完成后，接下来如何执行需要看系统栈了，对当前的栈来说，栈顶元素是B2；故跳到B2处继续执行，然后B2出栈，

接着执行B3完成整个函数B；接下来如何执行需要再看系统栈了，栈顶元素是A2，故跳到A2处继续执行，然后A2出栈，接着执行A3完成整个函数A；接下来如何执行需要再看系统栈，栈中已经没有元素了，表示没有之前中断的程序了，故系统知道已经没有要执行的程序了。

## 2.栈的实现

栈Stack<E>的基本操作：

void push(E)   --- 【入栈】向栈中添加元素              时间复杂度：O(1)

E pop()   ---【出栈】从栈中拿出栈顶元素                 时间复杂度：O(1)

E peek()   ---查看栈顶元素                                        时间复杂度：O(1)

int getSize()  ---查看栈中总共有多少个元素              时间复杂度：O(1)

boolean isEmpty()   ---判断栈是否为空                     时间复杂度：O(1)

##### 实现基于动态数组的栈：

```java
public interface Stack<E> {
    int getSize();        //查看栈中总共有多少个元素

    boolean isEmpty();    //判断栈是否为空

    void push(E e);        //【入栈】向栈中添加元素

    E pop();            //【出栈】从栈中拿出栈顶元素

    E peek();            //查看栈顶元素
}
```

```java
public class ArrayStack<E> implements Stack<E> {
    DynamicTOurOwnArray<E> array;

    /**
     * 构造函数，传入数组的容量capacity构造Array
     * @param capacity
     */
    public ArrayStack(int capacity) {
        array=new DynamicTOurOwnArray<>(capacity);
    }

    public ArrayStack() {
        array=new DynamicTOurOwnArray<>();
    }

    // 获取数组中的元素个数
    @Override
    public int getSize() {
        return array.getSize();
    }

    @Override
    public boolean isEmpty() {
        return array.isEmpty();
    }

    @Override
    public void push(E e) {
        array.addLast(e);
    }

    @Override
    public E pop() {
        return array.delLast();
    }

    @Override
    public E peek() {
        return array.getLast();
    }

    /**
     * 查看静态数组的容量
     * @return  数组容量
     */
    public int getCapacity(){
        return array.getCapacity();
    }

    @Override
    public String toString(){
        StringBuilder res = new StringBuilder();
        res.append("Stack: ");
        res.append('[');
        for(int i = 0 ; i < array.getSize() ; i ++){
            res.append(array.get(i));
            if(i != array.getSize() - 1)
                res.append(", ");
        }
        res.append("] top");   //横向排列，栈顶在数组右侧
        return res.toString();
    }
}
```

## 3.栈的另一个应用--（括号匹配）

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126121608624.png)

思路分析：

​	声明一个栈，然后逐一遍历字符串中的每一个字符，如果这个字符是一个左括号，就将其压入栈中；完成之后，判断右括号是否和栈顶的左括号相匹配，如果匹配成功就可以出栈；直至所有的都匹配成功，这时所有的元素都出栈，栈为空时表明字符串是一个有效的字符串。如果不是有效的字符串，在右括号与左括号相匹配时不能匹配成功，直接停止返回这是一个错误的字符串。

栈顶元素反映了在嵌套的层次关系中，最近的需要匹配的元素。

```java
public class StackSample {
    public boolean isValid(String s) {
        //声明栈stack
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            //获取字符串的第i个元素
            char c = s.charAt(i);
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) {
                    return false;
                }
                //取栈顶元素，与准备入栈的元素进行匹配
                char topChar = stack.pop();
                if (c == ')' && topChar != '(') {
                    return false;
                }
                if (c == ']' && topChar != '[') {
                    return false;
                }
                if (c == '}' && topChar != '{') {
                    return false;
                }
            }
        }
        return stack.isEmpty();     //判断栈是否为空,如果是空的话则匹配成功
    }

    public static void main(String[] args) {

        System.out.println((new StackSample()).isValid("()[]{}"));    //传入测试用例
        System.out.println((new StackSample()).isValid("([)]"));
    }
}
```

# 三、队列

​	队列是一种线性数据结构；相比数组，队列对应的操作也是数组的子集；**只能从一端（队尾）添加元素，只能从另一端（队首）取出元素，队列是先进先出的数据结构（First In First Out [FIFO]）。**

## 1.队列的实现

队列Queue<E>的基本操作：

void enqueue(E)   --- 【入队】向队列中添加元素              时间复杂度：O(1)

E dequeue()   ---【出队】从队列中拿出队首元素               时间复杂度：O(n)【队首后面的所有的元素都要移动一下】

E getFornt()   ---查看队首元素                                      	 时间复杂度：O(1)

int getSize()  ---查看队列中总共有多少个元素             	 时间复杂度：O(1)

boolean isEmpty()   ---判断队列是否为空                     	 时间复杂度：O(1)

```java
public class ArrayQueue<E> implements Queue<E> {
    private DynamicTOurOwnArray<E> array;

    //构造函数，传入数组容量
    public ArrayQueue(int capacity) {
        array = new DynamicTOurOwnArray<>(capacity);
    }

    public ArrayQueue() {
        array = new DynamicTOurOwnArray<>();
    }

    @Override
    public int getSize() {
        return array.getSize();
    }

    @Override
    public boolean isEmpty() {
        return array.isEmpty();
    }

    //新增元素,从队尾进，队头出
    @Override
    public void enqueue(E e) {
        array.addLast(e);
    }

    //查看静态数组容量
    public int getCapacity() {
        return array.getCapacity();
    }

    //取出队列头部元素
    @Override
    public E dequeue() {
        return array.delFirst();
    }

    //查看队首元素
    @Override
    public E getFront() {
        return array.getFirst();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append("Queue: ");
        res.append("front [");    //数组左侧是队首
        for (int i = 0; i < array.getSize(); i++) {
            res.append(array.get(i));    //将队列的每个元素都放到 res 中
            if (i != array.getSize() - 1)    //如果 i 不是array 的最后一个元素
                res.append(", ");
        }
        res.append("] tail");    //数组右侧是队尾
        return res.toString();
    }

    public static void main(String[] args) {
        ArrayQueue<Integer> queue = new ArrayQueue<>();
        for(int i = 0 ; i < 10 ; i ++){
            queue.enqueue(i);     //添加元素
            System.out.println("添加元素后的队列："+queue);
            if(i % 3 == 2){
                queue.dequeue();
                System.out.println("取出元素后的队列："+queue); //取出元素
            }
        }
    }
}
```

## 2.数组队列的问题

​	**删除队首元素（左侧队首）**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164156065.png)

​	**a 移除队列，后面的移动一个单位，size -1;得图**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164202334.png)

​	**但==如果 a移除队列后，后面的不移动，记录目前的队首位置为 front，队尾为 tail,只要维护 front 的指向即可（front++）,不需要所有的元素移动一个单位，即可得到循环队列==这种实现方式。**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164202375.png)

## 3.循环队列

​	**front == tail 		 -----		 队列为空时【起始状态如下图所示】**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164214658.png)

​	**队列进入5个元素后【front不变，tail 右移即可（tail++)】**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164240890.png)

​	**将 a 移除队列，【tail不变，front 右移即可（front++)】其余元素不必移动**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164245218.png)

​	继续加入元素到队列中，==**装满后面的空间，前面还有空着的空间，tail 就会移动到前面 0 的位置【环形结构】**==

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164252747.png)

​	**（tail+1）%capacity == front	 ---	队列满时 ，效果如图【capacity 中有意识的浪费一个空间,capacity为数组的长度：data.length】**

​	队满的时候，front和tail只相差一个元素，所以tail+1其实就是等于front。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126164258464.png)

队列Queue<E>的基本操作：

void enqueue(E)   --- 【入队】向队列中添加元素              时间复杂度：O(1)【均摊】

E dequeue()   ---【出队】从队列中拿出队首元素           时间复杂度：O(1)【均摊】

E getFornt()   ---查看队首元素                                        时间复杂度：O(1)

int getSize()  ---查看队列中总共有多少个元素              时间复杂度：O(1)

boolean isEmpty()   ---判断队列是否为空                     时间复杂度：O(1)

#### 循环队列的实现：

```java
public class LoopQueue<E> implements Queue<E> {
    private E[] data;
    private int front;
    private int tail;
    private int size;           //元素个数

    //定义数组容积capacity
    public LoopQueue(int capacity) {
        //循环数组中有意识的浪费一个空间,所以这里要+1，相应的getCapacity方法那里要-1
        data = (E[]) new Object[capacity + 1];
        front = 0;
        tail = 0;
        size = 0;
    }

    public LoopQueue() {
        this(10);
    }

    //循环队列中最多装载的元素数量，要注意有一个空间要浪费的，即队头和队尾最多缺少一个元素的距离
    public int getCapacity() {
        return data.length - 1;
    }

    @Override
    public boolean isEmpty() {
        return front == tail;
    }

    @Override
    public int getSize() {
        return size;
    }

    //循环队列入队,front不变，tail+1，因为是循环队列，所以要跟data.length取余
    @Override
    public void enqueue(E e) {

        if ((tail + 1) % data.length == front) {   //判断队列是否“满”，队满则扩容
            resize(getCapacity() * 2);        //队列扩容,循环队列最多存放的元素的2倍
        }
        data[tail] = e;
        tail = (tail + 1) % data.length;
        size++;
    }

    private void resize(int newCapacity) {
        //因为浪费一个空间，所以要加一
        E[] newData = (E[]) new Object[newCapacity + 1];
//        遍历方式一，toString中是另一种便利方式
        for (int i = 0; i < size; i++) {
            //将data中的size个元素放到了newData中的[0，size-1]的位置
            newData[i] = data[(i + front) % data.length];
        }
        data = newData;
        front = 0;
        tail = size;
    }

    //循环队列出队，tail不变，front+1，因为是循环队列，所以要跟data.length取余
    @Override
    public E dequeue() {
        if (isEmpty()) {
            throw new IllegalArgumentException("queue is empty");
        }
        E ret = data[front];
        data[front] = null;     //清空队首
        front = (front + 1) % data.length;
        size--;
        if (size == getCapacity() / 4 && getCapacity() / 2 != 0) {
            resize(getCapacity() / 2);
        }
        return ret;
    }

    //取得队首元素
    @Override
    public E getFront(){
        if(isEmpty())
            throw new IllegalArgumentException("Queue is empty.");
        return data[front];
    }

    @Override
    public String toString(){		//打印输出

        StringBuilder res = new StringBuilder();
        res.append(String.format("LoopQueue: size = %d , capacity = %d\n", size, getCapacity()));
        res.append("front [");		//队列左侧是队首
        //循环地+1，所以要(i + 1) % data.length；第二种遍历方式，resize里面是另一种遍历方式
        for(int i = front ; i != tail ; i = (i + 1) % data.length){
            res.append(data[i]);
            if((i + 1) % data.length != tail)	//判断当前索引不是最后一个元素，既不是队尾
                res.append(", ");
        }
        res.append("] tail");		//队列右侧是队尾
        return res.toString();
    }

    public static void main(String[] args){

        LoopQueue<Integer> queue = new LoopQueue<>();	//添加测试用例
        for(int i = 0 ; i < 10 ; i ++){
            queue.enqueue(i);		//将0-9这10个数字存放到 queue 中
            System.out.println(queue);

            if(i % 3 == 2){
                queue.dequeue();	//每隔三个数字执行出队操作
                System.out.println(queue);
            }
        }
    }
}
```

## 4.数组队列和循环队列的比较（执行效率）

代码：

```java
public class TestQueue {
    /**
     * 测试使用q运行opCount个enqueue和dequeue操作所需要的时间
     *
     * @param queue   测试的队列
     * @param opCount 队列个数
     * @return 花费的时间
     */
    private static double testQueue(Queue<Integer> queue, int opCount) {
        long startTime = System.nanoTime();
        Random random = new Random();
        for (int i = 0; i < opCount; i++) {
            queue.enqueue(random.nextInt(Integer.MAX_VALUE));
        }
        for (int i = 0; i < opCount; i++) {
            queue.dequeue();
        }
        long endTime = System.nanoTime();

        return (endTime - startTime) / 1000000000.0;
    }

    public static void main(String[] args) {
        //操作数量
        int opCount = 100000;
        ArrayQueue<Integer> arrayQueue = new ArrayQueue<>();
        double time1 = testQueue(arrayQueue, opCount);
        System.out.println("ArrayQueue, time: " + time1 + " s");
        LoopQueue<Integer> loopQueue = new LoopQueue<>();        //循环队列输出时间
        double time2 = testQueue(loopQueue, opCount);
        System.out.println("LoopQueue, time: " + time2 + " s");
    }
}
```

数组队列执行10万个队列入队出队所需的时间远远大于循环队列所需的时间

​	==主要的差距在出队的过程中==，**数组队列每一次出队后面所有的元素都要向前挪动一个位置，时间复杂度为O(n),则对于testQueue来说是O(n2);循环队列 则无需挪动位置，时间复杂度为O(n),对于testQueue来说是O(n).**

# 四、链表(Linked List)

## 1.基本概念

==链表：最简单的动态数据结构==

重要性：更深入的理解引用和递归，辅助组成其他数据结构

**优点：真正的动态，不需要处理固定的容量**

**缺点：丧失了随机访问的能力**

与数组对比：数组最好用于索引有语义的情况(例 score[2])，其最大的有点是支持快速查询；链表不适合用于索引有语义的情况，最大优点是动态

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185242865.png)

### 链表的结构：

图解：数据存储在 “节点”（Node）中，实际存储在E  e 中，数据与数据之间的链接(对下一个链表的引用)由 next 完成；==最后一个节点 next 存储的为 Null；如果为Null则证明是最后一个节点。==

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185258131.png)

### ![image-20190127162624478](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190127162624478.png)

### 数组和链表的比较：

![image-20190127162846543](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190127162846543.png)

```java
public class LinkedList<E> {
    //声明Node类，只有链表内才能访问
    private class Node {
        //声明成员变量E类型的e，存放元素
        public E e;
        public Node next;

        //声明构造函数，用户也同时传来 e 和 next
        public Node(E e, Node next) {
            this.e = e;     //将当前节点的e赋值成用户传来的e
            this.next = next;       //将当前节点的next赋值成用户传来的next
        }

        public Node(E e) {            //用户只传来e
            this(e, null);            //将当前节点的e赋值成用户传来的e，next设为null
        }

        public Node() {                //用户什么都不传
            this(null, null);        //将e和next都设为null
        }

        @Override
        public String toString() {        //打印输出
            return e.toString();
        }
    }
}
```

## 2.在链表中添加元素

​	对于一个链表来说，想要访问存储在其中的所有节点，**我们必须把链表的头 head 存储起来**， 

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185339056.png)

### ==在链表头添加元素==:

​	图解（要将 666【即node类对象实例】 加入链表中而不破坏现有的链表结构）

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185401900.png)

步骤：1.让 node 的 next 指向现在链表的头，即执行  node.next = head

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185432984.png)

​	2. 此时，**666 成为新的链表头，让 head  指向新的 666 节点，即执行  head = node**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185449693.png)

```java
private Node head;       //声明Node型变量head
    private int size;       //不能外部修改，记录链表中有多少个元素

    public LinkedList() {
        head = null;
        size = 0;
    }

    // 获取链表中的元素个数
    public int getSize() {
        return size;
    }

    //判断链表是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    // 在链表头添加新的元素e
    public void addFirst(E e) {
//        Node node = new Node(e);
//        node.next = head;
//        head = node;
        //等同于上面的三句代码,将当前节点的e赋值成用户传来的e，然后将当前节点的next赋值成用户传来的next
        head = new Node(e, head);
        size++;
    }
```

### ==在链表中间添加元素:==

图解：将 666 插入到链表中 1 的位置

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185505584.png)

步骤：1.要插入节点 666 ，必须要找到插入666之后，这个节点之前的节点是谁，将其叫做 prev，其初始化和 head 在同一个地方,执行 Node prev = head;    

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185517225.png)

步骤2：要找到 666 之前节点 ，因为插入 666 的索引为2【链表中并没有索引这个概念】故之前节点的索引为 1 ，从0开始遍历，遍历到索引为1的位置即可；

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185531535.png)

步骤3：将 node 的 next 指向 prev 的下一个元素，即执行 node.next = prev.next

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185539887.png)

步骤4：prev 的 next 指向 node, 即执行 node.next = prev.next,成功将 666 插入到链表中

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185550481.png)

==关键：找到要添加的节点的前一个节点（prev）==

代码：

```java
// 在链表的index(0-based)位置添加新的元素e
    public void add(int index, E e) {
        //判断 index 的合法性
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("index is invalid");
        }
        if (index == 0) {
            addFirst(e);
        } else {
            Node prev = head;
            //把当前 prev 存的下一个节点放到 prev 变量中，prev会在链表中一直移动，
            // 直到 index - 1 这个位置,即index前一个节点
            for (int i = 0; i < index - 1; i++) {
                prev = prev.next;
            }
//            Node node=new Node(e);    //创建node,元素为 e
//            node.next = prev.next;   //将 node 的 next 指向 prev 的下一个元素
//            prev.next = node;          //prev 的 next 指向 node
            prev.next = new Node(e, prev.next);     //相当于上面三行代码
            size++;
        }
    }
```

## 3.使用链表的虚拟头结点

​	上面所述的方法中在链表头添加元素时存在特殊：**为链表添加元素的过程要找到待添加位之前的节点，但对于链表头来说并没有之前的节点，所以在逻辑上特殊。**通过使用链表的虚拟头节点即可将链表头添加元素与其他位置添加元素统一起来。

图解：==创建个虚拟节点即可解决链表头添加元素时的问题==，对链表来说，**第一个元素是 dummyHead 的 next 对应的节点的元素，而不是 dummyHead 对应的节点的元素，dummyHead 这个位置的元素是根本不存在的，对用户来说也没有意义，只是为了逻辑编写方便设置的虚拟头结点。**这样所有的元素都有前一个位置的节点，并且初始的时候 dummyHead 指向的就是 0 这个元素的前一个节点。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190126185652189.png)

## 4.从链表中删除元素

有虚拟头结点的链表如图所示：![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190127113947860.png)

**想要删除索引为 2 的元素，步骤：**

1.先找到所要删除元素的前一个节点,即为图中的 1

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190127114025246.png)

2.prev 对应节点的 next 就是所要删除的节点，称为 delNode,

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190127113934170.png)

3.将 prev 对应节点的 next 赋值称为要删除的节点 delNode 的 next;即 执行 prev.next = delNode.next,从某种意义上来说，就将索引为 2 的元素从链表中删除了。 

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190127114153369.png)

4.让 索引为 2 的元素的 next 与链表整个脱离开来，即让 delNode 的 next 指向 NULL,即执行 delNode.next = null ;通过这个测试，就将索引为 2 的元素真正的从链表中删除。

## 5.链表时间复杂度分析

### 1.添加操作:O(n)

addLast(e)     ---O(n) [需要从链表头开始比遍历到链表尾]

addFirst(e)     ---O(1)[直接添加即可]

addIndex(e)   ---O(n/2) = O(n)【均摊】

### 2.删除操作

removeLast(e)    ---O(n)[需要从头找到最后一个元素的前一个位置的节点]

removeFirst(e)   ---O(1)[虚拟头节点就是第一个元素的前一个节点]

removeIndex(e)   ---O(n/2) = O(n)

### 3.修改操作（链表不支持随机访问）

set(index e)    ---O(n)[修改元素必须从头遍历找到要修改元素的位置]

### 4.查找操作

get(index)   ---O(n)[需要从头遍历整个链表]

contains(e)    ---O(n)[需要从头遍历整个链表]

总结：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190127114235855.png)

## 6.使用链表实现栈

==将链表头当做栈顶，用链表作为栈的底层实现来完成栈的结构==

![image-20190127181325044](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190127181325044.png)

```java
public class LinkedListStack<E> implements Stack<E> {       //实现 Stack 接口
    private LinkedList<E> list;     //私有链表对象lis

    public LinkedListStack() {
        list = new LinkedList<>();        //链表初始化
    }

    @Override
    public int getSize() {
        return list.getSize();
    }

    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }

    @Override
    public void push(E e) {
        list.addFirst(e);
    }

    @Override
    public E pop() {
        return list.removeFirst();
    }

    //查看栈顶元素
    @Override
    public E peek() {
        return list.getFirst();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append("Stack: top ");
        res.append(list);
        return res.toString();
    }

    public static void main(String[] args) {

        LinkedListStack<Integer> stack = new LinkedListStack<>();    //声明LinkedListStack的对象stack

        for (int i = 0; i < 5; i++) {    //向栈中压入5个元素
            stack.push(i);
            System.out.println(stack);
        }

        stack.pop();    //从栈中取出元素
        System.out.println(stack);
    }
}
```

### 比较栈与链表的性能差异：

​	**链表栈要比数组栈要快一些，数组栈中，经常需要重新分配整个静态数组，将原来的静态元素分配到新的数组中，比较耗时。**

​	但这个结果不一定对，因为这二者的时间复杂度都是同一级别的，不存在过多的差距。如果输入量增到1000000时，可能数组栈更快了，链表每次new一个空间需要耗时。

## 7.使用链表实现队列

​	在链表的头进行增加或删除操作比较容易，因为有 head 帮助我们标记头部，想要在尾部也进行该操作，加入 tail 帮助我们标记尾部即可使增加操作更加容易，但删除操作需要找到 tail 的前一项，也只能通过遍历的方式来找到。**故==从 head 端删除元素，从tail端插入元素==；如果链表为空时，由于没有 dummyHead，要注意链表为空的情况。**	

### 比较数组、队列、与链表的性能差异：

#### ​	==数组队列--O(n);循环队列--O(1);链表实现队列--O(1)==

# 五、链表和递归

LeetCode题目：

![image-20190128160158783](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190128160158783.png)

### 1.不使用虚拟头结点

代码：https://github.com/JDawnF/structure/tree/master/src/recursion

### 2.使用虚拟头结点

代码：https://github.com/JDawnF/structure/tree/master/src/recursion

### 3.链表与递归

**递归定义：本质上，将原来的问题，转换为更小的同一问题(可以体现在处理的元素更少了)**

例：数组求和：

Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1])				[更小的同一问题]

Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1])				[更小的同一问题]

. . .

 Sum(arr[n-1...n-1]) = arr[n-1] + Sum([])					[最基本的问题]---（只要 Sum([]) 值解决，根据同一逻辑可解决整个问题）

代码实现：

```java
public class Sum {
    public static int sum(int[] arr){  // 这个sum是由用户来使用的
        return sum(arr, 0);       //调用下面的sum
    }

    // 计算arr[l...n)这个区间内所有数字的和
    private static int sum(int[] arr, int left){   //这个 sum 函数是真正的递归函数
        if(left == arr.length) //相当于整个数组为空的时候
            return 0;
        //递归调用【从计算 left--n 的和变为 left+1 -- n 的和】
        return arr[left] + sum(arr, left + 1);
    }

    public static void main(String[] args) {

        int[] nums = {1, 2, 3, 4, 5, 6, 7, 8};
        System.out.println(sum(nums));
    }
}
```

在上述代码中，1.求解最基本的问题

​	if(left == arr.length)  
​        	    return 0;
2.把原问题转换为更小的问题，要根据更小的问题的答案构建出原问题的答案  arr[left] + 

​	 return arr[left] + sum(arr, left + 1);

### 4. 链表的天然递归结构性质

​	链表可以看做是一个 **头结点 0+ 一个更短的链表**，在图中，1 就是更短链表的头结点；也可以看做是 头结点 0+ 一个更短的链表，2 就是更短链表的头结点；[以此类推](https://www.baidu.com/s?wd=%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)，直到最后，可理解为 NULL 本身也是一个链表，是哪个最普通的链表。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-8666635.png)

**解决链表中删除元素的问题：**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171052447.png)

**对于最原始的链表，可看做是 头结点e + 一个更短的链表**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171058211.png)

​	如何通过得到解来解决原问题的解？**对原问题，就是没有考虑 头结点 ：如果头结点e != val(无需删除)，最终原问题的结果，就是头结点e +求得的==子问题链表==；如果需要删除的话，就是后续求出的链表**；![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171133276.png)

代码：

https://github.com/JDawnF/structure/tree/master/src/recursion

### 5. 递归运行的机制：递归的微观解读

##### ==递归调用的代价：函数调用+系统栈空间==

**递归的实质：递归函数的调用就是函数调用，只不过调用的是它自身**

数组求和：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171157485.png)

​	一步步执行到，l==n\==2的时候，return结果，此时一步步递归回去计算结果。即x=0，然后res=0+10,再然后res=0+10+6

**链表中删除元素**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171212945.png)

**图解过程：**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171225214.png)

​	先调用第一步的代码，head不为空，调用第二步代码，这时候传入的是head.next，即传入7，同理，再调用一次函数，传入8，然后继续，传入8.next，即传入空，然后此时head为空了，所以返回null，回到上次的调用，即传入8.next的时候，第二步里面，head.next得到的值是空null，此时再执行第三步，判断head.val是否等于val，如果不等于就返回head，此时不等于，所以返回节点8指向空，此时拼接到节点7后面，然后执行第三步，此时val相等，所以返回7.next,即返回节点8指向空，然后再向上拼接继续重复第二三步。

#### 特殊链表：

##### **1.双链表**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171241404.png)

​	每个节点有两个指针(引用)

##### 2.循环链表

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171254025.png)

​	设置虚拟头节点，尾节点不执行null，执行虚拟头节点，在虚拟头节点添加元素就相当于插入到链表中。

##### 3.数组链表（明确知道要处理元素的个数）

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190128171253954.png)

# 六、二分搜索树

## 1、树结构

**​使用树结构的原因：**

1.树结构是一种天然的组织结构​      

2.数据使用树结构存储后，查找高效

### 二叉树

​	它是动态数据结构【不需要在创建数据结构的时候就决定好要存储多少数据，要添加元素就new一个新的空间加入到其中即可】

![image-20190130130159092](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190130130159092.png)

​	**节点 Node 中，除了要存放元素 e 之外，还要存储两个指向其他节点的引用 left【左孩子】 和 right 【右孩子】**

### 二叉树要点：

1.二叉树具有**唯一的根节点**；

2.二叉树中每个节点最多有两个孩子，每个节点最多有一个父亲节点；一个孩子也没有的叫做叶子节点

3.二叉树具有**天然的递归结构**【每个节点的左子树也是二叉树、每个节点的右子树也是二叉树】

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130130257634.png)

4.二叉树不一定都是“满”的【满二叉树：除叶子节点外，每个节点都有两个孩子】

5.**一个节点、甚至 NULL 也是二叉树**

### 二分搜索树：

1.二分搜索树是二叉树

2.二分搜索树的每个节点的值：**大于其左子树的所有节点的值且小于其右子树的所有节点的值**

3.**二分搜索树的每个子树也是二分搜索树**

4.存储的元素必须具有可比较性【存储自定义数据类型，必须自定义好数据的比较方式】

![image-20190130130323690](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190130130323690.png)

代码：



## 2、向二分搜索树中添加元素

图解步骤：

![image-20190130130400034](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190130130400034.png)

**特殊情况（有重复的话，该元素就相当于已经存在于树中，不做任何改变）**

![image-20190130130419592](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190130130419592.png)

​	**如果想要包含重复元素，只需定义：左子树 <= 节点；右子树 >= 节点【只需将 = 关系放到定义中即可】**

代码：

https://github.com/JDawnF/structure/blob/master/src/BST/BST.java

精简代码：

https://github.com/JDawnF/structure/blob/master/src/BST/BSTSimple.java

## 3、二分搜索树的查询操作

用compareTo方法比较即可，这个方法会返回0，-1，1，表示等于，小于，大于

https://github.com/JDawnF/structure/blob/master/src/BST/BSTSimple.java

## 4、二分搜索树的遍历

### 4.1 二分搜索树的前序遍历

**遍历：就是把所有的节点都访问一遍**

​	二分搜索树的递归操作：**从根节点开始，查看根节点是否是要查找的元素**；是的话直接执行操作即可，不是的话就看要查找的元素是否小于根节点 ，是的话在左子树中继续进行该操作；若是大于根节点,在右子树中继续进行该操作【每次只选择一个子树进行下去】

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130130922343.png)

tranverse(node.left) -- 既要进行二叉树左子树的调用

tranverse(node.right) --也要进行二叉树右子树的调用

代码：https://github.com/JDawnF/structure/blob/master/src/BST/BSTSimple.java

##### **==前序遍历：先遍历根节点，再遍历左子树，最后再遍历右子树==**

### 4.2 二分搜索树的中序遍历和后序遍历

##### ​	==中序遍历：要访问的节点放在中间，先访问其左子树,再访问该节点；最后访问其右子树==

![image-20190130131025343](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190130131025343.png)

​	**二分搜索树的中序遍历结果元素是顺序的，这跟二分搜索树的性质相关** 

##### ==后序遍历：要访问节点放在最后，先访问左子树,再访问右子树；最后访问节点==

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131045810.png)

### 4.3 分析这几种遍历结果：

​	**每个节点递归遍历的话会访问三次**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131123341.png)

**前序遍历:父节点在首位，故只有执行==最左侧(蓝色)的点时才会执行递归调用==**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131141654.png)

**中序遍历:节点在中间，故只有执行最中间(蓝色)的点时才会执行递归调用**

**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131150452.png)**

**后序遍历:节点在后面，故只有执行最后面(蓝色)的点时才会执行递归调用**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131151465.png)

### 4.4 二分搜索树前序遍历的非递归实现

**前序遍历**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131203194.png)

**使用栈来模拟递归调用**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190130131238908.png)

## 5、二分搜索树的层序遍历

==前序、中序、后序遍历本质都是深度优先遍历==

层序遍历：根节点设置为第0层；先遍历第0层28、再遍历第1层16、30；再遍历第2层13、22、29、42；**逐层向下遍历的节点在广度上进行拓展；这种遍历方式也称为广度优先遍历；通常使用非递归的方式实现。**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131200712054.png)

图解：用**队列**的方式实现层序遍历

1.每一次一个元素入队，**从队尾的位置进入队列，初始化时将根节点入队**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131200720617.png)

2.以后每一次要做的事就是先看队首(看该到谁开始遍历了)，出队的就是根节点28，访问28对其进行相应的操作，这样28就遍历完了；

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131200744004.png)

3.将根节点 28 的左右孩子（16和30）分别入队【**对于队列来说，是先进先出，所以我们按照从左到右的顺序进行入队，所以先入队16后入队30**】![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131200806749.png)

4.现在的队首是16，将16拿出来，对其进行访问！

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131200814354.png)

5.将 16 的左右孩子 13 和 22 入队，

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131200825413.png) 

6.对队首元素 30 出队，对其进行操作，并将 30 的左右孩子（29和42）入队

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131200825936.png)

7.对队首元素 13 出队，对其进行操作，但13没有左右节点，他是个**叶子节点**；

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131200825456.png)

8.然后与上述相同，依次对队首元素进行操作，队列全部出队；【到这一步，队列的排序就与层序遍历相同了】

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131200836815.png)

广度优先遍历的意义：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131200907865.png)

​	在如图的某些模型中，广度优先遍历能够更快的查询到该元素，最短路径问题。

## 6、删除二分搜索树的节点

### 6.1 删除二分搜索树的最小值和最大值

#### 1.先找到二分搜索树的最小值和最大值(二分搜索树的特性)

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131203214393.png)

最小值：二叉树中的最左侧的元素（**不存在左孩子的父节点**）

最大值：二叉树中的最右侧的元素（**不存在右孩子的父节点**）

#### 2.再删除二分搜索树的最小值和最大值

​	1.当要删除的节点为叶子节点时，直接删除即可

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131203235670.png)

​	2.当要删除的节点不是叶子节点时，将该节点删除，**删除后将其整个右子树变为根节点的左子树即可**，因为左子树任意节点都小于右子树的任意节点

![image-20190131203253030](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190131203253030.png)

### 6.2 删除二分搜索树的任意元素

1.删除只有左孩子的节点：节点删除之后，将左孩子所在的二叉树取代其位置；连在原来父亲元素右节点的位置

2.删除只有右孩子的节点：节点删除之后，将右孩子所在的二叉树取代其位置；连在原来父亲元素左节点的位置

3.难点：删除有左右孩子的节点（删除左右都有孩子的节点d）

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131203333181.png)

在图中，**要删除58，就是要找到58的替代节点，找 58 （d）的后继**：所有元素中，离 58 最近的且比 58 大的节点，即图中的 59 (s)【即右子树中的最小值】

![image-20190131203357382](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190131203357382.png)

#### 另一种做法，找到左子树最大的树：![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131203427579.png)

最终代码：https://github.com/JDawnF/structure/blob/master/src/BST/BSTSimple.java

### 总结：

**1.二分搜索树的顺序性：放入.二分搜索树的元素都是有序的；**

**2.floor 和 ceil:floor:比45小的最大元素；ceil:比45大的最小元素【这两个可以不在二分搜索树中】**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131203515386.png)

**3.rank ：58 在整个树中所有的元素里排第几**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131203529305.png)

**4.select:rank 的反向操作**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131203535359.png)

**5.维护 size 的二分搜索树**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131203540508.png)

**6.支持重复元素的二分搜索树（定义左子树的节点 <= 父节点的值,count记录重复元素个数）**

![image-20190131203552423](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190131203552423.png)

# 七、集合和映射

## 1.集合(set)基础与集合实现

### 1.1 集合基础和基于二分搜索树的集合实现

集合：承载元素的容器，但每个元素都只能存在一次；能够快速实现“**去重**”这个工作；

（**二分搜索树不能添加重复元素**，是非常好的实现“集合”的底层数据结构）

基础功能代码：

Set<E>

- void add(E)   :	         向集合中添加元素E（不能添加重复元素）
  - void remove(E) :             从集合中删除元素E
- boolean contains(E):     检验集合是否包含元素E

- int getSize:                      获取集合中元素的个数

- boolean isEmpty():        检验集合是否为空 


### 1.2 基于链表的集合实现

使用链表来实现集合的数据结构（**二分搜索树与链表都属于动态的数据结构**）

![image-20190131230248395](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190131230248395.png)

### 1.3 集合类的复杂度分析

==使用二分搜索树比链表来实现集合要快的多==

分析：（对二叉树--   n:节点数量；h：高度）

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131230358634.png)



分析 二叉树中 n 与 h 的关系

#### 1.满二叉树情况

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131230412930.png)

分析过程：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131230425869.png)

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131230425929.png)

**==可知：n 与 h 之间的关系为 h=O(log n),可得：==**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131230426296.png)

log n 与 n 的差距【log n 的时间复杂度很小，特别快】，==在高阶算法中的 nlog n 的复杂度比 n2 的复杂度快 很多很多倍==

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131230441530.png)

**使用二分搜索树，==复杂度最坏的情况就是排成一列（相当于链表）==**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131230441877.png)

#### 完整版复杂度分析：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131230441889.png)



补充：

有序集合：有序集合中的元素具有顺序性（二分搜索树）【**实现增删查改更容易，但时间复杂度要大于哈希表**】

无序集合：无序集合中的元素不具有顺序性（链表，更高效的方案是使用哈希表），由元素插入顺序决定了其在集合中的顺序，【不能轻易的从小到大来遍历集合，也无法找到最小元素与最大元素、第n个元素是谁这些操作】

多重集合：集合中的元素可以重复【允许重复元素的二分搜索树的基础上包装一层就是多重集合】

## 2.映射基础与映射实现

### 2.1 映射([Map](https://www.baidu.com/s?wd=Map&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd))基础

定义：定义域中的每一个值在子域中都有一个值与它对应；存储(键、值)【Key、Value】数据对的数据结构；根据键，来快速的寻找值，可以非常容易的使用二分搜索树来实现它

![image-20190131231354264](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190131231354264.png)

实现机制：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131231416464.png)

```
Map<K,V>  通过泛型来实现，向 Map 中传入 Key 和 Value 这两个环境变量；

void add(K,V)     添加一个新的元素（键值数据对）

V remove(K)    删除一个元素，对映射来说，键充当索引的作用；可以不考虑键对应的值是谁，只要指定删除键对应的数据，它相应的值就跟着删除了；删除了 K ，告诉用户 K 对应的 Value 是什么，以便用户日后使用；

boolean contains(K)  查找元素，只要看 Key 是否存在于 Map 的数据结构中；

V get(K)   获取具体元素，get 方法中传入的 Key ，也就是键值；查询的是键（key）,返回的是值(Value);

void set(K,V)  修改元素，给定一个新的键(key)和值(value),修改键(key) 在 Map 中对应的值(value)

int getSize()  映射中存储的元素的数量，每一个元素都是一个键值对

boolean isEmpty()  判断映射是否为空
```

### 2.2 以链表来实现映射

### 2.3 基于二分搜索树的映射实现

### 2.4 映射的复杂度分析和更多映射相关问题

结果可知：**基于二分搜索树所实现的映射时间复杂度远远小于基于链表所实现的映射时间复杂度**

分析：基于二分搜索树所实现的映射中时间复杂度是O(h)，**h 是二分搜索树对应的高度，从根节点开始一层一层的向下找，二分搜索树有多少层它就访问了多少节点**；基于链表所实现的映射时间复杂度为 O(n),对应所有的元素都要遍历一遍。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131231533166.png)

### 补充：

1.有序映射：Map 中的 键(key) 具有顺序性；【基于搜索树实现】

2.无序映射：Map 中的 键(key) 不具有顺序性；【更高效的通过哈希表来实现】

3.多重映射：多重映射中的键可以重复

4.集合和映射的关系：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190131231556018.png)

从某种意义上，可以认为映射Map也是集合Set,**不过是键(key)这样的集合，而每一个 key 都携带了 value**  ；本质与映射没有太大的区别；==二者间可以相互转化，若有了集合的底层实现，通过重定义集合中的元素E是键值数据对<K,V>，对键值数据对进行比较时，是以键值 Key 进行比较的，而不在意 Value 的值。==

但更常见的操作是基于映射的实现包装出集合来，若有了映射E的底层实现，集合<K,V>就可以理解为<K,V>中 V 为空的情况，无论什么键(key),其对于的值都是空的，只考虑键即可，当只考虑键key时，映射Map就是Set<K>的集合，但get 与 set 方法就没有意义了，只要对映射Map包装，就可以得到集合Set 这种数据结构了。

代码：https://github.com/JDawnF/structure/tree/master/src/map

# 八、优先队列和堆

## 1 简介

### 1.1 优先队列

普通队列：先进先出，后进后出

**优先队列：出队顺序和入队顺序无关；==和优先级相关；==**（例如医院排队和操作系统动态选择优先级最高的任务执行）

图解：关键词“动态”；队列中的元素是在不断变化的，不断有新元素入队，不仅仅是按照优先级排序；【优先级可以具体定义】

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123547070.png)

与普通队列的区别：**出队元素是优先级最高的元素；队首元素也是优先级最高的元素，而不是最早进入队列的元素；**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123557799.png)

### 1.2 堆的基础结构(完全二叉树)

#### 1.二叉堆（Binary Heap）

​	二叉堆要满足的条件：**二叉堆是一颗完全二叉树；**完全二叉树：把元素顺序排列成树的形状；【最下面一层都是叶子节点，但在最后一层上面可能还有叶子节点，但这些叶子节点必须全在树的右侧】

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123621402.png)

二叉堆的性质：【节点大小和所处层次之间并没有必然的联系】

1.最大堆(大根堆)：堆中某个节点的值总是小于其父节点的值；【==父亲节点的值要大于左右孩子的值==】

2.最小堆(小根堆)：堆中某个节点的值总是大于其父节点的值；【==父亲节点的值要小于左右孩子的值==】

可以用数组来实现完全二叉树：

![image-20190201123633150](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/image-20190201123633150.png)

堆中对应的元素与数组中对应，从左到右，从上到下依次排序。

## 2.堆的添加和取出元素

### 2.1 向堆中添加元素

##### 堆中元素上浮（Sift up）

1.在堆中添加元素 52

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123722316.png)

2. 添加 52 后，52 > 16 ，不满足条件 父亲节点 > 孩子节点；要进行调整：从 52 开始一路与其父亲节点做比较并交换顺序

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123729499.png)

将 52 与 16 交换顺序；但 52 > 41 ,继续交换位置

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123729808.png)

这时，62 > 52 ,符合堆的性质  

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123751262.png)

堆中元素上浮（Sift up）：52 从底部逐渐上浮，直到其合适的位置依然可以维持堆的性质

### 2.2 从堆中取出元素

​	取出元素，**只取出堆顶元素（二叉树根节点）**，这个元素是二叉树中存储的最大的元素【取出操作只能取出该元素，不能取出其他元素】；

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123808955.png)

过程：1.访问根节点，数组中索引为 0 的元素；将其拿走之后，对整个堆来说，可以看成是有两颗子树；

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123819989.png)

2.将堆中的最后一个元素（即 16）顶到堆顶去；数组0变为16并删掉数组中10对应的16

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123844488.png)

3.但16在堆顶的话，打破了堆的性质，16 小于52和 30 ;不符合堆中父亲节点大于左右孩子的性质；

##### **Sift Down：堆中元素下沉；**

下沉过程1.父亲节点和左右孩子进行比较（16与52和30进行比较）；

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123853305.png)

2.选择孩子中较大的元素，交换位置；

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123858725.png)

3.父亲节点继续与左右孩子对比，重复上面步骤

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123905623.png)

4.16 > 15，满足堆的性质，最终形态为下图

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201123905334.png)

时间复杂度分析：添加(add) 和 取出操作(extractMax) 的时间复杂度都是：O(log n)【还是二叉树高度这个级别，但对于堆来说，由于其是完全二叉树，故永远不会变为链表形态，不存在最差时为 n 的情况】

## 3.Heapify 和 Replace

### 3.1 replace

定义：取出最大元素后，放入一个新元素【堆中总数没有变化】

实现方法：1.可以先 extractMax,再 add,两次O(log n)的操作；

​                   2.可以直接将堆顶元素替换以后 Sift Down,一次 O(log n)的操作；

### 3.2 Repalce

**定义：将任意数组整理成堆的形状；**

方法：将当前数组看做完全二叉树，**从当前最后一个非叶子节点开始；即图中的 22 ；【最后一个非叶子节点的索引：拿到最后一个叶子节点，根据这个叶子节点来计算其父亲节点的索引即可】**，从最后一个非叶子结点到根节点遍历，然后不断下沉

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201124159553.png)

从 22 开始，不断进行下沉操作

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201124212955.png)

索引为3 的是13，对其进行下沉操作，交换 41 和 13；

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201124212972.png)

索引为 2 的是19，对其进行下沉操作

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201124222978.png)

对索引为 1 、0 的继续进行下沉，得到最终的二叉树

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190201124222987.png)

#### Heapify 的算法复杂度：

将 n 个元素逐个插入到一个空堆中，算法复杂度：O(nlog n);

==使用 heapify ，算法复杂度：O(n)==

https://github.com/JDawnF/structure/tree/master/src/heap

## 4.基于堆的优先队列

### 优先队列的经典问题

在100 0000 个元素中选出前 100 个元素【在N个元素中选出前M个元素，M<<N】

解决方法：

1.使用高级排序（归并等）时间复杂度为 NlogN;

2.使用优先队列时间复杂度为 NlogM;（M<<N）

使用优先队列方法思路：【使用最小堆】

使用优先队列维护当前看到的前M个元素，将N个元素中的前M个元素放入优先队列中，之后每看到一个新的元素，如果这个新的元素比优先队列中最小的元素还要大的话，就用这个新的元素取代优先队列中的最小元素；直到遍历完所有N个元素，这时留在其中的M个元素就是我们所要找的M个元素。

代码：

https://github.com/JDawnF/structure/blob/master/src/stack_queue/PriorityQueue.java

#### 1.d 叉堆 (d-ary heap)

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190202184612787.png)

#### 2.索引堆：可以通过索引来很快的知道元素在堆中的位置，并修改该元素

#### 3.广义队列

只要支持入队与出队操作的都可以称为队列；

普通队列：先进先出，先到先得

优先队列：拿出优先级最高的元素作为出队元素的队列【栈也可以理解成一个队列】

# 九、线段树(或称为区间树)

## 1.线段树作用：

​	对于有一类问题，我们关心的是线段(或区间)。比如：经典线段树问题：区间染色。有一面墙，长度为 n ，每次选择一段墙进行染色

染色过程：

1. 4-9 黄色 

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124147778.png)

2. 7-15 绿色

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124147753.png)

3. 1-5 蓝色

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124202238.png)

4. 6-12 红色

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124201704.png)

存在颜色覆盖问题，

1.m 次操作后，可以看见多少种颜色？

2.m 次操作后，在区间 [i,j] 可以看见多少种颜色？

分析：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124214800.png)

另一类经典问题：区间查询

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124223106.png)

查询一个区间 [ i,j ] 的最大值，最小值，或者**区间数字和**  【实质：基于区间的统计查询】

实际使用情况：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124230806.png)

==使用线段树的必要性：极大降低时间复杂度==

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124230525.png)

#### 总结线段树：

==对于给定区间--更新==：更新区间中一个元素或者一个区间的值   /   查询一个区间 [i,j] 的最大值，最小值，或者区间数字和。

## 2.什么是线段树

**每一个节点表示 一个区间内的信息，不断拆分区间，==直到每个叶子节点均表示一个元素；==**

线段树优势：可以快速的找到所关心的区间，对其进行操作；无需对区间所有的元素都进行一次遍历

==线段树是平衡二叉树，堆也是平衡二叉树==，区间是固定的，但是区间的元素可能会变化。

## ![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124253568.png)

例 ：10 个元素的线段树，区间的元素是固定的。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124307203.png)

​	线段树不是完全二叉树（对于深度为K的，有n个结点的二叉树，**当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树**）

【二叉树，完全二叉树，满二叉树，平衡二叉树的区别】

线段树是平衡二叉树，可以用数组来表示（==对于整棵树来说，最大深度与最小深度之间的差最多为 1==），平衡二叉树就是叶子结点之间相差的深度不会超过1。如下面叶子结点在第4层和第5层，相差为1

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124325492.png)

如果区间有 n 个元素，用数组表示需要多少个节点?

分析：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124333289.png)

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124332964.png)

​	因为最后一层的节点数约等于上面所有层数之后，所有这里就是2n。最坏情况的时候，即满二叉树的话就需要4n。

​	**区间有 n 个元素，用数组表示需要 4n 空间，线段树不考虑添加元素，即区间固定，**==使用 4n 的静态空间即可，但存在内存占用浪费的情况，如下图，为空的也要占据存储空间，一般忽略 (**使用空间换时间**)==

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124341482.png)

[递归]建立线段树：

https://github.com/JDawnF/structure/tree/master/src/segmentTree

## 3.线段树的查询

查询 [ 2 , 5 ]

过程如图：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124402147.png)

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124401755.png)



递归查询，首先要先判断查询的区间是全部在左孩子节点或者是右孩子节点，如果是这两种的情况的话就比较简单，直接从左边界到mid或者mid+1到r，如果左右孩子中都要查询，就要分析查询空间的左边界到mid，和mid+1到查询区间的右边界

## 补充：

### 1.对一个区间进行更新

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124428083.png)

方案：懒惰更新--**使用 lazy 数组记录未记录内容**

### 2.二维线段树

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124427862.png)

### 3.动态线段树

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190203124428960.png)

原来的话空间是4n

# 十、字典树

## 1.概述

【多叉树】 专门处理字符串，专门为 字典(一个词条和一个示意相对应)设计的数据结构；

 在 字典  中，有 n 个词条，使用 映射 方式查找，本质是使用 树结构 ，查询的时间复杂度是 O(log n);

使用 字典树(Tire)  的数据结构时，查询每个词条的时间复杂度与 字典 中一共有多少条目无关；与查询字符串[单词]的长度 w 相关，时间复杂度为 O(w);[但大多数单词的长度小于 10]

字典树图解：![image-20190203202633329](/Users/jack/Desktop/md/images/image-20190203202633329.png)

每个节点有 26 （26个英文字母，根据情况可更改）个指向下个节点的指针。在不同情景下，每个节点有若干指向下个节点的指针，这是**动态的数据结构**。	

![image-20190203202709612](/Users/jack/Desktop/md/images/image-20190203202709612.png)

​	仅靠判断节点是否是叶子节点来判断单词是否查询完成是不可行的，因为有些单词本身就是其他单词的一部分[pan 是 panda 的一部分]，故添加 boolean 值 is[Word](https://www.baidu.com/s?wd=Word&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd) 来判断当前的节点是否代表一个单词的结尾；

![image-20190203202741538](/Users/jack/Desktop/md/images/image-20190203202741538.png)

## 2.字典树的创建及查询

代码：

## 3.Trie字典树的前缀查询

![img](/Users/jack/Desktop/md/images/70-20190203202941923.png)

​	在 Tire 中搜索一个单词的过程中，在一个支路上所经过的字符串是否都是目标单词的前缀，通过这种数据结构，可以快速的查看在当前存储的所有单词中，是否有某一个前缀对应的单词。

### Trie字典树和简单的模式匹配

![img](/Users/jack/Desktop/md/images/70-20190203203208087.png)

### Trie字典树和字符串映射

![img](/Users/jack/Desktop/md/images/70-20190203203221374.png)

## 补充：

### 1.Tire 的删除操作

删除 deer :当搜索到 deer 最后一个字母的时候，自底向上地删除即可，每一个节点如果其对于的 next 为空则相应的都可以删除

![image-20190203203305251](/Users/jack/Desktop/md/images/image-20190203203305251.png)      

在 panda 中删除 pan ，n 并不是叶子节点，将 n 节点的 isword 删除即可

![img](/Users/jack/Desktop/md/images/70-20190203203312861.png)

### 2.Tire 的局限性

最大的问题：空间

即使是 26 个字母表这样的字符空间，TreeMap 也要存储 26 条记录，存储空间是原来的 27 倍，空间消耗巨大；位解决该问题。提出 压缩字典树 (Compressed Trie)[维护成本高]

![img](/Users/jack/Desktop/md/images/70-20190203203331125.png)

另一个解决方案：三分搜索树【只有 3 个孩子，占用空间小 ，所费时间略微多了，与所查找字符串长度成正比】

![image-20190203203355943](/Users/jack/Desktop/md/images/image-20190203203355943.png)

# 十一、并查集

## 1.概述

[一个很有意思的并查集详解](https://blog.csdn.net/u013546077/article/details/64509038)

由孩子节点指向父亲节点的树结构，解决连接问题，如图来判断两个点之间是否是连接的

![img](/Users/jack/Desktop/md/images/70-20190203203847984.png)

并查集：可以快速判断网络中节点间的连接状态【网络：抽象概念，用户之间形成的网络】可以高效回答连接问题的数据结构

对于一组数据，主要支持两个动作：

​	1.uoion(p,q)   --并，传入数据 p 和 q,在并查集内部将这两个数据，以及他们所在的集合合并起来

​	2.isConnected(p,q)   ---查询 ，对于给定的两个数据 p 和 q 是否属于同一个集合

## 2.并查集的基本数据表示

第一版Union-Find本质就是一个数组

 对 10 个元素 （0-9）分成 2 个集合，其中 (0-4) 这 5 个元素为 集合0 ；(5-9) 这 5 个元素为 集合1

 ![img](/Users/jack/Desktop/md/images/70-20190203204111942.png)

或者

![img](/Users/jack/Desktop/md/images/70-20190203204111941.png)

在 isConnected(p,q)   ---查询 中，只需要查看  p 和 q 所对应的 Id 值是否相等即可，将查看  p 和 q 背后的 Id 是谁的过程抽象为函数：find(p) == find(q) ,这种方式为 Quick Find,其时间复杂度为 O(1)

但 Quick Find 中的 uoion(p,q)   --并  时间复杂度为 O(n)；合并过程需要遍历一遍所有元素, 将两个元素的所属集合编号合并

![img](/Users/jack/Desktop/md/images/70-20190203204154287.png)

第二版Union-Find, 使用一个数组构建一棵指向父节点的树

将每一个元素，看做是一个节点；其中，节点 3 指向其父节点 2，2 为根节点，其指针指向自己即可；

节点1 和 节点3 合并，则让 节点1 所对应的指针指向 节点3 所在树的根节点，即 节点2；

![img](/Users/jack/Desktop/md/images/70-20190203204207632.png)

如果让 节点7 和 节点2 合并 ，即让 节点7 所在的 根节点5 ，指向 节点2 即可；

如果让 节点7 和 节点3 合并 ，即让 节点7 所在的 根节点5 ，指向 节点3 所在树的 根节点2 即可；

![img](/Users/jack/Desktop/md/images/70-20190203204216821.png)

Quick Union:并查集不是一个树结构，而是 森林结构 ，里面存在很多树 ，在初始亲情况下有 10 棵树，每棵树只有一个节点；![image-20190203204234890](/Users/jack/Desktop/md/images/image-20190203204234890.png)

如果执行 union 4,3 操作

![image-20190203204249770](/Users/jack/Desktop/md/images/image-20190203204249770.png)

再执行 union 3,8

![image-20190203204320883](/Users/jack/Desktop/md/images/image-20190203204320883.png)

![image-20190203204353436](/Users/jack/Desktop/md/images/image-20190203204353436.png)

## 3.优化

### 基于size的优化

并查集的实现由于对真正合并的元素不做形状上的判断，这个合并的过程会不断增加树的高度，甚至演化为链表；

解决办法：考虑(size)当前这棵树整体有多少个节点,例如 union 4,9,正常操作如下图

![img](/Users/jack/Desktop/md/images/70-20190203204803619.png)

这时的高度为 4，但完全可以让 9 指向 4 所在的根节点 8 ，即 9 指向 8；高度变为 3

![img](/Users/jack/Desktop/md/images/70-20190203204810874.png)

### 基于rank的优化【树的高度】

![img](/Users/jack/Desktop/md/images/70-20190203204929998.png)

执行 union 4,2 ，以 size 优化方式执行，高度变高了

![img](/Users/jack/Desktop/md/images/70-20190203204929987.png)

更合理的方式： 在每一个节点上记录以这个节点为根的对应的树，其最大深度为多少，在真正合并的时候，应该使用深度比较低的那棵树向深度比较高的树进行合并；整体更加合理；称为 基于rank 的优化，k[i] 表示根节点为 i 的树的高度

![img](/Users/jack/Desktop/md/images/70-20190203205046523.png)

路径压缩(Path Compression)

由上述几种优化方式，知

![img](/Users/jack/Desktop/md/images/70-20190203205128174.png)

查找节点：左侧的高度最大，其执行速度最慢；下侧的高度最小，其执行速度最快；故将 高度大的树 压缩成为 高度小的树 称为路径压缩；

对并查集来说，每一个节点其子树是没有限制的，故理想情况下，希望树的形态如下侧那样（根节点在第一层，其余节点均在第二层），但很难实现吗，通常只要追求高度减小即可提高运行速率；

压缩过程：find 4  【在查询过程中，压缩路径，使高度变小】

1.

![img](/Users/jack/Desktop/md/images/70-20190203205215568.png)

2.

![img](/Users/jack/Desktop/md/images/70-20190203205215620.png)

3.

![img](/Users/jack/Desktop/md/images/70-20190203205215602.png)

理想状况：通过 递归 实现

![img](/Users/jack/Desktop/md/images/70-20190203205237635.png)

补充：在方式 5 中也可以变为理想状态下的情况【不是通过 递归 ，通过 循环遍历 来实现】

![image-20190203205301582](/Users/jack/Desktop/md/images/image-20190203205301582.png)

时间复杂度：O(h) --- 严格意思上：O(log  *n)

![img](/Users/jack/Desktop/md/images/70-20190203205313254.png)





































































































































































































































































































参照：慕课网《玩转数据结构》

​	https://blog.csdn.net/jianghao233/article/list/2?t=1&