# 一、范式

范式是具有最小冗余的表结构。3 范式具体如下:

## 第一范式**(1st NF** -列都是不可再分) 

​	第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元(也称为最小的原子单元)，则满足第一范式(1NF) 

![image-20190418204240383](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20190418204240383.png)

## 第二范式**(2nd NF**-每个表只描述一件事情)

​	首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一件事情。

![image-20190418204259606](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20190418204259606.png)

## 第三范式**(3rd NF**- 不存在对非主键列的传递依赖**)**

​	第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号。

![image-20190418204329306](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20190418204329306.png)

# 二、存储过程**(**特定功能的 **SQL** 语句集**)** 

​	一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次 编译，用户通过指定存储过程的名字并给出参数(如果该存储过程带有参数)来执行它。存储过 程是数据库中的一个重要对象。 

## 存储过程优化思路: 

1. 尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。 

2. 中间结果存放于临时表，加索引。 

3. 少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如 

   对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次 

   读取。 

4. 事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成 

   并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。 

5. 使用 try-catch 处理错误异常。 

6. 查找语句尽量不要放在循环内。 

# 三、触发器**(**一段能自动执行的程序**)** 

​	触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是: 触发器是当对某一个表进行操作时触发。诸如:update、insert、delete 这些操作的时候，系统 会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类:DML 触发器和 DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有 create、 alter、drop 语句。 

# 四、ER图

Entity-Relationship，有三个组成部分:实体、属性、联系。用来进行关系型数据库系统的概念设计。

**实体的三种联系 包含一对一，一对多，多对多三种。** 

- 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B; 
- 如果是一对一，画两个带箭头的线段; 
- 如果是多对多，画两个不带箭头的线段。 

![image-20190418205146682](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20190418205146682.png)