# 一、数据库引擎

MySQL 提供了多种的存储引擎：

- InnoDB
- MyISAM
- MRG_MYISAM
- MEMORY
- CSV
- ARCHIVE
- BLACKHOLE
- PERFORMANCE_SCHEMA
- FEDERATED

## InnoDB

​	==InnoDB是一个健壮的事务型存储引擎==，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。InnoDB还引入了行级锁定和外键约束，**在以下场合下，使用InnoDB是最理想的选择：**

- 更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。
- 事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。
- 自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
- 外键约束。MySQL支持外键的存储引擎只有InnoDB。
- 支持自动增加列AUTO_INCREMENT属性。
- 从5.7开始innodb存储引擎成为默认的存储引擎。

==一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。==

### **InnoDB 的 4 大特性**

- 插入缓冲(insert buffer)
- 二次写(double write)
- 自适应哈希索引(ahi)
- 预读(read ahead)

## MyISAM

​	**MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。**例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：

- tb_demo.frm，存储表定义。
- tb_demo.MYD，存储数据。
- tb_demo.MYI，存储索引。

​	==MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：==

1. 选择密集型的表。**MyISAM存储引擎在筛选大量数据时非常迅速**，这是它最突出的优点。
2. 插入密集型的表。**MyISAM的并发插入特性允许同时选择和插入数据。**例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。

![image-20190327211524719](/Users/jack/Desktop/md/images/image-20190327211524719.png)

## MRG_MYISAM

​	MRG_MyISAM存储引擎是一组MyISAM表的组合，老版本叫 MERGE 其实是一回事儿，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。**说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。**

##### 	Merge存储引擎的使用场景。

​	对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。

- ENGINE=MERGE，指明使用MERGE引擎，其实是跟MRG_MyISAM一回事儿，也是对的，**在MySQL 5.7已经看不到MERGE了。**
- UNION=(t1, t2)，指明了MERGE表中挂接了些哪表，可以通过alter table的方式修改UNION的值，以实现增删MERGE表子表的功能。比如：

```Java
alter table tb_merge engine=merge union(tb_log1) insert_method=last;
```

- INSERT_METHOD=LAST，INSERT_METHOD指明插入方式，取值可以是：0 不允许插入；FIRST 插入到UNION中的第一个表； LAST 插入到UNION中的最后一个表。
- MERGE表及构成MERGE数据表结构的各成员数据表必须具有完全一样的结构。每一个成员数据表的数据列必须按照同样的顺序定义同样的名字和类型，索引也必须按照同样的顺序和同样的方式定义。

## MEMORY

​	**使用MySQL Memory存储引擎的出发点是速度。**为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。

一般在以下几种情况下使用Memory存储引擎：

- 目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。
- 如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。
- 存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。
- Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用<、>和>=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和<>的操作符中，不适合在<或>操作符中，也同样不适合用在order by子句中。

## CSV

CSV 存储引擎是基于 CSV 格式文件存储数据。

- CSV 存储引擎因为自身文件格式的原因，所有列必须强制指定 NOT NULL 。
- CSV 引擎也不支持索引，不支持分区。
- CSV 存储引擎也会包含一个存储表结构的 .frm 文件，还会创建一个 .csv 存储数据的文件，还会创建一个同名的元信息文件，该文件的扩展名为 .CSM ，用来保存表的状态及表中保存的数据量。
- 每个数据行占用一个文本行。

因为 csv 文件本身就可以被Office等软件直接编辑，保不齐就有不按规则出牌的情况，如果出现csv 文件中的内容损坏了的情况，也可以使用 CHECK TABLE 或者 REPAIR TABLE 命令检查和修复

## ARCHIVE

Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。

## BLACKHOLE

黑洞存储引擎，所有插入的数据并不会保存，BLACKHOLE 引擎表永远保持为空，写入的任何数据都会消失，

## PERFORMANCE_SCHEMA

主要用于收集数据库服务器性能参数。MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表，一般用于记录binlog做复制的中继。在这里有官方的一些介绍[MySQL Performance Schema](https://dev.mysql.com/doc/refman/5.6/en/performance-schema.html)

## FEDERATED

主要用于访问其它远程MySQL服务器一个代理，它通过创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，而后完成数据存取；在MariaDB的上实现是FederatedX

### 其他

这里列举一些其它数据库提供的存储引擎，OQGraph、SphinxSE、TokuDB、Cassandra、CONNECT、SQUENCE。提供的名字仅供参考。

## 常用引擎对比

​	不同存储引起都有各自的特点，为适应不同的需求，需要选择不同的存储引擎，所以首先考虑这些存储引擎各自的功能和兼容。

| 特性                                                   | InnoDB | MyISAM | MEMORY | ARCHIVE |
| ------------------------------------------------------ | ------ | ------ | ------ | ------- |
| 存储限制(Storage limits)                               | 64TB   | No     | YES    | No      |
| 支持事物(Transactions)                                 | Yes    | No     | No     | No      |
| 锁机制(Locking granularity)                            | 行锁   | 表锁   | 表锁   | 行锁    |
| B树索引(B-tree indexes)                                | Yes    | Yes    | Yes    | No      |
| T树索引(T-tree indexes)                                | No     | No     | No     | No      |
| 哈希索引(Hash indexes)                                 | Yes    | No     | Yes    | No      |
| 全文索引(Full-text indexes)                            | Yes    | Yes    | No     | No      |
| 集群索引(Clustered indexes)                            | Yes    | No     | No     | No      |
| 数据缓存(Data caches)                                  | Yes    | No     | N/A    | No      |
| 索引缓存(Index caches)                                 | Yes    | Yes    | N/A    | No      |
| 数据可压缩(Compressed data)                            | Yes    | Yes    | No     | Yes     |
| 加密传输(Encrypted data[1])                            | Yes    | Yes    | Yes    | Yes     |
| 集群数据库支持(Cluster databases support)              | No     | No     | No     | No      |
| 复制支持(Replication support[2])                       | Yes    | No     | No     | Yes     |
| 外键支持(Foreign key support)                          | Yes    | No     | No     | No      |
| 存储空间消耗(Storage Cost)                             | 高     | 低     | N/A    | 非常低  |
| 内存消耗(Memory Cost)                                  | 高     | 低     | N/A    | 低      |
| 数据字典更新(Update statistics for data dictionary)    | Yes    | Yes    | Yes    | Yes     |
| 备份/时间点恢复(backup/point-in-time recovery[3])      | Yes    | Yes    | Yes    | Yes     |
| 多版本并发控制(Multi-Version Concurrency Control/MVCC) | Yes    | No     | No     | No      |
| 批量数据写入效率(Bulk insert speed)                    | 慢     | 快     | 快     | 非常快  |
| 地理信息数据类型(Geospatial datatype support)          | Yes    | Yes    | No     | Yes     |
| 地理信息索引(Geospatial indexing support[4])           | Yes    | Yes    | No     | Yes     |

1. 在服务器中实现（通过加密功能）。在其他表空间加密数据在MySQL 5.7或更高版本兼容。
2. 在服务中实现的，而不是在存储引擎中实现的。
3. 在服务中实现的，而不是在存储引擎中实现的。
4. 地理位置索引，InnoDB支持可mysql5.7.5或更高版本兼容

## 查看存储引擎

使用“SHOW VARIABLES LIKE '%storage_engine%';” 命令在mysql系统变量搜索磨人设置的存储引擎，输入语句如下：

```
mysql> SHOW VARIABLES LIKE '%storage_engine%';
+----------------------------------+---------+
| Variable_name                    | Value   |
|----------------------------------+---------|
| default_storage_engine           | InnoDB  |
| default_tmp_storage_engine       | InnoDB  |
| disabled_storage_engines         |         |
| internal_tmp_disk_storage_engine | InnoDB  |
+----------------------------------+---------+
4 rows in set
Time: 0.005s
```

使用“SHOW ENGINES;”命令显示安装以后可用的所有的支持的存储引擎和默认引擎，后面带上 \G 可以列表输出结果，你可以尝试一下如“SHOW ENGINES\G;”。

```
mysql> SHOW ENGINES;
+--------------------+---------+--------------------------------------+-------------+--------+-----------+
| Engine             | Support | Comment                              | Transactions| XA     | Savepoints|
|--------------------+---------+--------------------------------------+-------------+--------+-----------|
| InnoDB             | DEFAULT | Supports transactions,               | YES         | YES    | YES       |
|                    |         | row-level locking, and foreign keys  |             |        |           |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables| NO          | NO     | NO        |
| MEMORY             | YES     | Hash based, stored in memory, useful | NO          | NO     | NO        |
|                    |         | for temporary tables                 |             |        |           |
| BLACKHOLE          | YES     | /dev/null storage engine (anything   | NO          | NO     | NO        |
|                    |         | you write to it disappears)          |             |        |           |
| MyISAM             | YES     | MyISAM storage engine                | NO          | NO     | NO        |
| CSV                | YES     | CSV storage engine                   | NO          | NO     | NO        |
| ARCHIVE            | YES     | Archive storage engine               | NO          | NO     | NO        |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                   | NO          | NO     | NO        |
| FEDERATED          | NO      | Federated MySQL storage engine       | <null>      | <null> | <null>    |
+--------------------+---------+--------------------------------------+-------------+--------+-----------+
```

由上面命令输出，可见当前系统的默认数据表类型是InnoDB。当然，我们可以通过修改数据库配置文件中的选项，设定默认表类型。

## 设置存储引擎

对上面数据库存储引擎有所了解之后，你可以在`my.cnf` 配置文件中设置你需要的存储引擎，这个参数放在 [mysqld] 这个字段下面的 default_storage_engine 参数值，例如下面配置的片段

```
[mysqld]
default_storage_engine=CSV
```

在创建表的时候，对表设置存储引擎，例如：

```sql
CREATE TABLE `user` (
  `id`     int(100) unsigned NOT NULL AUTO_INCREMENT,
  `name`   varchar(32) NOT NULL DEFAULT '' COMMENT '姓名',
  `mobile` varchar(20) NOT NULL DEFAULT '' COMMENT '手机',
  PRIMARY KEY (`id`)
)ENGINE=InnoDB;
```

在创建用户表 user 的时候，SQL语句最后 ENGINE=InnoDB 就是设置这张表存储引擎为 InnoDB。

## 如何选择合适的存储引擎

​	提供几个选择标准，然后按照标准，选择对应的存储引擎即可，也可以根据[常用引擎对比](https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%B8%B8%E7%94%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94)来选择你使用的存储引擎。使用哪种引擎需要根据需求灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。

1. 是否需要支持事务；
2. 是否需要使用热备；
3. 崩溃恢复，能否接受崩溃；
4. 是否需要外键支持；
5. 存储的限制；
6. 对索引和缓存的支持；

## 目前，MySQL 默认的存储引擎是 InnoDB ，并且也是最主流的选择。主要原因如下：

- 【最重要】支持事务。
- 支持行级锁和表级锁，能支持更多的并发量。
- 查询不加锁，完全不影响查询。
- 支持崩溃后恢复。

在 MySQL5.1 以及之前的版本，默认的存储引擎是 MyISAM ，但是目前已经不再更新，且它有几个比较关键的缺点：

- 不支持事务。
- 使用表级锁，如果数据量大，一个插入操作锁定表后，其他请求都将阻塞。

# 二、索引

​	索引，类似于书籍的目录，想找到一本书的某个特定的主题，需要先找到书的目录，定位对应的页码。

MySQL 中存储引擎使用类似的方式进行查询，先去索引中查找对应的值，然后根据匹配的索引找到对应的数据行。

### 1.2、**索引的好处**

1. **提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。**
2. 降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则正好降低了排序的成本。
3. 大大减少服务器需要扫描的数据量。
4. 帮助服务器避免排序和临时表。
5. 将随机I/O变顺序I/O。
6. 大大提高查询速度

### 1.3、**索引的坏处**

1. 占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。
2. 降低更新表(即写)的速度：**表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。**

### 1.4、**索引的使用场景**

- 1、对非常小的表，大部分情况下全表扫描效率更高。

- 2、对中大型表，索引非常有效。

- 3、特大型的表，建立和使用索引的代价随着增长，可以使用分区技术来解决。

  > 实际场景下，MySQL 分区表很少使用，原因可以看看 [《互联网公司为啥不使用 MySQL 分区表？》](https://blog.csdn.net/admin1973/article/details/55504018) 文章。
  >
  > 对于特大型的表，更常用的是**“分库分表”**，目前解决方案有 Sharding Sphere、MyCAT 等等。

### 1.5、**索引的类型**

**==索引，都是实现在存储引擎层的。主要有六种类型：==**

- 1、普通索引：最基本的索引，没有任何约束。

  ```sql
  ALTER TABLE 'table_name' ADD INDEX index_name('col')；
  ```

- 2、唯一索引：与普通索引类似，但具有唯一性约束，允许空值。

  ```sql
  ALTER TABLE 'table_name' ADD UNIQUE('col')；
  ```

- 3、主键索引：特殊的唯一索引，**不允许重复，不允许有空值**。

  - ```sql
    ALTER TABLE 'table_name' ADD PRIMARY KEY('col')；
    ```

- 4、复合(组合)索引：将多个列组合在一起创建索引，可以覆盖多个列，这多个列不允许有空值。

  ```sql
  ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')；
  ```

- **5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。**

- 6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎。

  ```sql
  ALTER TABLE 'table_name' ADD FULLTEXT('col')；
  ```

  > 常用的全文索引引擎的解决方案有 Elasticsearch、Solr 等等。最为常用的是 Elasticsearch 。

#### 遵循“最左前缀”原则

​	**把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。**

​	在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引。

```sql
ALTER TABLE 'table_name' ADD INDEX index_name(col1(4),col2（3))；
```

​	**表示使用col1的前4个字符和col2的前3个字符作为索引**

具体的使用，可以看看 [《服务端指南 数据存储篇 | MySQL（03） 如何设计索引》](http://blog.720ui.com/2017/mysql_core_03_how_use_index/) 。

### 1.6、**MySQL 索引的“创建”原则**

- 1、**最适合索引的列是出现在 `WHERE或ON` 子句中的列，或连接子句中的列，而不是出现在 `SELECT` 关键字后的列。**

- 2、==索引列的基数越大，数据区分度越高，索引效果越好。==

  > 参照：
  >
  > - [《MySQL 索引基数》](https://blog.csdn.net/mingyundezuoan/article/details/79038989) 理解相对简单
  > - [《低基数索引为什么会对性能产生负面影响》](https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1309cardinal/index.html) 写的更原理，所以较为难懂。

- 3、根据情况创建复合索引，复合索引可以提高查询效率。

  > 因为复合索引的基数会更大。

- 4、避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。

- 5、主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率。

- 6、对字符串进行索引，应该定制一个前缀长度，可以节省大量的索引空间。

### 1.7、**MySQL 索引的“使用”注意事项**

- 1、应尽量避免在 `WHERE` 子句中使用 `!=` 或 `<>` 操作符，**否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。**

  > 注意，`column IS NULL` 也是不可以使用索引的。

- 2、应尽量避免在 `WHERE` 子句中使用 `OR` 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：`SELECT id FROM t WHERE num = 10 OR num = 20` 。

- 3、应尽量避免在 `WHERE` 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

- 4、应尽量避免在 `WHERE` 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。

- 5、不要在 `WHERE` 子句中的 `=` 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

- 6、复合索引遵循前缀原则。

- 7、如果 MySQL 评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中添加强制索引。

- 8、**列类型是字符串类型，查询时一定要给值加引号，否则索引失效。**

- 9、`LIKE` 查询，`%` 不能在前，因为无法使用索引。如果需要模糊匹配，可以使用外部的ElasticSearch、Lucene等全文搜索引擎替代。

- 10、列值为空（NULL）时是可以使用索引的，但MySQL难以优化引用了可空列的查询,它会使索引、索引统计和值更加复杂。可空列需要更多的储存空间，还需要在MySQL内部进行特殊处理。

关于这块，可以看看 [《服务端指南 数据存储篇 | MySQL（04） 索引使用的注意事项》](http://blog.720ui.com/2017/mysql_core_04_index_item/) 文章，写的更加细致。

#### 1.7.1、**以下三条 SQL 如何建索引，只建一条怎么建？**

```
WHERE a = 1 AND b = 1
WHERE b = 1
WHERE b = 1 ORDER BY time DESC
```

- 以顺序 b , a, time 建立复合索引，`CREATE INDEX table1_b_a_time ON index_test01(b, a, time)`。
- 对于第一条 SQL ，因为最新 MySQL 版本会优化 `WHERE` 子句后面的列顺序，以匹配复合索引顺序。

### 1.8、**查看一个查询用到哪个索引**

​	`EXPLAIN` 显示了 MYSQL 如何使用索引来处理 SELECT 语句以及连接表,可以帮助选择更好的索引和写出更优化的查询语句。

使用方法，在 `SELECT` 语句前加上 `EXPLAIN` 就可以了。参照 [《MySQL explain 执行计划详细解释》](http://www.jfox.info/2017/mysql-explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A.html) 。

## 2、MySQL中索引的语法

#### 在创建表的时候添加索引

```sql
CREATE TABLE tablename(
id INT(10) PRIMARY KEY,
content TEXT,
name CHAR(10) NOT NULL, 
[UNIQUE] INDEX name_index (name(4)))ENGION MyISAM DEFAULT CHARSE utf8;
```

#### 在创建表以后添加索引

```sql
ALTER table my_table ADD [UNIQUE] INDEX my_index(my_text);
CREATE INDEX my_index ON my_table(my_text);
```

```sql
首先创建一个表：create table t1 (id int primary key,username varchar(20),password varchar(20));
创建单个索引的语法：CREATE INDEX 索引名 on 表名（字段名）
索引名一般是：表名_字段名
给id创建索引：CREATE INDEX t1_id on t1(id);
创建联合索引的语法：CREATE INDEX 索引名 on 表名（字段名1，字段名2）
给username和password创建联合索引：CREATE index t1_username_password ON t1(username,password)
其中index还可以替换成unique，primary key，分别代表唯一索引和主键索引
删除索引：DROP INDEX t1_username_password ON t1
```

#### 根据索引查询

```sql
SELECT * FROM tablename WHERE MATCH(content) AGAINST('word1','word2',...);
```

#### 删除索引

```sql
DROP index my_index ON tablename；
```

#### 查看表中的索引

```sql
SHOW INDEX FROM tablename
```

## 3、索引的原理

​	MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等等。

### 1、哈希索引：

​	只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，**因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。**

### 2、全文索引：

​	==FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB==，针对较大的数据，生成全文索引非常的消耗时间和空间。**对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用 LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。**FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：

```sql
//创建表的时候添加FULLTEXT索引
CTREATE TABLE my_table(
id INT(10) PRIMARY KEY,
name VARCHAR(10) NOT NULL,
my_text text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
FULLTEXT(my_text));
```

```sql
//创建表以后，在需要的时候添加FULLTEXT索引
ALTER my_table ADD FULLTEXT ft_index(my_text);
CREATE INDEX ft_index ON my_table(my_text);
```

- 对于较大的数据集，把数据添加到一个没有FULLTEXT索引的表，然后添加FULLTEXT索引的速度比把数据添加到一个已经有FULLTEXT索引的表快。
- **MySQL自带的全文索引只能用于MyISAM存储引擎，如果是其它数据引擎，那么全文索引不会生效。**
- ==在MySQL中，全文索引只对英文有用，目前对中文还不支持。==
- 在MySQL中，如果检索的字符串太短则无法检索得到预期的结果，**检索的字符串长度至少为4字节**，此外，如果检索的字符包括停止词，那么停止词会被忽略。

### 3、平衡多路查找树B-Tree索引和B+Tree索引

#### B-Tree

​	==B-Tree是为磁盘等外存储设备(如磁盘等)设计的一种平衡查找树。==因此在讲B-Tree之前先了解下磁盘的相关知识。

​	**系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。**

​	**InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。**InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：

```sql
mysql> show variables like 'innodb_page_size';
```


​	而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。**InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。**

​	B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，==key为记录的键值，对应表中的主键值，data为数据库中一行记录中除主键外的数据==。对于不同的记录，key值互不相同。

##### 一棵m阶的B-Tree有如下特性： 

1. 每个节点最多有m个孩子。 
   1. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
   2. 若根节点不是叶子节点，则至少有2个孩子 
2. 所有叶子节点都在同一层，且不包含其它关键字信息 
3. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
4. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
5. ki(i=1,…n)为关键字，且关键字升序排序。 
6. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree： ![ç´¢å¼](/Users/jack/Desktop/md/images/20160202204827368.png)


​	每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字key和三个指向子树根节点的指针，**指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域**。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

模拟查找关键字29的过程：

> 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
> 比较关键字29在区间（17,35），找到磁盘块1的指针P2。
> 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
> 比较关键字29在区间（26,30），找到磁盘块3的指针P2。
> 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
> 在磁盘块8中的关键字列表中找到关键字29。

​	分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。**由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。**

#### B+Tree

​	B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

​	从上面的B-Tree结构图中可以看到**每个节点中不仅包含数据的key值，还有data值。**而每一个页的存储空间是有限的，**如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，==当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。==**

​	==在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。==

##### B+Tree相对于B-Tree有几点不同：

- 非叶子节点只存储键值信息。
- 所有叶子节点之间都有一个链指针。
- 数据记录都存放在叶子节点中。

​	将上面的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 

![ç´¢å¼](/Users/jack/Desktop/md/images/20160202205105560.png)


​	==通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。==

> 可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：
>
> ​	InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，**也就是说一个页（B+Tree中的一个节点）**中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。
>

​	实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

​	**数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。**上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。==当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。==

### 主索引(也称聚集索引)与辅助索引

​	聚集索引可以说是按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对这堆记录 进行 堆划分。即主要描述的是物理上的存储。

​	首先要介绍几个概念，**在索引的分类中，我们可以按照索引的键是否为主键来分为“主索引”和“辅助索引”，使用主键键值建立的索引称为“主索引”，其它的称为“辅助索引”。因此主索引只能有一个，辅助索引可以有很多个。**

​	==辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。==当通过辅助索引来查询数据时，需要进过两步：

- 首先，InnoDB 存储引擎会遍历辅助索引找到主键。
- 然后，再通过主键在聚集索引中找到完整的行记录数据。

另外，InnoDB 通过主键聚簇数据，如果没有定义主键，会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个主键作为聚簇索引。

### 4、MyISAM——非聚簇索引

​	非聚集索引强调的是逻辑分类。可以说是定义了一套存储规则，而需要有一块控件来维护这个规则，这个被称之为索引表。

- MyISAM存储引擎采用的是非聚簇索引，非聚簇索引的主索引和辅助索引几乎是一样的，只是主索引不允许重复，不允许空值，**他们的叶子结点的key都存储指向键值对应的数据的物理地址。**
- 非聚簇索引的数据表和索引表是分开存储的。
- **非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。**
- ==只有在MyISAM中才能使用FULLTEXT索引。==

#### **聚簇索引的注意点有哪些？**

聚簇索引表最大限度地提高了 I/O 密集型应用的性能，但它也有以下几个限制：

- 1、插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。

  > 关于这一点，可能面试官会换一个问法。例如，为什么主键需要是自增 ID ，又或者为什么主键需要带有时间性关联。

- 2、更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB 表，我们一般定义主键为不可更新。

  > MySQL 默认情况下，主键是允许更新的。对于 MongoDB ，其 主键是不允许更新的。

- 3、二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

  > 当然，有一种情况可以无需二次查找，基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。

- 4、**主键 ID 建议使用整型。**因为，每个主键索引的 B+Tree 节点的键值可以存储更多主键 ID ，每个非主键索引的 B+Tree 节点的数据可以存储更多主键 ID 。

### 5、InnoDB——聚簇索引

- 聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。因此主键的值长度越小越好，类型越简单越好。
- 聚簇索引的数据和主键索引存储在一起。
- **聚簇索引的数据是根据主键的顺序保存。因此适合按主键索引的区间查找，可以有更少的磁盘I/O，加快查询速度。但是也是因为这个原因，聚簇索引的插入顺序最好按照主键单调的顺序插入，否则会频繁的引起页分裂，严重影响性能。**
- 在InnoDB中，如果只需要查找索引的列，就尽量不要加入其它的列，这样会提高查询效率。

​	==使用主索引的时候，更适合使用聚簇索引，因为聚簇索引只需要查找一次，而非聚簇索引在查到数据的地址后，还要进行一次I/O查找数据。==

​	因为聚簇辅助索引存储的是主键的键值，因此可以在数据行移动或者页分裂的时候降低维护成本，因为这时不用维护辅助索引。但是辅助索引会占用更多的空间。

​	**聚簇索引在插入新数据的时候比非聚簇索引慢很多，因为插入新数据时需要检查主键是否重复，这需要遍历主索引的所有叶节点，而非聚簇索引的叶节点保存的是数据地址，占用空间少，因此分布集中，查询的时候I/O更少，但聚簇索引的主索引中存储的是数据本身，数据占用空间大，分布范围更大，可能占用好多的扇区，因此需要更多次I/O才能遍历完毕。**

下图可以形象的说明聚簇索引和非聚簇索引的区别：

![img](/Users/jack/Desktop/md/images/20180411154851675.jpeg)

## 4、索引的使用策略

### 4.1 什么时候要使用索引？

- 主键自动建立唯一索引；
- 经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引；
- 作为排序的列要建立索引；
- 查询中与其他表关联的字段，外键关系建立索引
- 高并发条件下倾向组合索引；

### 4.2 什么时候不要使用索引？

- 经常增删改的列不要建立索引(因为每次列的更新)；
- 有大量重复的列不建立索引；
- 表记录太少不要建立索引；

### 4.3 索引失效的地方

- 在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的；
- 在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了；
- LIKE操作中，'%aaa%'不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引；
- **在索引的列上使用表达式或者函数会使索引失效**，例如：select * from users where YEAR(adddate)<2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select * from users where adddate<’2007-01-01′。
- **在查询条件中使用正则表达式时，只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。**
- 在查询条件中使用<>会导致索引失效。
- 在查询条件中使用IS NULL会导致索引失效。
- 在查询条件中使用OR连接多个条件会导致索引失效，这时应该改为两次查询，然后用UNION ALL连接起来。
- 尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引；

​	只有当数据库里已经有了足够多的测试数据时，它的性能测试结果才有实际参考价值。如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快--不管有没有使用索引。只有当数据库里的记录超过了1000条、数据总量也超过了MySQL服务器上的内存总量时，数据库的性能测试结果才有意义。

## 5、索引的优化

### 1、最左前缀

​	索引的最左前缀和B+Tree中的“最左前缀原理”有关，举例来说就是如果设置了组合索引<col1,col2,col3>那么以下3中情况可以使用索引：col1，<col1,col2>，<col1,col2,col3>，其它的列，比如<col2,col3>，<col1,col3>，col2，col3等等都是不能使用索引的。

根据最左前缀原则，我们一般把排序分组频率最高的列放在最左边，以此类推。

### 2、带索引的模糊查询优化

​	在上面已经提到，使用LIKE进行模糊查询的时候，'%aaa%'不会使用索引，也就是索引会失效。如果是这种情况，只能使用全文索引来进行优化（上文有讲到）。

为检索的条件构建全文索引，然后使用

```sql
SELECT * FROM tablename MATCH(index_colum) ANGAINST(‘word’);
```

参照：

- [《MySQL 索引原理》](https://blog.csdn.net/u013235478/article/details/50625677)
- [《深入理解 MySQL 索引原理和实现 —— 为什么索引可以加速查询？》](https://blog.csdn.net/tongdanping/article/details/79878302)

## 6、**索引的最左匹配特性**

当 B+Tree 的数据项是复合的数据结构，比如索引 `(name, age, sex)` 的时候，B+Tree 是按照从左到右的顺序来建立搜索树的。

- 比如当 `(张三, 20, F)` 这样的数据来检索的时候，B+Tree 会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex ，最后得到检索的数据。
- 但当 `(20, F)` 这样的没有 name 的数据来的时候，B+Tree 就不知道下一步该查哪个节点，**因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。**
- 比如当 `(张三, F)` 这样的数据来检索时，B+Tree 可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了。

这个是非常重要的性质，即索引的最左匹配特性。

## 7、 **MyISAM 索引与 InnoDB 索引的区别**

- InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。

- **InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。**

- **MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。**

- **InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。**

  > 覆盖索引，指的是基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。

# 三、MySQL 的四种事务隔离级别

​	**事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。**==这样可以防止出现脏数据，防止数据库数据出现问题。==

## 1.**事务的特性**

指的是 **ACID** ，如下图所示：

![事务的特性](/Users/jack/Desktop/md/images/06.png)

1. **原子性** Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。**事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。**
2. **一致性** Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。**这表示写入的资料必须完全符合所有的预设[约束](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7)、[触发器](https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93))、[级联回滚](https://zh.wikipedia.org/w/index.php?title=%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A&action=edit&redlink=1)等。**
3. **隔离性** Isolation ：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致**。**比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。**
   1. ==事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。==
4. **持久性** Durability ：事务处理结束后，**对数据的修改就是永久的，即便系统故障也不会丢失**。

## 2.**事务的并发问题**

**实际场景下，事务并不是串行的，所以会带来如下三个问题：**

- 1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。
- 2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。
- 3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。**是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。**

总结：==不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。==(因为不可重复读只是修改了一条记录，相当于修改了一行数据，所以锁住一行即可；而幻读是新增/删除数据，不能确定是新增/删除哪一条数据，所以需要锁住整个表。)

### 2.1MySQL 事务隔离级别会产生的并发问题

事务定义了==四种事务隔离级别==，不同数据库在实现时，产生的并发问题是不同的。

> 不同的隔离级别有不同的现象，并有不同的锁定/并发机制，**隔离级别越高，数据库的并发性就越差。**

- ==READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的。==

  > 会导致脏读，读到其他事务还没提交的数据。
  >
  > - 出现脏读的本质就是因为**操作(修改)完该数据就立马释放掉锁**，导致读的数据就变成了无用的或者是**错误的数据**。即修改完数据之后还未提交事务，然后进行了回滚。

- ==READ COMMITTED（提交读）：事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。==

  > 会导致不可重复读，因为这个事务看不到别的事务进行数据记录的修改。
  >
  > 这个隔离级别，也可以叫做“不可重复读”。
  >
  > **一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改**
  >
  > - 把**释放锁的位置调整到事务提交之后**，此时在事务提交前，其他进程是无法对该行数据进行读取的，包括任何操作。
  > - **语句级别**的快照！**每次读取的都是当前最新的版本**！![image-20190329092524607](/Users/jack/Desktop/md/images/image-20190329092524607.png)

- ==REPEATABLE READ（可重复读）：一个事务按相同的查询条件读取以前检索过的数据，其他事务插入了满足其查询条件的新数据。产生幻行。==

  > 会导致幻读。**可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。**
  >
  > **事务级别的快照！每次读取的都是当前事务的版本，即使被修改了，也只会读取当前事务版本的数据。**

- ==SERIALIZABLE（可串行化）：**强制事务串行执行**。==

MySQL InnoDB 采用 **MVCC** 来支持高并发，实现结果如下表所示：

> 关于 Oracle 和 PostgreSQL 可能不大一样。

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读    |
| ---------------------------- | ---- | ---------- | ------- |
| 读未提交（read-uncommitted） | 是   | 是         | 是      |
| 读已提交（read-committed）   | 否   | 是         | 是      |
| 可重复读（repeatable-read）  | 否   | 否         | 是（x） |
| 串行化（serializable）       | 否   | 否         | 否      |

- ==MySQL 默认的事务隔离级别为可重复读（repeatable-read）== 。

- 上图的 `<X>` 处，MySQL 因为其间隙锁的特性，导致其在可重复读（repeatable-read）的隔离级别下，不存在幻读问题。也就是说，上图 `<X>` 处，需要改成“否”！！！！

- 具体的实验，可以看看 [《MySQL 的四种事务隔离级别》](https://www.cnblogs.com/huanongying/p/7021555.html) 。

- 有些资料说可重复读解决了幻读，实际是存在的，可以通过 `SELECT xxx FROM t WHERE id = ? FOR UPDATE` 的方式，获得到悲观锁，禁止其它事务操作对应的数据，从而解决幻读问题。可以看看如下文章：

  - 必读 [《MySQL 幻读的详解、实例及解决办法》](https://segmentfault.com/a/1190000016566788) 案例性更强，易懂。

    > 其实 可重复读也是可以避免幻读的，通过对 select 操作手动加 行X锁（SELECT … FOR UPDATE 这也正是 SERIALIZABLE 隔离级别下会隐式为你做的事情），同时还需要知道，即便当前记录不存在，比如 id = 1 是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加 行X锁，不存在就加 next-key lock间隙X锁），其他事务则无法插入此索引的记录，故杜绝了幻读。

  - 选读 [《MySQL 的 InnoDB 的幻读问题》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html) 原理性更强，读懂会很爽。

  - 随意 [《Innodb 中 RR 隔离级别能否防止幻读？》](https://github.com/Yhzhtk/note/issues/42) 一个简单的讨论。

注意：

**1、事务隔离级别为读提交时，写数据只会锁住相应的行**

**2、事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。**

**3、事务隔离级别为串行化时，读写数据都会锁住整张表**

**4、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。**

**5、MYSQL MVCC实现机制参考链接：https://blog.csdn.net/whoamiyang/article/details/51901888**

**6、关于next-key 锁可以参考链接：https://blog.csdn.net/bigtree_3721/article/details/73731377**

# 四、MySQL的锁机制

​	表锁是日常开发中的常见问题，因此也是面试当中最常见的考察点，当多个查询同一时刻进行数据修改时，就会产生并发控制的问题。**MySQL 的共享锁和排他锁，就是读锁和写锁。**

- **共享锁：不堵塞，多个用户可以同时读一个资源，互不干扰。**
- **排他锁：一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。**

## 1.**锁的粒度**

- 表锁：系统开销最小，会锁定整张表，MyIsam 使用表锁。
- 行锁：最大程度的支持并发处理，但是也带来了最大的锁开销，InnoDB 使用行锁。

> ​	==只有在你增删改查时匹配的条件字段带有索引时，innodb才会使用行级锁，在你增删改查时匹配的条件字段不带有索引时，innodb使用的将是表级锁。==
>
> ​	因为当你匹配条件字段不带有索引时，数据库会全表查询，所以这需要将整张表加锁,才能保证查询匹配的正确性。在生产环境中我们往往需要满足多人同时对一张表进行增删改查，所以就需要使用行级锁，所以这个时候一定要记住为匹配条件字段加索引。
>
> ​	提到行级锁和表级锁时我们就很容易联想到读锁和写锁，因为只有触发了读写锁，我们才会谈是进行行级锁定还是进行表级锁定。==用select 命令时触发读锁，使用update,delete,insert时触发写锁，并且使用rollback或commit后解除本次锁定。==

### 1.1 表级锁和行级锁可以进一步划分为共享锁（s）和排他锁（X）。

#### 共享锁（s）

​	共享锁（Share Locks，简记为S）又被称为读锁，其他用户可以并发读取数据，**但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。**

​	共享锁(S锁)又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

#### 排他锁（X）：

​	**排它锁(Exclusive lock,简记为X锁)又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。**它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。

#### 两者之间的区别：

​	共享锁（S锁）：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。**获取共享锁的事务只能读数据，不能修改数据。**

​	排他锁（X锁）：如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获取排他锁的事务既能读数据，又能修改数据。

在默认的情况下，==`select`是不加任何行锁的~事务可以通过以下语句显示给记录集加共享锁或排他锁。==

- 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`。
- 排他锁（X)：`SELECT * FROM table_name WHERE ... FOR UPDATE`。

for update表示加上了排它锁

参照：https://juejin.im/post/5b55b842f265da0f9e589e79

### 1.2 另外两个表级锁：IS和IX

​	**当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。**但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而**意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。**而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。==意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。==

#### InnoDB另外的两个表级锁：

意向共享锁（IS）：表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。

意向排他锁（IX）：表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。

##### 注意：

- 这里的**意向锁是表级锁**，表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行锁时才会判断是否冲突。**意向锁是InnoDB自动加的，不需要用户干预。**

- IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。

  InnoDB的锁机制兼容情况如下： 

  ![InnoDBçéæºå¶å¼å®¹æåµ](/Users/jack/Desktop/md/images/163da3105cb54186.png)

当一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之如果请求不兼容，则该事物就等待锁释放。

##  2.**悲观锁和乐观锁**

### 1）悲观锁

​	它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，**因此，==在整个数据处理过程中，将数据处于锁定状态。==**悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

​	**在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。**读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。

> 悲观锁，就是我们上面看到的共享锁和排他锁。

### 2）乐观锁

​	相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。**但随之而来的就是数据库性能的大量开销，**特别是对长事务而言，这样的开销往往无法承受。

​	而乐观锁机制在一定程度上解决了这个问题。**乐观锁，大多是基于数据版本（ Version ）记录机制实现。**即为数据增加一个版本标识，在基于数据库表的版本解决方案中，**一般是通过为数据库表增加一个 “version” 字段来实现。**读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

> 乐观锁，实际就是通过版本号，从而实现 CAS 原子性更新。

## 3、死锁

​	多数情况下，可以认为如果一个资源被锁定，它总会在以后某个时间被释放。**而死锁发生在当多个进程访问同一数据库时，其中每个进程拥有的锁都是其他进程所需的，由此造成每个进程都无法继续下去。简单的说，进程 A 等待进程 B 释放他的资源，B 又等待 A 释放他的资源，这样就互相等待就形成死锁。**

​	虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，==死锁的发生必须具备以下四个必要条件==：

- 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
- 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。(要别人的，自己的又没放出来)
- **不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。**
- 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合 {P0，P1，P2，•••，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。

### 下列方法有助于最大限度地降低死锁：

- 设置获得锁的超时时间。

  > 通过超时，至少保证最差最差最差情况下，可以有退出的口子。

- 按同一顺序访问对象。

  > 这个是最重要的方式。

- **避免事务中的用户交互。**

- 保持事务简短并在一个批处理中。

- 使用低隔离级别。

- 使用绑定连接。

## 4、**MySQL 中 InnoDB 引擎的行锁**

==InnoDB 是基于索引来完成行锁。==例如：`SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE` 。

- `FOR UPDATE` 可以根据条件来完成**行锁**锁定，并且 id 是有索引键的列,如果 id 不是索引键那么 InnoDB 将完成**表锁**，并发将无从谈起。

​	==InnoDB**基于行锁**还实现了MVCC多版本并发控制，MVCC在隔离级别下的`Read committed`和`Repeatable read`下工作。MVCC能够实现**读写不阻塞**！==

## 5、 **关于熟悉 MySQL 的锁机制**

- Innodb 的行锁(下面的几种锁都是排它锁)

  > ​	Mysql中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种。
  >
  > 1. Record Lock: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。
  >
  > 2. Gap Lock:对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。锁定索引之间的间隙，但是不包含索引本身。
  >
  >    > 例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。
  >    >
  >    > ```sql
  >    > SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
  >    > ```
  >
  > 3. Next-key Lock：  锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。==使用 MVCC + Next-Key Locks 可以解决幻读问题。==
  >
  > **Innodb 的锁的策略为 next-key 锁，即 record lock + gap lock ，是通过在 index 上加 lock 实现的。**
  >
  > - 如果 index 为 unique index ，则降级为 record lock 行锁。
  > - 如果是普通 index ，则为 next-key lock 。
  > - 如果没有 index ，则直接锁住全表，即表锁。

- MyISAM 的表锁

  > MyISAM 直接使用表锁。
  >
  > ​	Mysql中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单 **，资源消耗也比较少，加锁快，不会出现死锁** 。==其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。==

#### 间隙锁GAP

​	当我们**用范围条件检索数据**而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给**符合范围条件的已有数据记录的索引项加锁**；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。

值得注意的是：==间隙锁只会在`Repeatable read`隔离级别下使用==

例子：假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101

```sql
select * from  emp where empid > 100 for update;
```

上面是一个范围查询，InnoDB**不仅**会对符合条件的empid值为101的记录加锁，也会对**empid大于101（这些记录并不存在）的“间隙”加锁**。

InnoDB使用间隙锁的目的有两个：

- **为了防止幻读**(上面也说了，`Repeatable read`隔离级别下再通过GAP锁即可避免了幻读)
- 满足恢复和复制的需要
  - MySQL的恢复机制要求：**在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读**

<https://juejin.im/post/5b55b842f265da0f9e589e79#heading-5>

#### 虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的：

- 事务更新大表中的大部分数据直接使用表级锁效率更高；
- 事务比较复杂，使用行级索很可能引起死锁导致回滚。

# 五、MySQL 查询执行顺序

## MySQL 查询执行的顺序是：

```
(1)     SELECT
(2)     DISTINCT <select_list>
(3)     FROM <left_table>
(4)     <join_type> JOIN <right_table>
(5)     ON <join_condition>
(6)     WHERE <where_condition>
(7)     GROUP BY <group_by_list>
(8)     HAVING <having_condition>
(9)     ORDER BY <order_by_condition>
(10)    LIMIT <limit_number>
```

## 标准的 SQL 的解析顺序为:

 (1) FROM 子句 组装来自不同数据源的数据

 (2) WHERE 子句 基于指定的条件对记录进行筛选

 (3) GROUP BY 子句 将数据划分为多个分组 

 (4) 使用聚合函数进行计算

 (5) 使用HAVING子句筛选分组

 (6) 计算所有的表达式

 (7) 使用ORDER BY对结果集进行排序

##  执行顺序

1. FROM：对FROM子句中前两个表执行笛卡尔积生成虚拟表vt1

2. ON: 对vt1表应用ON筛选器只有满足 join_condition 为真的行才被插入vt2

3. OUTER(join)：如果指定了 OUTER JOIN保留表(preserved table)中未找到的行将行作为外部行添加到vt2，生成t3，如果from包含两个以上表，则对上一个联结生成的结果表和下一个表重复执行步骤和步骤直接结束。

4. WHERE：对vt3应用 WHERE 筛选器只有使 where_condition 为true的行才被插入vt4

5. GROUP BY：按GROUP BY子句中的列列表对vt4中的行分组生成vt5

6. CUBE|ROLLUP：把超组(supergroups)插入vt6，生成vt6

7. HAVING：对vt6应用HAVING筛选器只有使 having_condition 为true的组才插入vt7

8. SELECT：处理select列表产生vt

9. DISTINCT：将重复的行从vt8中去除产生vt9

10. ORDER BY：将vt9的行按order by子句中的列列表排序生成一个游标vc10

11. TOP：从vc10的开始处选择指定数量或比例的行生成vt11 并返回调用者

参照<https://www.cnblogs.com/huminxxl/p/3149097.html>

# 六、MVCC

## 1.简介

​	多版本并发控制（MVCC），是一种用来**解决读-写冲突**的无锁并发控制，也就是为事务分配单向增长的时间戳，**为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。** 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。

​	如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题，叫做并发控制方法。最简单的方法，通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。==MVCC 使用了一种不同的手段，每个连接到数据库的读者，**在某个瞬间看到的是数据库的一个快照**，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。==

​	当一个 MVCC 数据库需要更一个一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是**将旧数据标记为过时（obsolete）,并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。**这种方式允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。这种多版本的方式避免了填充删除操作在内存和磁盘存储结构造成的空洞的开销，但是需要系统周期性整理（sweep through）以删除老的、过时的数据。对于面向文档的数据库（Document-oriented database，也即半结构化数据库）来说，这种方式允许系统将整个文档写到磁盘的一块连续区域上，当需要更新的时候，直接重写一个版本，而不是对文档的某些比特位、分片切除，或者维护一个链式的、非连续的数据库结构。

​	MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用`时间戳`或者`事务 ID`去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据。

​	一句话讲，MVCC就是用 **同一份数据临时保留多版本的方式** 的方式，实现并发控制。

### 这里留意到 MVCC 关键的两个点：

1. 在读写并发的过程中如何实现多版本；
2. 在读写并发之后，如何实现旧版本的删除（毕竟很多时候只需要一份最新版的数据就够了）；

## 2.MVCC的实现

**MVCC 使用时间戳（TS）、递增的事务 ID（T）实现事务一致性。**

​	==MVCC 通过维护多版本数据，保证一个读事务永远不会被阻塞。==**对象 P 维护有多个版本，每个版本会有一个读时间戳（Read TimeStamp, RTS）和 写时间戳（Write TimeStamp, WTS），事务 Ti 读对象 P 的最新版本，该版本早于事务 Ti 的读时间戳 RTS(Ti)。**

​	事务 Ti 要对 P 执行写操作，如果有其他事务 Tk 同时对 P 操作，则 RTS(Ti）必须要早于 RTS(Tk)，即有 RTS(Ti) < RTS(Tk)，这样对 Ti 对 P 的写操作才能完成。**一般地，如果其他事务拥有 P 的一个更早的读时间戳的情况下，写操作是不能完成的。**打个比方就是在存储前面有一道线，只有等你前面的人的完成了他们的事务，你的修改事务才可以提交完成。

​	重复说一下：==每个对象 P 有一个时间戳 TS，如果事务 Ti 想要对 P 执行写操作，（写要先读）事务的读时间戳是 RTS(Ti)，如果有其他事务拥有一个比较早的时间戳，有 TS(P) < RTS(Ti)，这时事务 Ti 会退出并重新开始。否则，事务 Ti 创建一个 P 的新版本，并设置新版本 P 的时间戳，似的 TS = TS(Ti)。==

​	**MVCC 系统明显的缺点是会存储多个版本数据的冗余开销。但同时，读操作永不会被阻塞，这对那些以读操作为主的数据库来说非常重要。**MVCC 实现了真的快照隔离（snapshot isolation），然后其他的并发控制方法要么是不完整的快照隔离方式，要么需要较高的性能损耗。

> Wikipedia 中的内容有点繁琐，简单地，上面的描述，阐明了在同一数据版本下写操作的限制，已经通过多版本实现快照隔离的优越性。

参照：<https://www.cnblogs.com/YFYkuner/p/5178684.html>

## 3.具体实现原理

​	**Innodb MVCC主要是为Repeatable-Read事务隔离级别做的。在此隔离级别下，A、B客户端所示的数据相互隔离，互相更新不可见。**

了解Innodb的行结构、Read-View的结构对于理解innodb mvcc的实现由重要意义

==Innodb存储的最基本row中包含一些额外的存储信息 DATA_TRX_ID，DATA_ROLL_PTR，DB_ROW_ID，DELETE BIT==

- **6字节的DATA_TRX_ID 标记了最新更新这条行记录的transaction id，每处理一个事务，其值自动+1**
- **7字节的DATA_ROLL_PTR 指向当前记录项的rollback segment的undo log记录，找之前版本的数据就是通过这个指针**
- 6字节的DB_ROW_ID，当由Innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，否则聚集索引中不包括这个值.，这个用于索引当中
- DELETE BIT位用于标识该记录是否被删除，这里的不是真正的删除数据，而是标志出来的删除。真正意义的删除是在commit的时候

![img](/Users/jack/Desktop/md/images/268981-20151221230743968-739828690.png)

### 具体的执行过程

==begin->用排他锁锁定该行->记录redo log->记录undo log->修改当前行的值，写事务编号，回滚指针指向undo log中的修改前的行==

​	上述过程确切地说是描述了UPDATE的事务过程，其实**undo log分insert和update undo log，因为insert时，原始的数据并不存在，所以回滚时把insert undo log丢弃即可，而update undo log则必须遵守上述过程**

#### 下面分别以select、delete、 insert、 update语句来说明

##### **SELECT**

Innodb检查每行数据，确保他们符合两个标准：

1、**InnoDB只查找版本早于当前事务版本的数据行(也就是数据行的版本必须小于等于事务的版本)，这确保当前事务读取的行都是事务之前已经存在的，或者是由当前事务创建或修改的行。**

2、行的删除操作的版本一定是未定义的或者大于当前事务的版本号，确定了当前事务开始之前，行没有**被删除**

符合了以上两点则返回查询结果。

##### **INSERT**

InnoDB为每个新增行记录当前系统版本号作为创建ID。

##### **DELETE**

InnoDB为每个删除行的记录当前系统版本号作为行的删除ID。

##### **UPDATE**

InnoDB复制了一行。这个新行的版本号使用了系统版本号。它也把系统版本号作为了删除行的版本。

#### 说明

insert操作时 “创建时间”=DB_ROW_ID，这时，“删除时间 ”是未定义的；

update时，复制新增行的“创建时间”=DB_ROW_ID，删除时间未定义，旧数据行“创建时间”不变，删除时间=该事务的DB_ROW_ID；

delete操作，相应数据行的“创建时间”不变，删除时间=该事务的DB_ROW_ID；

select操作对两者都不修改，只读相应的数据

## 4.MVCC的总结

​	上述更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，**undo log中的行就是MVCC中的多版本，**这个可能与我们所理解的MVCC有较大的出入，一般我们认为MVCC有下面几个特点：

- 每行数据都存在一个版本，每次数据更新时都更新该版本
- 修改时Copy出当前版本随意修改，各个事务之间无干扰
- **保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）**

==就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道，而Innodb的实现方式是==：

- **事务以排他锁的形式修改原始数据**
- **把修改前的数据存放于undo log，通过回滚指针与主数据关联**
- **修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）**

二者最本质的区别是，当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？ 

Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。 

比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。

​	理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。

参照：<https://www.cnblogs.com/chenpingzhao/p/5065316.html>

# 七、常用sql

## **1.如何查询第n高的工资**

```sql
SELECT DISTINCT(salary) from employee ORDER BY salary DESC LIMIT n-1,1
```

## 2.**如何在MySQL种获取当前日期？**

```sql
SELECT CURRENT_DATE();
```

## 3.解题方法

​	根据考题要搞清楚表的结果和多表之间的关系，根据想要的结果思考使用那种关联方式，通常把要查询的列先写出来，然后分析这些列都属于哪些表，才考虑使用关联查询。

## 4.UNION与UNION ALL的区别

- 如果使用UNION ALL，不会合并重复的记录行
- 效率 UNION 高于 UNION ALL

# 八、MySQL的关联查询语句

## **六种关联查询**

- 交叉连接（CROSS JOIN）
- 内连接（INNER JOIN）
- 外连接（LEFT JOIN/RIGHT JOIN）
- 联合查询（UNION与UNION ALL）
- 全连接（FULL JOIN）
- 交叉连接（CROSS JOIN）

```
SELECT * FROM A,B(,C)或者
SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）
SELECT * FROM A,B WHERE A.id=B.id
或者SELECT * FROM A INNER JOIN B ON A.id=B.id	多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN
```

## **内连接分为三类**

- 等值连接：ON A.id=B.id
- 不等值连接：ON A.id > B.id
- 自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid

## **外连接（LEFT JOIN/RIGHT JOIN）**

- 左外连接：LEFT OUTER JOIN, **以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN**
- 右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN

## **联合查询（UNION与UNION ALL）**

```sql
SELECT * FROM A UNION SELECT * FROM B UNION ...
```

- **就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并**
- 如果使用UNION ALL，不会合并重复的记录行
- 效率 UNION 高于 UNION ALL

## **全连接（FULL JOIN）**

- **MySQL不支持全连接**
- 可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用

```sql
SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id
```

**嵌套查询**用一条SQL语句得结果作为另外一条SQL语句得条件，效率不好把握SELECT * FROM A WHERE id IN (SELECT id FROM B)

# 九、InnoDB和MyISAM的区别

​	InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table 时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。

**注意的是，当count(*)语句包含where条件时，两种表的操作是一样的。也就是 上述“6”中介绍到的InnoDB使用表锁的一种情况。**

## MyISAM适合：

l  做很多count 的计算；

l  插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择；

l  没有事务。

## InnoDB适合：

l  可靠性要求比较高，或者要求事务；

l  表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定数据引擎的创建；

l  如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表；

l  DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除；

l  LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。

要注意，创建每个表格的代码是相同的，除了最后的 TYPE参数，这一参数用来指定数据引擎。

## 其他区别

1、对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引(索引可以为主键索引，当然也可以为非主键索引)，但是在MyISAM表中，可以和其他字段一起建立联合索引。

2、DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。

3、LOAD TABLE FROMMASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。

4、 InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。

5、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。





