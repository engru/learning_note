# 玩转数据结构

# 一、数组

​	数组优点：快速查询；数组最好用于“索引有语义”的情况；但并非所有有语义的索引都适用于数组；例： 身份证号就不适合，占用空间太大；数组也可以处理 “索引没有语义 ”的情况。

## 1 整型数组

​	**Java 自身的数组是静态数组，不具有对内存空间增、删、改、查功能；故二次分装自己的内存，为动态数组。**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123203028943.png)

自己的数组类： Array

data:数组名称

size:数组中实际装入元素的长度

capacity:数组定义的长度（容量）

代码如下：

```java
public class OurOwnArray {
    private int[] data;     //定义int 型数组 data
    private int size;       //data数组中有效元素的数量

    /**
     * @param capacity 数组的容量
     */
    // 构造函数，传入数组的容量capacity构造Array，数组容量与size无关
    //数组容量没有必要单独定义一个变量，只要声明函数的时候传入即可
    public OurOwnArray(int capacity) {
        data = new int[capacity];
        size = 0;
    }

    // 无参数的构造函数，默认数组的容量capacity=10
    public OurOwnArray() {
        this(10);
    }

    // 获取数组的容量
    public int getCapacity() {
        return data.length;
    }

    // 获取数组中的元素个数
    public int getSize() {
        return size;
    }

    // 返回数组是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    // 向所有元素后添加一个新元素
    public void addLast(int e) {
        //data[size++]=e    相当于下面两句
//        data[size] = e;
//        size++;
        add(size, e);
    }

    // 在所有元素前添加一个新元素
    public void addFirst(int e) {
        add(0, e);
    }

    // 在index索引的位置插入一个新元素e
    public void add(int index, int e) {
        if (size == data.length) {
            throw new IllegalArgumentException("out of capacity");
        }
        //索引不合格,这里index可以等于size，刚开始都是0
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("index illegal");
        }
        for (int i = size - 1; i >= index; i--) {
            data[i + 1] = data[i];  //从插入的位置开始，数组后移，后面的值覆盖前面的值
        }
        data[index] = e;       //覆盖原来的值
        size++;
    }

    // 获取index索引位置的元素
    public int get(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        return data[index];
    }

    // 修改index索引位置的元素为e
    public void set(int index, int e) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        data[index] = e;
    }

    // 查找数组中是否有元素e
    public boolean contains(int e) {
        for (int i = 0; i < size; i++) {
            if (data[i] == e) {
                return true;
            }
        }
        return false;
    }

    // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1,只能查找到一个元素e
    public int find(int e) {
        for (int i = 0; i < size; i++) {
            if (data[i] == e) {
                return i;
            }
        }
        return -1;
    }

    // 从数组中删除index位置的元素, 返回删除的元素,与插入相反
    public int delete(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        int temp = data[index];     //返回删除的元素
        for (int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];      //从删除的索引开始，插入的索引后面，数组左移
        }
        size--;
        return temp;
    }

    public int delFirst() {
        return delete(0);
    }

    public int delLast() {
        return delete(size - 1);
    }

    // 从数组中删除元素e,只删除一个元素e
    public void delElement(int e) {
        int index = find(e);
        if (index != -1) {  //数组中有这个元素
            delete(index);
        }
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format("Array：size=%d,capacity=%d\n", size, data.length));
        res.append('[');
        for (int i = 0; i < size; i++) {
            res.append(data[i]);
            if (i != size - 1) {
                res.append(", ");
            }
        }
        res.append(']');
        return res.toString();
    }
}
```

## 2 泛型数组

​	泛型：使数据结构可以放置所有的“数据类型”；**但只能放置类对象，不能是基本数据类型**（boolean、byte、char、short、int、long、float、double），为了解决这个问题，Java 中每个基本数据类型都有对应的包装类（将本来不是类对象的变成了类对象）；

​	**基本数据类型对应的包装类[Boolean、Byte、Char、Short、Int、Long、Float、Double ]  二者之间可以互相转换。**

```java
//泛型数组，E为类对象，所有判断元素相等的时候要用equal方法
public class TOurOwnArray<E>{
    private E[] data;
    ...
    // 构造函数，传入数组的容量capacity构造Array，数组容量与size无关
    //数组容量没有必要单独定义一个变量，只要声明函数的时候传入即可
    public TOurOwnArray(int capacity) {
        //java 中不支持直接new出泛型数组
        // 需要通过object创建一个数组，然后再转换为E[]
        data = (E[]) new Object[capacity];
        size = 0;
    }
    ...
    //将上面的数组int改为E类型就可以了
    // 从数组中删除index位置的元素, 返回删除的元素,与插入相反
    public E delete(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        E temp = data[index];     //返回删除的元素
        for (int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];      //从删除的索引开始，插入的索引后面，数组左移
        }
        size--;
        data[size] = null; // loitering objects != memory leak 使数组最后引用中的值被垃圾回收
        return temp;
    }
    ...
}
```

## 3动态数组

​	动态数组是为了解决数组空间不够用的情况，**Java 中的静态数组，当插入的值数量 > 数组的size 时就会报错，使用动态数组可以解决这个问题，**

​	**设置动态数组的思路**：再建立一个新的数组newData，它要比之前的数组空间大一些；将data 中的数据放入到 newData 中，**循环遍历数组data中所有的元素，将他们依次赋值到 newData 中；**	

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230804821.png)

**==想让 newData 取代原来的 data ,对数组而言，容量（capacity）已经变为 8 ；size 在newData中还是 4 ，但数组可以装入更多的元素；==**![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230853839.png)

​	将数组data的**引用改为指向 新的有8个空间的数组**，与newData的引用相同,指向同样的空间；整个过程封装在函数中，当函数执行完成后，newData 就会失效了；而 data 是整个类的成员变量，和整个类的成员变量是相同的，只要类在使用则data就是有效的；![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230904146.png)

**==之前的4个空间的数组，因为已经没有引用了，垃圾回收器会将其销毁；数组完成扩容==**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190123230911188.png)

```java
public class DynamicTOurOwnArray<E> {
    private E[] data;     //定义int 型数组 data
    private int size;       //data数组中有效元素的数量

    /**
     * @param capacity 数组的容量
     */
    // 构造函数，传入数组的容量capacity构造Array，数组容量与size无关
    //数组容量没有必要单独定义一个变量，只要声明函数的时候传入即可
    public DynamicTOurOwnArray(int capacity) {
        //java 中不支持直接new出泛型数组
        // 需要通过object创建一个数组，然后再转换为E[]
        data = (E[]) new Object[capacity];
        size = 0;
    }

    // 无参数的构造函数，默认数组的容量capacity=10
    public DynamicTOurOwnArray() {
        this(10);
    }

    // 获取数组的容量
    public int getCapacity() {
        return data.length;
    }

    // 获取数组中的元素个数
    public int getSize() {
        return size;
    }

    // 返回数组是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    // 向所有元素后添加一个新元素
    public void addLast(E e) {
        //data[size++]=e    相当于下面两句
//        data[size] = e;
//        size++;
        add(size, e);
    }

    // 在所有元素前添加一个新元素
    public void addFirst(E e) {
        add(0, e);
    }

    // 在index索引的位置插入一个新元素e
    public void add(int index, E e) {
        //索引不合格,这里index可以等于size，刚开始都是0
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("index illegal");
        }
        if (size == data.length) {
            resize(2 * data.length);    //进行数组扩容，变为原来的2倍
        }
        for (int i = size - 1; i >= index; i--) {
            data[i + 1] = data[i];  //从插入的位置开始，数组后移，后面的值覆盖前面的值
        }
        data[index] = e;       //覆盖原来的值
        size++;
    }

    // 将数组空间的容量变成newCapacity大小（2倍）
    private void resize(int newCapacity) {
        E[] newData = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {       //new 一个新的E型数组newData
            newData[i] = data[i];     //将原来的数组内容放入到新的newData中
        }
        data = newData;       //让 data 指向 newData 的空间
    }

    // 获取index索引位置的元素
    public E get(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        return data[index];
    }

    // 修改index索引位置的元素为e
    public void set(int index, E e) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        data[index] = e;
    }

    // 查找数组中是否有元素e
    public boolean contains(E e) {
        for (int i = 0; i < size; i++) {
            if (data[i].equals(e)) {
                return true;
            }
        }
        return false;
    }

    // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1,只能查找到一个元素e
    public int find(E e) {
        for (int i = 0; i < size; i++) {
            if (data[i].equals(e)) {
                return i;
            }
        }
        return -1;
    }

    // 从数组中删除index位置的元素, 返回删除的元素,与插入相反
    public E delete(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("index illegal");
        }
        E temp = data[index];     //返回删除的元素
        for (int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];      //从删除的索引开始，插入的索引后面，数组左移
        }
        size--;
        data[size] = null; // loitering objects != memory leak 使数组最后引用中的值被垃圾回收
        //缩小一半
        if (size == data.length / 2) {
            resize(data.length / 2);
        }
        return temp;
    }

    public E delFirst() {
        return delete(0);
    }

    public E delLast() {
        return delete(size - 1);
    }

    // 从数组中删除元素e,只删除一个元素e
    public void delElement(E e) {
        int index = find(e);
        if (index != -1) {  //数组中有这个元素
            delete(index);
        }
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format("Array：size=%d,capacity=%d\n", size, data.length));
        res.append('[');
        for (int i = 0; i < size; i++) {
            res.append(data[i]);
            if (i != size - 1) {
                res.append(", ");
            }
        }
        res.append(']');
        return res.toString();
    }
}
```

## 4.复杂度分析

时间复杂度分析：例：O(1)、O(n)、O(lgn)、O(nlogn)、O(n^2)

O:描述的是算法的运行时间和输入数据之间的关系

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124131518511.png)

​	上图中：c1指在for 循环中，将nums这个数组里面的元素取出来、将sum这个数取出来、将sum和nums 加在一起、最后将结果扔回给sum变量这些操作花费的总时间；实际中无法具体取得

​	c2指在整个程序中，开辟 Int 型空间 sum，并将0的初始化空间赋值给 sum,在运算结束后，还有返回sum，这些操作花费的总时间；实际中无法具体取得。

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132103936.png)

​	前两个忽略常数，都是O(n),虽然第三个的常数值很小，但它还是O(n^2),但并不代表：对于任意输入来说，O(n)都要优于O(n^2)，**O 是渐进时间复杂度**，【描述 n 趋近于无穷的情况来比较算法的性能】；最后一个中，低阶的300n 相比 n^2(高阶)可忽略，故为O(n^2)；

### 1.动态数组的时间复杂度分析

##### 添加操作：通常情况下（按最坏的情况看）是 O(n) 

​	addLast(e) ---O(1)   :该操作所消耗时间与数据规模没有关系，**无论数组中有多少元素，addLast都能在常数时间内完成。**

​	addFirst(e) ---O(n)   :数组头添加元素需要**将数组每个元素向后移动一个单位，故为O(n)。**

​	add(index,e) ---O(n/2)=O(n)  :在数组 index 索引的位置插入元素e，时间复杂度与 index 相关，index = 0时和addFirst(e)相同；index = size时和addLast(e)相同，分析：假设多种情况下的概率相同，运用概率论的知识，求出时间的期望。**平均来看需要右移动 n/2 个元素，O需要忽略常数，故为 O(n)。**

##### 删除操作：通常情况下（==按最坏的情况看==）是 O(n) 

​	removeLast(e) ---O(1) 

​	removeFirst(e) ---O(n) 

​	remove(index,e) --- O(n/2)=O(n)

​	resize  ---O(n)

##### 修改操作：

已知索引：O(1)  **数组最大优势--支持随机访问，只要知道索引就可以马上访问到该数据**

未知索引：O(n)  需要从头遍历数组来找到该元素进行修改

​	**set(index,e) ---O(1)** 

##### 查找操作：需要从头遍历数组来找到该元素

​	get(index) ---O(1)  	知道所要查找元素的索引，立马可以拿到该值

​	contains(e) --- O(n)      不知道所要查找元素的索引，查看数组中是否包含某个元素

​	find(e) ---O(n)        	不知道所要查找元素的索引，查看数组中 e 元素对应的索引是多少

### 2.均摊复杂度和防止复杂度的震荡

**resize 的时间复杂度分析：**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132502059.png)

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132517730.png)

​	不会每次添加元素都会触发resize，	==因为最坏的情况（resize）要在很多次 addLast 操作后才会执行； 运用均摊复杂度比较合适；==

​	假设capacity=n，n+1次addLast，超过数组的容量，所以触发resize，相当于又加了一倍capacity的元素，所以总共进行2n+1次基本操作，平均每次addLast操作，进行2次基本操作。**这样均摊计算，addLast 和 removeLast 的均摊复杂度均为O(1);**

####  复杂度震荡

​	上面的那种所说的是大多数情况下，都不会执行resize,现在认为制造这样的情景，让 addLast 和 removeLast 依次执行多次，**这样就会每次都执行 resize ，addLast 和 removeLast 的时间复杂度均为O(n);从O(1)变为O(n)，产生复杂度震荡。**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132707690.png)

#### 解决复杂度震荡问题：

出现原因：removeLast 时 resize 过于着急,额度过于紧凑，应该减半一些

解决方案：Lazy策略，不急着缩容，设置 resize == capacity/4 时，才将 capacity 减半

图解过程：

1.添加元素超过 size ,容量扩大一倍：

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132733516.png)

**2.删除元素后，先不着急缩小数组容量**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132740344.png)

**3.等到数组长度size缩小到数组容量capacity 的1/4 时**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132739989.png)

**4.缩小数组容量，但也只缩小到原来的一半，仍然预留了一半的数组容量供数组进行 addLast 操作**

![img](https://raw.githubusercontent.com/JDawnF/learning_note/master/images/70-20190124132740299.png)

##### 代码：

```java
//数组长度size为数组容量1/4时才会缩小数组容量,size可能等于1，所以后面再加个判断
if (size == data.length / 4 && data.length/2 != 0) {
    resize(data.length / 2);
}
```

# 二、栈

​	栈是一种线性数据结构；相比数组，栈对应的操作是数组的子集，因为栈只能从一端添加元素，也只能从同一端取出元素，这一端称为栈顶。

​	向栈中添加元素【入栈】，从栈中取出栈顶元素【出栈】，**栈中的元素是后进先出(FIFO)，由此可知：数组也是一种后进先出的数据结构。**

## 1.栈的应用

### 1.1 无处不在的 Undo (撤销)操作 

例：文档中依次输入 沉迷  学习  不法  ---实际上是将这些元素压入栈中;执行 Undo 操作，--实际是从栈中拿出栈顶元素，通过栈顶元素来确认最近一次的操作是什么；然后将其删除，成功删除（出栈）后

### 1.2 程序调用的系统栈 

例：子过程（子逻辑）的调用在编译器内部的实现机理:![image-20190126114236948](/Users/jack/Desktop/md/images/image-20190126114236948.png)

A2: 程序执行到了A函数的第二行，发生中断去执行函数B

B2：程序执行到了B函数的第二行，发生中断去执行函数C

当都执行完成后，接下来如何执行需要看系统栈了，对当前的栈来说，栈顶元素是B2；故跳到B2处继续执行，然后B2出栈，

接着执行B3完成整个函数B；接下来如何执行需要再看系统栈了，栈顶元素是A2，故跳到A2处继续执行，然后A2出栈，接着执行A3完成整个函数A；接下来如何执行需要再看系统栈，栈中已经没有元素了，表示没有之前中断的程序了，故系统知道已经没有要执行的程序了。

## 2.栈的实现

栈Stack<E>的基本操作：

void push(E)   --- 【入栈】向栈中添加元素              时间复杂度：O(1)

E pop()   ---【出栈】从栈中拿出栈顶元素                 时间复杂度：O(1)

E peek()   ---查看栈顶元素                                        时间复杂度：O(1)

int getSize()  ---查看栈中总共有多少个元素              时间复杂度：O(1)

boolean isEmpty()   ---判断栈是否为空                     时间复杂度：O(1)

##### 实现基于动态数组的栈：

```java
public interface Stack<E> {
    int getSize();        //查看栈中总共有多少个元素

    boolean isEmpty();    //判断栈是否为空

    void push(E e);        //【入栈】向栈中添加元素

    E pop();            //【出栈】从栈中拿出栈顶元素

    E peek();            //查看栈顶元素
}
```

```java
public class ArrayStack<E> implements Stack<E> {
    DynamicTOurOwnArray<E> array;

    /**
     * 构造函数，传入数组的容量capacity构造Array
     * @param capacity
     */
    public ArrayStack(int capacity) {
        array=new DynamicTOurOwnArray<>(capacity);
    }

    public ArrayStack() {
        array=new DynamicTOurOwnArray<>();
    }

    // 获取数组中的元素个数
    @Override
    public int getSize() {
        return array.getSize();
    }

    @Override
    public boolean isEmpty() {
        return array.isEmpty();
    }

    @Override
    public void push(E e) {
        array.addLast(e);
    }

    @Override
    public E pop() {
        return array.delLast();
    }

    @Override
    public E peek() {
        return array.getLast();
    }

    /**
     * 查看静态数组的容量
     * @return  数组容量
     */
    public int getCapacity(){
        return array.getCapacity();
    }

    @Override
    public String toString(){
        StringBuilder res = new StringBuilder();
        res.append("Stack: ");
        res.append('[');
        for(int i = 0 ; i < array.getSize() ; i ++){
            res.append(array.get(i));
            if(i != array.getSize() - 1)
                res.append(", ");
        }
        res.append("] top");   //横向排列，栈顶在数组右侧
        return res.toString();
    }
}
```

## 3.栈的另一个应用--（括号匹配）

![img](/Users/jack/Desktop/md/images/70-20190126121608624.png)

思路分析：

​	声明一个栈，然后逐一遍历字符串中的每一个字符，如果这个字符是一个左括号，就将其压入栈中；完成之后，判断右括号是否和栈顶的左括号相匹配，如果匹配成功就可以出栈；直至所有的都匹配成功，这时所有的元素都出栈，栈为空时表明字符串是一个有效的字符串。如果不是有效的字符串，在右括号与左括号相匹配时不能匹配成功，直接停止返回这是一个错误的字符串。

栈顶元素反映了在嵌套的层次关系中，最近的需要匹配的元素。

```java
public class StackSample {
    public boolean isValid(String s) {
        //声明栈stack
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            //获取字符串的第i个元素
            char c = s.charAt(i);
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) {
                    return false;
                }
                //取栈顶元素，与准备入栈的元素进行匹配
                char topChar = stack.pop();
                if (c == ')' && topChar != '(') {
                    return false;
                }
                if (c == ']' && topChar != '[') {
                    return false;
                }
                if (c == '}' && topChar != '{') {
                    return false;
                }
            }
        }
        return stack.isEmpty();     //判断栈是否为空,如果是空的话则匹配成功
    }

    public static void main(String[] args) {

        System.out.println((new StackSample()).isValid("()[]{}"));    //传入测试用例
        System.out.println((new StackSample()).isValid("([)]"));
    }
}
```

# 三、队列

​	队列是一种线性数据结构；相比数组，队列对应的操作也是数组的子集；只能从一端（队尾）添加元素，只能从另一端（队首）取出元素，队列是先进先出的数据结构（First In First Out [FIFO]）。

## 1.队列的实现

队列Queue<E>的基本操作：

void enqueue(E)   --- 【入队】向队列中添加元素              时间复杂度：O(1)

E dequeue()   ---【出队】从队列中拿出队首元素                 时间复杂度：O(n)【队首后面的所有的元素都要移动一下】

E getFornt()   ---查看队首元素                                        时间复杂度：O(1)

int getSize()  ---查看队列中总共有多少个元素              时间复杂度：O(1)

boolean isEmpty()   ---判断队列是否为空                     时间复杂度：O(1)

## 2.数组队列的问题









































































































































































































































































































































































































































































































































































































































