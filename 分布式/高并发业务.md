# 高并发业务

## 一、高并发系统的分析和设计

## 1.有效请求和无效请求

​	简单来说，那些刷票、不但请求网站的请求基本可以视为无效请求。对于无效请求，常见的应对方法有很多。比如：**加入验证码。 一般而言，首次无验证码以便用户减少录入，第二次请求开始加入验证码，可以是图**
**片验证码、等式运算等。**；还可以用短信服务，这些应该放在负载均衡器上进行区分。![image-20181218152738339](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20181218152738339-5118058.png?raw=true)

​	这是对一个账号连续无效请求的压制 ，有时候有些用户可能申请多个账 号来迷惑服务 器，使得他可以避开对单个账户的验证，从而获得更多的服务器资源。 一个人多个账户的 场景还是 比较好应付的，可以通过提高账户的等级来压制多个请求，**比如对于支付交易的 网站，可以通过银行卡验证，实名制获取相关证件号码，从而使用证件号码使得多个账户 归结为 一人，通过这层关系来屏蔽多个账号的频繁请求，这样就有效地规避了 一个人多个 账号的频繁请求。** 

​	对于有组织的请求，则不是那么容易了 ，因为对于一些黄牛组织，可能通过多人的账 号来发送请求，统一组织伪造有效请求，**我们会考虑使用僵尸账号 排除法对可交易的账 号进行排除，所谓僵尸账号 ，是指那些平时没有任何交易的账号，只是在特殊的日子交易，比如春运期间进行大批量抢购的账号。当请求达到服务器，我们通过僵尸账号，排除掉一些无效请求。当然还能使用 IP 封禁，尤其是通过同 一 IP 或者网段频繁请求的，但是这样也许会误伤有效请求，所以使用 IP封禁还是要慎重一些。** 

## 2.系统设计

​	1.水平分法，按业务分，一个服务负责一个业务，然后不同业务之间通过远程过程调用协议RPC进行调用，比较流行的 RPC 有 Dubbo、 Thrift和 Hessian 等。**其原理是，每一个服务都会暴露一些公共的接口给 RPC 服务，这样对于任何一个服务器都能够通过 RPC 服务获取其他服务器对应的接口去调度各个服务器的逻辑来完成功能，但是接口的相互调用也会造成一定的缓慢。**

![image-20181218154525875](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20181218154525875-5119125.png?raw=true)

​	2.垂直分法，所谓垂直分法就是将 一个很大的请求量，不按子系统分，而是将它们按照互不相干的几个同样的系统分摊下去，即之间分法请求到不同的服务器，而这些服务器执行各自的业务。![image-20181218154603938](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20181218154603938-5119163.png?raw=true)

​	3.垂直和水平结合：![image-20181218154852130](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20181218154852130-5119332.png?raw=true)

​	**首先将系统按照业务区分为多个子系统，然后在每一个子系统下再分多个服务器，通过每一个子系统的路由器找到对应的子系统服务器提供服务。**	

## 3.数据库设计

##### 	可以通过分库或者分表优化数据库。

​	分表是指在一个数据库 内本来一张表可 以保存的数据 ， 设计成多张表去保存 ， 比如交易表t_transaction。由于存储数据多会造成查询和统计的缓慢，这个时候可以使用多个表存储，比如2016年的数据用表t_transaction_2016存储，2017年的数据使用表t_transaction_2017存储， 2018年的数据则用表t_transaction_2018存储， 依此类推，开发者只要根据查询的年份确定需要查找哪张表就可以了。![image-20181218160110203](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20181218160110203-5120070.png?raw=true)

​	分库则不一样 ，它把表数据分配在不同的数据库中，比如上面的t_transaction可以存放在多个数据库中，如图：![image-20181218160223808](https://learningpics.oss-cn-shenzhen.aliyuncs.com/images/image-20181218160223808-5120143.png?raw=true)

​	分库数据库首先需要一个路 由算法确定数据在哪个数据库上，然后才能进行查询 ， 比如我们可以把用户和对应业务的数据库的信息缓存到 Redis 中，这样路由算法就可以通过Redis读取的数据来决定使用哪个数据库进行查询了 。		

​	一些会员很多的网站还可以区分活跃会员和非活跃会员 。 活跃会员可以通过数据迁徙的手段，也就是先记录在某个时间段( 比如一个月的月底)会员的活跃度， 然后通过数据迁徙 ， 将活跃会员较平均分摊到各个数据库中 ，以避免某个库过多 的集中活跃会员，而导致个别数据库被访问过多，从而达到数据库的负载均衡。	

##### 	除了分库分表，还可以考虑优化SQL，建立索引等优化，提高数据库的性能。

​	在开发网站中使用更新语句和复杂查询语句要时刻记住更新是表锁定还是行锁定 ，比如 id 是主键 ， 而 user name是用户名称，也是唯一索引，更新用户的生日，可以使用以下两条 SQL 中的任何一条 : 

```sql
update t user set birthday = #{birthday} where id= #{id};
update t user set birthday= #{birthday} where user name= #{userName} ;
```

​	**上面的语句都正确，但是优选使用主键更新 ， 其原因是在 MySQL 的运行过程中，第二句 SQL 会锁表，即不仅锁定更新的数据，而且锁定其他表的数据，从而影响并发，而使用主键的更新则是行锁定。**

​	除了上面的sql优化，还要注意平时要少用not in和not exists这样的语句，应该全部改为连接语句去执行，如下面的语句应该改成连接语句：

```
SELECT u.id FROM t_user u WHERE u.id NOT IN (SELECT ur.user_id FROM t_user_role ur);

select u.id from t_user u left join t_user_role ur on u.id = ur.user_id where ur.user_id is null ;	
```

​	对于分布式数据库而言，还会有另外一个麻烦，就是事务的一致性，事务的一致性比较复杂 ，目前流行的有两段提交协议，即 **XA 协议、 Paxos 协议。**	







参照：《Java EE互联网轻量级框架整合开发 SSM框架（Spring MVC+Spring+MyBatis）和Redis实现》